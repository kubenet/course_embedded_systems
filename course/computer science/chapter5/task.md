
# Курс: Информатика
## Практическое занятие №5. "Погружение в Python"

### 1. Извлечение и переназначение элементов списка

Попробуйте несколько поисков:

```python
>>> symlist =['HPQ', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'DOA', 'GOOG']
>>> symlist[0]
'HPQ'
>>> symlist[1]
'AAPL'
>>> symlist[-1]
'GOOG'
>>> symlist[-2]
'DOA'
>>>
```

Попробуйте переназначить одно значение:

```python
>>> symlist[2] = 'AIG'
>>> symlist
['HPQ', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'DOA', 'GOOG']
>>>
```

Возьмите несколько кусочков:

```python
>>> symlist[0:3]
['HPQ', 'AAPL', 'AIG']
>>> symlist[-2:]
['DOA', 'GOOG']
>>>
```

Создайте пустой список и добавьте в него элемент.

```python
>>> mysyms = []
>>> mysyms.append('GOOG')
>>> mysyms
['GOOG']
```

Вы можете переназначить часть списка другому списку. Например:

```python
>>> symlist[-2:] = mysyms
>>> symlist
['HPQ', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'GOOG']
>>>
```

Когда вы это сделаете, размер списка в левой части (`symlist`) будет изменен соответствующим образом, чтобы поместилась правая часть (`mysyms`). Например, в приведенном выше примере последние два элемента `symlist` были заменены единственным элементом в списке `mysyms`.

### 2. Перебор элементов списка

Цикл `for` работает путем перебора данных в такой последовательности, как список. Проверьте это, набрав следующий цикл и наблюдая, что происходит:

```python
>>> for s in symlist:
        print('s =', s)
# Look at the output
```

### 3. Тесты на членство

Используйте оператор `in` или `not in`, чтобы проверить, присутствуют ли `AIG`, `AA` и `CAT` в списке символов.

```python
>>> # Is 'AIG' IN the `symlist`?
True
>>> # Is 'AA' IN the `symlist`?
False
>>> # Is 'CAT' NOT IN the `symlist`?
True
>>>
```

### 4. Добавление, вставка и удаление элементов

Используйте метод `append()`, чтобы добавить символ `RHT` в конец `symlist`.

```python
>>> # append 'RHT'
>>> symlist
['HPQ', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'GOOG', 'RHT']
>>>
```

Используйте метод `insert()`, чтобы вставить символ `AA` в качестве второго элемента в списке.

```python
>>> # Insert 'AA' as the second item in the list
>>> symlist
['HPQ', 'AA', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'GOOG', 'RHT']
>>>
```

Используйте метод `remove()`, чтобы удалить `MSFT` из списка.

```python
>>> # Remove 'MSFT'
>>> symlist
['HPQ', 'AA', 'AAPL', 'AIG', 'YHOO', 'GOOG', 'RHT']
>>>
```

Добавьте дублирующую запись для `YHOO` в конец списка.


```python
>>> # Append 'YHOO'
>>> symlist
['HPQ', 'AA', 'AAPL', 'AIG', 'YHOO', 'GOOG', 'RHT', 'YHOO']
>>>
```
Используйте метод `index()`, чтобы найти первую позицию `YHOO` в списке.

```python
>>> # Find the first index of 'YHOO'
4
>>> symlist[4]
'YHOO'
>>>
```

Посчитайте, сколько раз `YHOO` встречается в списке:

```python
>>> symlist.count('YHOO')
2
>>>
```

Удалите первое появление `YAHOO`.

```python
>>> # Remove first occurrence 'YHOO'
>>> symlist
['HPQ', 'AA', 'AAPL', 'AIG', 'GOOG', 'RHT', 'YHOO']
>>>
```

Just so you know, there is no method to find or remove all occurrences of an item.
However, we'll see an elegant way to do this in section 2.

### 5. Сортировка

Хотите отсортировать список? Используйте метод `sort()`. Попробуйте:

```python
>>> symlist.sort()
>>> symlist
['AA', 'AAPL', 'AIG', 'GOOG', 'HPQ', 'RHT', 'YHOO']
>>>
```

Хотите отсортировать в обратном порядке? Попробуй это:

```python
>>> symlist.sort(reverse=True)
>>> symlist
['YHOO', 'RHT', 'HPQ', 'GOOG', 'AIG', 'AAPL', 'AA']
>>>
```

Примечание. При сортировке списка его содержимое изменяется «на месте». То есть элементы списка перемешиваются, но в результате новый список не создается.

### 6. Собираем все обратно

Хотите взять список строк и объединить их в одну строку? Используйте метод `join()` для таких строк (обратите внимание: на первый взгляд это выглядит забавно).

```python
>>> a = ','.join(symlist)
>>> a
'YHOO,RHT,HPQ,GOOG,AIG,AAPL,AA'
>>> b = ':'.join(symlist)
>>> b
'YHOO:RHT:HPQ:GOOG:AIG:AAPL:AA'
>>> c = ''.join(symlist)
>>> c
'YHOORHTHPQGOOGAIGAAPLAA'
>>>
```

### 7. Списки чего угодно

Списки могут содержать объекты любого типа, включая другие списки (например, вложенные списки).
Попробуйте это:

```python
>>> nums = [101, 102, 103]
>>> items = ['spam', symlist, nums]
>>> items
['spam', ['YHOO', 'RHT', 'HPQ', 'GOOG', 'AIG', 'AAPL', 'AA'], [101, 102, 103]]
```

Обратите пристальное внимание на приведенный выше вывод. `items` — это список из трех элементов.
Первый элемент — это строка, а два других элемента — это списки.

Вы можете получить доступ к элементам во вложенных списках, используя несколько операций индексирования.

```python
>>> items[0]
'spam'
>>> items[0][0]
's'
>>> items[1]
['YHOO', 'RHT', 'HPQ', 'GOOG', 'AIG', 'AAPL', 'AA']
>>> items[1][1]
'RHT'
>>> items[1][1][2]
'T'
>>> items[2]
[101, 102, 103]
>>> items[2][1]
102
>>>
```

Хотя технически возможно составить очень сложный список структуры, как правило, вы хотите, чтобы все было просто. Обычно списки содержат элементы, имеющие одинаковое значение. Для например, список, полностью состоящий из чисел, или список текста струны. Смешивание разных типов данных в одном списке часто это хороший способ взорвать голову, поэтому его лучше избегать.

Вместо создания списка с помощью цикла можно использовать понимание списка с довольно понятным синтаксисом.

```python
[i**2 for i in range(4)]
[0, 1, 4, 9]
```

### 7. Файлы

Эти упражнения зависят от файла `data/portfolio.csv`. Файл содержит список строк с информацией о портфеле акций. Предполагается, что вы работаете в `$YOUR_PATH_TO_COURSE/course_embedded_systems/course/computer science/chapter5/`. Если вы не уверены, вы можете узнать, где думает Python. он работает:

```python
>>> import os
>>> os.getcwd()
'$PWD' # Output vary
>>>
```
Сначала попробуйте прочитать весь файл сразу как большую строку:

```python
>>> with open('Data/portfolio.csv', 'rt') as f:
        data = f.read()

>>> data
'name,shares,price\n"AA",100,32.20\n"IBM",50,91.10\n"CAT",150,83.44\n"MSFT",200,51.23\n"GE",95,40.37\n"MSFT",50,65.10\n"IBM",100,70.44\n'
>>> print(data)
name,shares,price
"AA",100,32.20
"IBM",50,91.10
"CAT",150,83.44
"MSFT",200,51.23
"GE",95,40.37
"MSFT",50,65.10
"IBM",100,70.44
>>>
```
Следует отметить, что в приведенном выше примере Python имеет два режима работы. выход. В первом режиме, когда вы вводите data в командной строке, Python показывает необработанное строковое представление, включая кавычки и `escape коды`. Когда вы вводите `print(data)`, вы получаете фактически отформатированный вывод строки. 
Хотя прочитать файл целиком сразу несложно, зачастую это не самая простая задача. наиболее подходящий способ сделать это, особенно если файл оказывается огромный или содержит строки текста, которые вы хотите обрабатывать по одной время.
Чтобы прочитать файл построчно, используйте такой цикл:

```python
>>> with open('Data/portfolio.csv', 'rt') as f:
        for line in f:
            print(line, end='')

name,shares,price
"AA",100,32.20
"IBM",50,91.10
...
>>>
```

Когда вы используете этот код, как показано, строки читаются до конца
файл достигнут, и в этот момент цикл останавливается.

В некоторых случаях вам может потребоваться вручную прочитать или пропустить
*одна* строка текста (например, возможно, вы хотите пропустить первую строку
заголовков столбцов).

```python
>>> f = open('Data/portfolio.csv', 'rt')
>>> headers = next(f)
>>> headers
'name,shares,price\n'
>>> for line in f:
    print(line, end='')

"AA",100,32.20
"IBM",50,91.10
...
>>> f.close()
>>>
```

`next()` возвращает следующую строку текста в файле. Если бы вы вызывали его несколько раз, вы бы получили последовательные строки. Однако, как вы знаете, цикл for уже использует `next()` для получения данных.
Таким образом, вы обычно не будете вызывать его напрямую, если не пытаетесь явно пропустить или прочитать одну строку, как показано.

Прочитав строки файла, вы можете начать выполнять дополнительную обработку, например разделение.
Например, попробуйте следующее:

```python
>>> f = open('Data/portfolio.csv', 'rt')
>>> headers = next(f).split(',')
>>> headers
['name', 'shares', 'price\n']
>>> for line in f:
    row = line.split(',')
    print(row)

['"AA"', '100', '32.20\n']
['"IBM"', '50', '91.10\n']
...
>>> f.close()
```

*Примечание. В этих примерах `f.close()` вызывается явно, поскольку оператор `with` не используется.*

### 8. Чтение из файла


Теперь, когда вы знаете, как читать файл, давайте напишем программу, выполняющую простые вычисления.

Столбцы в `portfolio.csv` соответствуют названию акции, количеству акций и цена покупки одного пакета акций. Напишите программу под названием `pcost.py`, который открывает этот файл, читает все строки и вычисляет, как
сколько стоит покупка всех акций в портфеле.

*Подсказка: чтобы преобразовать строку в целое число, используйте `int(s)`. Чтобы преобразовать строку в число с плавающей запятой, используйте `float(s)`.*

Ваша программа должна вывести вывод, подобный следующему:

```bash
Total cost 44671.15
```

###  9. Другие виды «файлов»

Что делать, если вы хотите прочитать нетекстовый файл, например сжатый gzip? файл данных? Встроенная функция `open()` вам здесь не поможет, но В Python есть библиотечный модуль `gzip`, который может читать сжатые `gzip` файлы.

Попробуйте 

```python
>>> import gzip
>>> with gzip.open('Data/portfolio.csv.gz', 'rt') as f:
    for line in f:
        print(line, end='')

... look at the output ...
>>>
```

Примечание. Включение файлового режима `rt` здесь имеет [решающее значение](https://docs.python.org/3/library/functions.html#open). Если вы забудете про это, вы получите байтовые строки вместо обычных текстовых строк.

### 10. Определение функции

Попробуйте определить простую функцию:

```python
>>> def greeting(name):
        'Issues a greeting'
        print('Hello', name)

>>> greeting('Guido')
Hello Guido
>>> greeting('Paula')
Hello Paula
>>>
```

Если первый оператор функции является строкой, он служит документацией.
Попробуйте ввести команду, например `help(greeting)`, чтобы увидеть ее отображение.

### 11. Превращение скрипта в функцию

Возьмите код, который вы написали для программы pcost.py, и превратите его в функцию `portfolio_cost(filename)`. Функция принимает имя файла в качестве входных данных, считывает данные портфеля из этого файла и возвращает общую стоимость портфеля в виде числа с плавающей запятой.

Чтобы использовать вашу функцию, измените свою программу так, чтобы она выглядела как-то
так:

```python
def portfolio_cost(filename):
    ...
    # Your code here
    ...

cost = portfolio_cost('data/portfolio.csv')
print('Total cost:', cost)
```

Когда вы запустите программу, вы должны увидеть тот же результат, что и раньше. После запуска программы вы также можете вызвать свою функцию в интерактивном режиме, набрав это:

```bash
bash $ python3 -i pcost.py
```

Это позволит вам вызывать функцию из интерактивного режима.

```python
>>> portfolio_cost('Data/portfolio.csv')
44671.15
>>>
```

Возможность интерактивно экспериментировать с кодом полезна для тестирования и отладки.

### 12. Обработка ошибок

Что произойдет, если вы попробуете свою функцию с файлом, в котором отсутствуют некоторые поля?

```python
>>> portfolio_cost('Data/missing.csv')
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "pcost.py", line 11, in portfolio_cost
    nshares    = int(fields[1])
ValueError: invalid literal for int() with base 10: ''
>>>
```

На этом этапе вы столкнулись с решением. Чтобы программа работала вы можете либо очистить исходный входной файл, удалив плохие строк или вы можете изменить свой код для обработки плохих строк в некоторых
образом.

Измените программу `pcost.py`, чтобы перехватить исключение и вывести предупреждение сообщение и продолжите обработку остальной части файла.

### 13. Использование библиотечной функции

Python поставляется с большой стандартной библиотекой полезных функций. Одна из библиотек, которая может быть здесь полезна, — это модуль `csv`. Вам следует использовать его всякий раз, когда вам приходится работать с файлами данных CSV. Вот пример того, как это работает:

```python
>>> import csv
>>> f = open('Data/portfolio.csv')
>>> rows = csv.reader(f)
>>> headers = next(rows)
>>> headers
['name', 'shares', 'price']
>>> for row in rows:
        print(row)

['AA', '100', '32.20']
['IBM', '50', '91.10']
['CAT', '150', '83.44']
['MSFT', '200', '51.23']
['GE', '95', '40.37']
['MSFT', '50', '65.10']
['IBM', '100', '70.44']
>>> f.close()
>>>
```

Одна из приятных особенностей модуля `csv` заключается в том, что он обрабатывает множество низкоуровневых деталей, таких как кавычки и правильное разделение запятых. В приведенном выше выводе вы заметите, что из имен в первом столбце удалены двойные кавычки.

Измените свою программу `pcost.py` так, чтобы она использовала модуль `csv` для анализа, и попробуйте запустить более ранние примеры.

### 14. Чтение из командной строки

В программе `pcost.py` имя входного файла жестко встроено в код:

```python
# pcost.py

def portfolio_cost(filename):
    ...
    # Your code here
    ...

cost = portfolio_cost('Data/portfolio.csv')
print('Total cost:', cost)
```

Это нормально для обучения и тестирования, но в реальной программе вы, вероятно, не будете этого делать.

Вместо этого вы можете передать имя файла в качестве аргумента скрипту. Попробуйте изменить нижнюю часть программы следующим образом:

```python
# pcost.py
import sys

def portfolio_cost(filename):
    ...
    # Your code here
    ...

if len(sys.argv) == 2:
    filename = sys.argv[1]
else:
    filename = 'Data/portfolio.csv'

cost = portfolio_cost(filename)
print('Total cost:', cost)
```

`sys.argv` — это список, содержащий переданные аргументы в командной строке (если таковые имеются).

Чтобы запустить вашу программу, вам нужно запустить `Python` из терминала.
Например, из `bash` в `Unix`:

```bash
bash % python3 pcost.py Data/portfolio.csv
Total cost: 44671.15
bash %
```

### 15. Список кортежей

Файл `data/portfolio.csv` содержит список акций в портфеле. Ранее вы написали функцию portfolio_cost(filename)`, которая читает этот файл и провели простой расчет.

В этом файле определите функцию `read_portfolio(filename)`, которая открывает данный файл портфолио и считывает его в список кортежей. Для этого вам нужно внести несколько незначительных изменений в приведенный выше код.

Во-первых, вместо определения `total_cost = 0` вы создадите переменную изначально установлен пустой список. Например:

```python
portfolio = []
```

Далее, вместо суммирования стоимости, вы превратите каждую строку в кортеж, и добавите его в этот список. Например:

```python
for row in rows:
    holding = (row[0], int(row[1]), float(row[2]))
    portfolio.append(holding)
```


Наконец, вы вернете результирующий список `portfolio`.

Поэкспериментируйте со своей функцией в интерактивном режиме

*Подсказка: используйте `-i` при выполнении файла в терминале*

```python
>>> portfolio = read_portfolio('Data/portfolio.csv')
>>> portfolio
[('AA', 100, 32.2), ('IBM', 50, 91.1), ('CAT', 150, 83.44), ('MSFT', 200, 51.23),
    ('GE', 95, 40.37), ('MSFT', 50, 65.1), ('IBM', 100, 70.44)]
>>>
>>> portfolio[0]
('AA', 100, 32.2)
>>> portfolio[1]
('IBM', 50, 91.1)
>>> portfolio[1][1]
50
>>> total = 0.0
>>> for s in portfolio:
        total += s[1] * s[2]

>>> print(total)
44671.15
>>>
```

Этот список кортежей, который вы создали, очень похож на двумерный массив. Например, вы можете получить доступ к определенному столбцу и строке, используя такой поиск, как `portfolio[row][column]`, где `row` и `column` — целые числа.

Тем не менее, вы также можете переписать последний цикл for, используя такой оператор:

```python
>>> total = 0.0
>>> for name, shares, price in portfolio:
            total += shares*price

>>> print(total)
44671.15
>>>
```

### 16: Список словарей

Возьмите функцию, которую вы написали, и измените ее так, чтобы каждая акция в портфеле представляла словарь, а не кортеж. В этом словаре используйте имена полей `name`, `shares` и `price` для представления различных столбцов во входном файле.

Поэкспериментируйте с этой новой функцией так же, как вы это делали в

```python
>>> portfolio = read_portfolio('Data/portfolio.csv')
>>> portfolio
[{'name': 'AA', 'shares': 100, 'price': 32.2}, {'name': 'IBM', 'shares': 50, 'price': 91.1},
    {'name': 'CAT', 'shares': 150, 'price': 83.44}, {'name': 'MSFT', 'shares': 200, 'price': 51.23},
    {'name': 'GE', 'shares': 95, 'price': 40.37}, {'name': 'MSFT', 'shares': 50, 'price': 65.1},
    {'name': 'IBM', 'shares': 100, 'price': 70.44}]
>>> portfolio[0]
{'name': 'AA', 'shares': 100, 'price': 32.2}
>>> portfolio[1]
{'name': 'IBM', 'shares': 50, 'price': 91.1}
>>> portfolio[1]['shares']
50
>>> total = 0.0
>>> for s in portfolio:
        total += s['shares']*s['price']

>>> print(total)
44671.15
>>>
```

Здесь вы заметите, что доступ к различным полям каждой записи осуществляется по именам ключей, а не по числовым номерам столбцов. Это часто предпочтительнее, потому что полученный код легче читать позже.

Просмотр больших словарей и списков может быть затруднительным. Чтобы очистить вывод для отладки, рассмотрите возможность использования функции pprint.

```python
>>> from pprint import pprint
>>> pprint(portfolio)
[{'name': 'AA', 'price': 32.2, 'shares': 100},
    {'name': 'IBM', 'price': 91.1, 'shares': 50},
    {'name': 'CAT', 'price': 83.44, 'shares': 150},
    {'name': 'MSFT', 'price': 51.23, 'shares': 200},
    {'name': 'GE', 'price': 40.37, 'shares': 95},
    {'name': 'MSFT', 'price': 65.1, 'shares': 50},
    {'name': 'IBM', 'price': 70.44, 'shares': 100}]
>>>
```


### 17. Подсчет

Попробуйте несколько простых примеров подсчета:

```python
>>> for n in range(10):            # Count 0 ... 9
        print(n, end=' ')

0 1 2 3 4 5 6 7 8 9
>>> for n in range(10,0,-1):       # Count 10 ... 1
        print(n, end=' ')

10 9 8 7 6 5 4 3 2 1
>>> for n in range(0,10,2):        # Count 0, 2, ... 8
        print(n, end=' ')

0 2 4 6 8
>>>
```

### 18. Дополнительные операции с последовательностями

Поэкспериментируйте в интерактивном режиме с некоторыми операциями сокращения последовательности.

```python
>>> data = [4, 9, 1, 25, 16, 100, 49]
>>> min(data)
1
>>> max(data)
100
>>> sum(data)
204
>>>
```

Попробуйте перебрать данные.

```python
>>> for x in data:
        print(x)

4
9
...
>>> for n, x in enumerate(data):
        print(n, x)

0 4
1 9
2 1
...
>>>
```


### 19. zip()

В файле `data/portfolio.csv` первая строка содержит заголовки столбцов.

```python
>>> f = open('Data/portfolio.csv')
>>> rows = csv.reader(f)
>>> headers = next(rows)
>>> headers
['name', 'shares', 'price']
>>>
```

Однако что, если бы вы могли использовать заголовки для чего-нибудь полезного? Здесь на сцену выходит функция `zip()`. Сначала попробуйте соединить заголовки файлов со строкой данных:

```python
>>> row = next(rows)
>>> row
['AA', '100', '32.20']
>>> list(zip(headers, row))
[ ('name', 'AA'), ('shares', '100'), ('price', '32.20') ]
>>>
```

Обратите внимание, как `zip()` соединяет заголовки столбцов со значениями столбцов. Мы использовали здесь `list()`, чтобы превратить результат в список, чтобы вы могли его увидеть. Обычно `zip()` создает итератор, который должен использоваться циклом `for`.

Это объединение является промежуточным шагом к созданию словаря. Теперь попробуйте следующее:

```python
>>> record = dict(zip(headers, row))
>>> record
{'price': '32.20', 'name': 'AA', 'shares': '100'}
>>>
```

Это преобразование — один из самых полезных приемов, о которых следует знать при обработке большого количества файлов данных. Например, предположим, что вы хотите, чтобы программа `pcost.py` работала с различными входными файлами, но без учета фактического номера столбца, в котором указаны имя, акции и цена.


### 20. Списки

Попробуйте несколько простых обработок списков, чтобы ознакомиться с синтаксисом.

```python
>>> nums = [1,2,3,4]
>>> squares = [ x * x for x in nums ]
>>> squares
[1, 4, 9, 16]
>>> twice = [ 2 * x for x in nums if x > 2 ]
>>> twice
[6, 8]
>>>
```

Обратите внимание, как генераторы списков создают новый список с данными, соответствующим образом преобразованными или отфильтрованными.

### 21. Сокращение последовательности

Рассчитайте общую стоимость портфеля, используя один оператор `Python`.

```python
>>> portfolio = read_portfolio('data/portfolio.csv')
>>> cost = sum([ s['shares'] * s['price'] for s in portfolio ])
>>> cost
44671.15
>>>
```

После того, как вы это сделаете, покажите, как можно вычислить текущую стоимость портфеля с помощью одного оператора.

```python
>>> value = sum([ s['shares'] * prices[s['name']] for s in portfolio ])
>>> value
28686.1
>>>
```
Обе вышеуказанные операции являются примером сокращения карты. Понимание списка отображает операцию по всему списку.

```python
>>> [ s['shares'] * s['price'] for s in portfolio ]
[3220.0000000000005, 4555.0, 12516.0, 10246.0, 3835.1499999999996, 3254.9999999999995, 7044.0]
>>>
```

Затем функция `sum()` выполняет сокращение результата:

```python
>>> sum(_)
44671.15
>>>
```

Обладая этими знаниями, вы теперь готовы запустить стартап, работающий с большими данными.

### 22: Запросы данных


Попробуйте следующие примеры различных запросов к данным.

Во-первых, список всех портфельных холдингов, содержащих более 100 акций.

```python
>>> more100 = [ s for s in portfolio if s['shares'] > 100 ]
>>> more100
[{'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 51.23, 'name': 'MSFT', 'shares': 200}]
>>>
```

Все портфельные активы MSFT и IBM.

```python
>>> msftibm = [ s for s in portfolio if s['name'] in {'MSFT','IBM'} ]
>>> msftibm
[{'price': 91.1, 'name': 'IBM', 'shares': 50}, {'price': 51.23, 'name': 'MSFT', 'shares': 200},
  {'price': 65.1, 'name': 'MSFT', 'shares': 50}, {'price': 70.44, 'name': 'IBM', 'shares': 100}]
>>>
```

Список всех активов портфеля стоимостью более 10 000 долларов США.

```python
>>> cost10k = [ s for s in portfolio if s['shares'] * s['price'] > 10000 ]
>>> cost10k
[{'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 51.23, 'name': 'MSFT', 'shares': 200}]
>>>
```

### 23: Извлечение данных

Покажите, как можно построить список кортежей `(name,shares)`, где `name` и `shares` берутся из `portfolio`.

```python
>>> name_shares =[ (s['name'], s['shares']) for s in portfolio ]
>>> name_shares
[('AA', 100), ('IBM', 50), ('CAT', 150), ('MSFT', 200), ('GE', 95), ('MSFT', 50), ('IBM', 100)]
>>>
```


Если вы замените квадратные скобки (`[`,`]`) на фигурные скобки (`{`, `}`), вы получите нечто, известное как понимание множеств.
Это дает вам уникальные или отличные значения.

Например, это определяет набор уникальных названий акций, которые появляются в портфеле:

```python
>>> names = { s['name'] for s in portfolio }
>>> names
{ 'AA', 'GE', 'IBM', 'MSFT', 'CAT' }
>>>
```

Если вы укажете пары «ключ:значение», вы сможете создать словарь. Например, создайте словарь, который сопоставит название акции с общим количеством принадлежащих акций.

```python
>>> holdings = { name: 0 for name in names }
>>> holdings
{'AA': 0, 'GE': 0, 'IBM': 0, 'MSFT': 0, 'CAT': 0}
>>>
```

Эта последняя функция известна как **словарное понимание**. Давайте сведем в таблицу:

```python
>>> for s in portfolio:
        holdings[s['name']] += s['shares']

>>> holdings
{ 'AA': 100, 'GE': 95, 'IBM': 150, 'MSFT':250, 'CAT': 150 }
>>>
```

Попробуйте этот пример, который фильтрует словарь «цены» только до тех имен, которые появляются в портфолио:

```python
>>> portfolio_prices = { name: prices[name] for name in names }
>>> portfolio_prices
{'AA': 9.22, 'GE': 13.48, 'IBM': 106.28, 'MSFT': 20.89, 'CAT': 35.46}
>>>
```


### 24. Первоклассные данные

В файле `data/portfolio.csv` мы читаем данные, организованные в виде столбцов, которые выглядят следующим образом:

```csv
name,shares,price
"AA",100,32.20
"IBM",50,91.10
...
```

В предыдущем коде мы использовали модуль `CSV` для чтения файла, но все равно приходилось выполнять преобразования типов вручную. Например:

```python
for row in rows:
    name   = row[0]
    shares = int(row[1])
    price  = float(row[2])
```


Этот вид преобразования также можно выполнить более умным способом, используя некоторые базовые операции со списками.

Создайте список Python, содержащий имена функций преобразования, которые вы будете использовать для преобразования каждого столбца в соответствующий тип:

```python
>>> types = [str, int, float]
>>>
```

Причина, по которой вы даже можете создать этот список, заключается в том, что в Python все *первоклассно*. Итак, если вы хотите иметь список функций, это нормально. Элементы в созданном вами списке являются функциями для преобразования значения `x` в заданный тип (например, `str(x)`, `int(x)`, `float(x)`.

Теперь прочитайте строку данных из вышеуказанного файла:

```python
>>> import csv
>>> f = open('Data/portfolio.csv')
>>> rows = csv.reader(f)
>>> headers = next(rows)
>>> row = next(rows)
>>> row
['AA', '100', '32.20']
>>>
```

Как уже отмечалось, этой строки недостаточно для вычислений, поскольку типы неверны. Например:

```python
>>> row[1] * row[2]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can't multiply sequence by non-int of type 'str'
>>>
```

Однако, возможно, данные можно сопоставить с типами, указанными вами в `types`. Например:

```python
>>> types[1]
<type 'int'>
>>> row[1]
'100'
>>>
```

Попробуйте преобразовать одно из значений:

```python
>>> types[1](row[1])     # Same as int(row[1])
100
>>>
```

Попробуйте преобразовать другое значение:

```python
>>> types[2](row[2])     # Same as float(row[2])
32.2
>>>
```

Попробуйте выполнить расчет с преобразованными значениями:

```python
>>> types[1](row[1])*types[2](row[2])
3220.0000000000005
>>>
```

`zip` типы столбцов с полями и посмотрите на результат:

```python
>>> r = list(zip(types, row))
>>> r
[(<type 'str'>, 'AA'), (<type 'int'>, '100'), (<type 'float'>,'32.20')]
>>>
```

Вы заметите, что здесь преобразование типа связано со значением. Например, `int` сочетается со значением `100`.

`zip` список полезен, если вы хотите выполнить преобразования всех значений одно за другим. Попробуй это:

```python
>>> converted = []
>>> for func, val in zip(types, row):
          converted.append(func(val))
...
>>> converted
['AA', 100, 32.2]
>>> converted[1] * converted[2]
3220.0000000000005
>>>
```

Убедитесь, что вы понимаете, что происходит в приведенном выше коде. В цикле переменная func — это одна из функций преобразования типов (например, str, int и т. д.), а переменная val — одно из значений.
например «АА», «100». Выражение `func(val)` преобразует значение (что-то вроде приведения типа).

Приведенный выше код можно сжать в одно представление списка.

```python
>>> converted = [func(val) for func, val in zip(types, row)]
>>> converted
['AA', 100, 32.2]
>>>
```

### 25: Создание словарей

Помните, как функция `dict()` может легко создать словарь, если у вас есть последовательность имен и значений ключей? Давайте сделаем словарь из заголовков столбцов:

```python
>>> headers
['name', 'shares', 'price']
>>> converted
['AA', 100, 32.2]
>>> dict(zip(headers, converted))
{'price': 32.2, 'name': 'AA', 'shares': 100}
>>>
```

Конечно, если вы разбираетесь в понимании списков, вы можете выполнить все преобразование за один шаг, используя:

```python
>>> { name: func(val) for name, func, val in zip(headers, types, row) }
{'price': 32.2, 'name': 'AA', 'shares': 100}
>>>
```

### 26. $\pi$
Вычислите десятичные дроби числа Пи, используя формулу Уоллиса.
$$\pi = 2 \prod_{i=1}^{\infty}\frac{4i^2}{4i^2 - 1}$$


### 27. Последовательность Фибоначчи

Напишите функцию, которая отображает `n` первых членов последовательности Фибоначчи, определяемую следующим образом:

$$\left\{
    \begin{array}{ll}
        U_{0} = 0 \\
        U_{1} = 1 \\
        U_{n+2} = U_{n+1} + U_{n}
    \end{array}
\right.$$

### 28.  Площадь поверхности земли
Всемирная геодезическая система (сеть) (World Geodetic System) – это комплект международных стандартов для описания формы Земли. В самой последней версии WGS-84 земной геоид приближенно определяется как эл-
липсоид, принимающий форму сжатого у полюсов сфероида с главной, или большой, полуосью эллипса a = 6 378 137.0 м и малой полуосью эллипса c = 6 356 752.314245 м.
Использовать формулу вычисления площади поверхности сжатого у полюсов сфероида
$$S=2\pi a^2 (1 + ((1 - e^2)/e) atanh(e))$$
где $e^2 = 1 - (c^2 / a^2)$
для вычисления площади поверхности вышеописанного эллипсоида и сравнить полученный результат с площадью поверхности Земли при предположении, что Земля – сфера с радиусом 6371 км
##3 Строки
1. Имеется строка, представляющая последовательность пар оснований (т. е. содержащие только буквы A, G, C, T). Определить доли (проценты) оснований G и C в этой последовательности.
(Совет: для строк существует метод count, возвращающий количество найденных вхождений заданных подстрок.)
2. Используя лишь методы обработки строк, разработать способ, позволяющий определить, является ли нуклеотидная последовательность палиндромом в том смысле, что она равнозначна собственной комплементарной последовательности, читаемой в обратном порядке. Например, последовательностьTGGATCCA является палиндромом, так как соответствующая ей комплементарная последовательность ACCTAGGT при прочтении в обратном порядке совпадает с исходной последовательностью. Комплементарными парами оснований являются (A, T) и (C, G).
##№ 29. Форматирование
В приведенной ниже в таблице перечислены названия, символические обозначения, числовые значения, погрешности и единицы измерения некоторых физических констант

|Название| Символ| Значение| Погрешность| Единицы измерения| 
|-|-|-|-|-|
|Постоянная Больцмана| $k_B$| $1.380649×10^{−23}$| - | $J \space K^{-1}$| 
|Скорость света| $c$| $2.99792458×10^8$| - | $m \space s^{-1}$| 
|Постоянная Планка| $h$| $6.62607015×10^{−34}$| - | $J\space s$| 
|Число Авогадро| $N_A$| $6.02214076×10^{23}$| - | $mol^{-1}$ | 
|Магнитный момент электрона| $\mu_e$| $−9.28476377×10^{-24}$| $2.3×10^{-31}$|$J \space T^{-1}$| 
|Гравитационная постоянная| $G$| $6.6743×10^{-11}$| $1.5×10^{-15}$ | $N \space m^2 \space kg^{-2}$|

Определяя переменные в форме
```python
G = 6.6743e-11 # J/K
G_unc = 1.5e-15 # погрешность
G_units = 'Nm^2/kg^2'
```
использовать метод строкового объекта format для получения следующих вариантов вывода:
1. kB = 1.381e-23 J/K;
2. G = 0.0000000000667430 Nm^2/kg^2;
3. использовать одинаковый спецификатор формата для каждой строки:
```
kB = 1.3807e-23 J/K
mu_e = -9.2848e-24 J/T
N_A = 6.0221e+23 mol -1
c = 2.9979e+08 m/s
```
4. и еще раз использовать одинаковый спецификатор формата для каждой
строки:
=== G = +6.67E-11 [Nm^2/kg^2] ===
=== e = -9.28E-24 [ J/T] ===
> Подсказка: код Unicode для греческой буквы мю в нижнем регистре U+03BC.

5. Получить показанный ниже вывод, в котором погрешность (стандартное отклонение) в значении каждой константы выражается как число в круглых скобках после предшествующих числовых раз-
рядов, т. е. 6.67430(15)×10−11 означает 6.67430×10−11 ± 1.5×10−15.
```
G = 6.67430(15)e-11 Nm^2/kg^2
mu_e = -9.28476377(23)e-24 J/T
```
### 29. Массивы
Написать небольшую программу на Python, которая по заданному массиву a вычисляет массив того же размера p, в котором каждый элемент p[i] является произведением всех целых чисел в массиве a, за исключением элемента a[i]. Например, если a = [1, 2, 3], то p = [6, 3, 2].

### 30. Расстояние Хэмминга 
Расстояние Хэмминга (Hamming distance) между двумя строками равной длины – это количество позиций, в которых символы различны. Написать небольшую программу на Python для вычисления расстояния Хэмминга между
двумя строками s1 и s2.

### 31. $n!!$
Функция факториал $n! = 1 × 2 × 3 × … × (n − 1) × n$ – произведение первых n положительных чисел представлена в модуле math методом factorial. Функция двойной факториал $n!!$ – это произведение положительных нечетных чисел, включая n (которое также обязательно должно быть нечетным числом):
$$n !! = \prod_{i=1}^{( n +1)/2} (2i − 1) = 1×3×5×...×( n − 2) × n.$$
1. Написать программу вычисления n!!.
 2. Расширить формулу для вычисления с четными числами, включая четное число n:
$$n !! = \prod_{i=1}^{n/2} (2i ) = 2×4×6×...×( n − 2)×n.$$
