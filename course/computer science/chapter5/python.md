# Курс: Информатика

#computer_science #python #note 

## `list`
### Инициализация и индексация списков

Python предоставляет упорядоченные структуры данных для хранения объектов — списки (list). В отличие от массивов в других языках, списки в Python могут содержать объекты различных типов.

Список создается с помощью квадратных скобок `[]`:
```python
list1 = [1, 'two', 3.14, 0]
list2 = [2, 4, -0.1, list1, True]
```

Списки могут содержать ссылки на различные типы данных, включая другие списки. Их размер не нужно объявлять заранее. Например, пустой список можно создать так:
```python
list0 = []
```

Элементы извлекаются по индексу (индексация начинается с 0):
```python
list1[2]  # 3.14
list2[-1]  # True
list2[3][1]  # 'two'
```

В последнем примере извлекается второй элемент из четвертого элемента 
списка `list2`, который также является списком.

Элементы списков могут быть индексированы. Например:

```python
list2[3][1]  # 'two'
list2[3][1][1]  # 'w'
```

Для проверки наличия элемента в списке используется оператор `in`, но он не рекурсивен:

```python
1 in list1  # True
'two' in list2  # False
```

Второе выражение возвращает `False`, потому что `list2` не содержит строку `'two'` напрямую.

### Изменяемость списков


При копировании списка важно помнить, что присваивание переменной другой список не создает его копию:

```python
q1 = [1, 2, 3]
q2 = q1
q1[2] = 'oops'
print(q1)  # Вывод: [1, 2, 'oops']
print(q2)  # Вывод: [1, 2, 'oops']
```

В этом примере `q1` и `q2` ссылаются на один и тот же список, поэтому изменения в одном списке отражаются в другом.

В Python можно вырезать (slice) элементы из списков так же, как и из строк. Например:

```python
q1 = [0., 0.1, 0.2, 0.3, 0.4, 0.5]
print(q1[1:4])   # Вывод: [0.1, 0.2, 0.3]
print(q1[::-1])  # Вывод: [0.5, 0.4, 0.3, 0.2, 0.1, 0.0]
print(q1[1::2])  # Вывод: [0.1, 0.3, 0.5]
```
Операция среза создает новый список. Например:

```python
q2 = q1[1:4]
q2[1] = 99
print(q2)  # Вывод: [0.1, 99, 0.3]
print(q1)  # Вывод: [0.0, 0.1, 0.2, 0.3, 0.4, 0.5]
```

### Методы list

В Python списки имеют множество полезных методов, позволяющих изменять их содержимое и размер. Вот некоторые из наиболее часто используемых методов:

| Метод                    | Описание                                            |
| ------------------------ | --------------------------------------------------- |
| `append(element)`        | Добавляет `element` в конец списка.                 |
| `extend(list2)`          | Расширяет список элементами из `list2`.             |
| `index(element)`         | Возвращает наименьший индекс, содержащий `element`. |
| `insert(index, element)` | Вставляет `element` по указанному `index`.          |
| `pop()`                  | Удаляет и возвращает последний элемент из списка.   |
| `remove(element)`        | Удаляет первое вхождение `element` из списка.       |
| `sort()`                 | Сортирует элементы списка.                          |
| `reverse()`              | Изменяет порядок элементов на обратный.             |
| `copy()`                 | Возвращает поверхностную копию списка.              |
| `count(element)`         | Возвращает количество вхождений `element` в списке. |
```python
q = []
q.append(4)
print(q)  # Вывод: [4]

q.extend([6, 7, 8])
print(q)  # Вывод: [4, 6, 7, 8]

q.insert(1, 5)  # Вставка 5 по индексу 1
print(q)  # Вывод: [4, 5, 6, 7, 8]

q.remove(7)
print(q)  # Вывод: [4, 5, 6, 8]

print(q.index(8))  # Вывод: 3 (элемент 8 находится по индексу 3)

# Sort and Reverse

q = [2, 0, 4, 3, 1]
q.sort()
print(q)  # Вывод: [0, 1, 2, 3, 4]

q.reverse()
print(q)  # Вывод: [4, 3, 2, 1, 0]
```

Если нужно получить отсортированную копию списка без изменения оригинала, можно использовать `sorted()`:
```python
q = ['a', 'e', 'A', 'c', 'b']
sorted_q = sorted(q)
print(sorted_q)  # Вывод: ['A', 'a', 'b', 'c', 'e']
print(q)         # Вывод: ['a', 'e', 'A', 'c', 'b'] (исходный список остается неизменным)
```
Для сортировки в убывающем порядке используется аргумент `reverse=True`:
```python
q = [10, 5, 5, 2, 6, 1, 67]
print(sorted(q, reverse=True))  # Вывод: [67, 10, 6, 5, 5, 2, 1]
```

## `tuple`

Кортежи (tuple) — это неизменяемые последовательности, которые можно воспринимать как списки. Кортеж создается с использованием круглых скобок:
```python
t = (1, 'two', 3.0)
print(t)  # Вывод: (1, 'two', 3.0)
```

Кортежи можно индексировать и вырезать, как списки, но нельзя изменять их содержимое (добавлять или удалять элементы):

```python
print(t[1])  # Вывод: 'two'
# t[2] = 4  # Это вызовет ошибку: TypeError
```

Хотя кортежи неизменяемы, они могут содержать изменяемые объекты, такие как списки:
```python
t = (1, ['a', 'b', 'd'], 0)
t[1][2] = 'c'  # Изменяем элемент внутри списка
print(t)  # Вывод: (1, ['a', 'b', 'c'], 0)
```

### Создание кортежей

Пустой кортеж создается с помощью пустых скобок:
```python
t0 = ()
```

Чтобы создать кортеж с одним элементом, нужно добавить запятую:
```python
t = ('one',)  # Это кортеж с одним элементом
```

### Упаковка и распаковка кортежей

Кортеж можно создать без круглых скобок:
```python
t = 1, 2, 3
print(t)  # Вывод: (1, 2, 3)
```

Это называется упаковкой кортежа. Распаковка происходит при присваивании значений нескольким переменным:

```python
a, b, c = 97, 98, 99
print(b)  # Вывод: 98
```

## Итерируемые объекты в Python

**Примеры итерируемых объектов**

Строки, списки и кортежи — это примеры итерируемых объектов, которые позволяют проходить по элементам по одному. Их можно преобразовывать в списки или кортежи с помощью конструктора `list()` или `tuple()`:

```python
# Преобразование строки в список
print(list('hello'))  # Вывод: ['h', 'e', 'l', 'l', 'o']

# Создание нового списка
a = [5, 4, 3, 2, 1]
b = list(a)  # Создаем новый объект списка
print(b is a)  # Вывод: False (разные объекты)
```

**Функции `any()` и `all()`**

Функция `any()` проверяет, есть ли хотя бы один элемент, равный `True`, а `all()` проверяет, все ли элементы равны `True`:

```python
a = [1, 0, 0, 2, 3]
print(any(a), all(a))  # Вывод: (True, False)

b = [[], False, 0.]
print(any(b), all(b))  # Вывод: (False, False)
```

### Синтаксис распаковки аргументов

Иногда нужно вызвать функцию с аргументами из списка или кортежа. Синтаксис `*` распаковывает последовательность в позиционные аргументы:

```python
import math
t = [3, 4]
# math.hypot(t)  # Это вызовет ошибку
result = math.hypot(*t)  # Правильный вызов с распаковкой
print(result)  # Вывод: 5.0

```

#### Упаковка значений

Вы можете использовать оператор `*`, чтобы упаковать значения из кортежа или списка:

```python
# Упаковка значений в одну переменную
*a, = 1, 2
print(a)  # Вывод: [1, 2]
```
Эта операция требует запятой в конце, чтобы указать, что левая сторона — это кортеж или список.

#### Примеры упаковки и распаковки
**Упаковка хвостовых значений:**
```python
a, *b = 1, 2, 3
print(a)  # Вывод: 1
print(b)  # Вывод: [2, 3]
```
**Упаковка начальных значений**:
```python
*a, b = 1, 2, 3
print(a)  # Вывод: [1, 2]
print(b)  # Вывод: 3
```
**Упаковка с обязательными переменными**:
```python
*a, b, c = 1, 2, 3
print(a)  # Вывод: [1]
print(b)  # Вывод: 2
print(c)  # Вывод: 3
```

**Ошибка при недостаточном количестве значений:**
```python
# Вызывает ValueError из-за недостаточного количества значений
# *a, b, c, d, e = 1, 2, 3
```

**Использование `*` с генераторами и диапазонами**
```python
gen = (2 ** x for x in range(10))
*g, = gen
print(g)  # Вывод: [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]

ran = range(10)
*r, = ran
print(r)  # Вывод: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

**Параллельное присваивание**

```python
employee = ["John Doe", "40", "Software Engineer"]
name, age, job = employee
print(name)  # Вывод: 'John Doe'
print(age)   # Вывод: '40'
print(job)   # Вывод: 'Software Engineer'
```

**Обмен значениями**
```python
a = 100
b = 200
a, b = b, a
print(a)  # Вывод: 200
print(b)  # Вывод: 100
```

**Сбор нескольких значений**
```python
seq = [1, 2, 3, 4]
first, *body, last = seq
print(first)  # Вывод: 1
print(body)   # Вывод: [2, 3]
print(last)   # Вывод: 4
```

Этот подход более гибкий, так как адаптируется к изменениям в длине последовательности:

```python
seq = [1, 2, 3, 4, 5, 6]
first, *body, last = seq
print(body)  # Вывод: [2, 3, 4, 5]
```

**Игнорирование ненужных значений**

Вы можете использовать временную переменную (обычно `_`), чтобы игнорировать ненужные значения:

```python
a, b, *_ = 1, 2, 0, 0, 0, 0
print(a)  # Вывод: 1
print(b)  # Вывод: 2
print(_)  # Вывод: [0, 0, 0, 0]
```
### Циклы `for`

Циклы `for` позволяют последовательно перебирать элементы итерируемого объекта:

```python
fruit_list = ['apple', 'melon', 'banana', 'orange']
for fruit in fruit_list:
    print(fruit)
```

```
apple
melon
banana
orange
```

Циклы могут быть вложенными:

```python
for fruit in fruit_list:
    for letter in fruit:
        print(letter, end='.')
    print()  # Переход на новую строку
```

```python
a.p.p.l.e.
m.e.l.o.n.
b.a.n.a.n.a.
o.r.a.n.g.e.
```

## `zip`

Что делать, если нужно одновременно пройти по нескольким последовательностям? Для этого и предназначена встроенная функция `zip`. Она создает объект-итератор, в котором каждый элемент представляет собой кортеж из элементов, выбираемых поочередно из переданных последовательностей.
```python
a = [1, 2, 3, 4]
b = ['a', 'b', 'c', 'd']
```

При вызове `zip(a, b)` получается объект-итератор:

```python
zip(a, b)
# <builtins.zip at 0x104476998>
```

Теперь можно итерироваться по парам элементов:
```python
for pair in zip(a, b):
    print(pair)
#(1, 'a')
#(2, 'b')
#(3, 'c')
#(4, 'd')
```

#### Разделение последовательностей (unzip)

Функцию `zip` можно использовать и для разделения кортежей:
```python
z = zip(a, b)  # Соединение
A, B = zip(*z)  # Разделение
print(A, B)
# (1, 2, 3, 4) ('a', 'b', 'c', 'd')
```

Проверим, совпадают ли списки:
```python
list(A) == a, list(B) == b
# (True, True)
```