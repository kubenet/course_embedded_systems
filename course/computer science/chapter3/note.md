# Курс:  Информатика
#computer_science #bash #note
# Практическое занятие №3. "Сценарии оболочки"
- [[#Как использовать команды|Как использовать команды]]
- [[#Поиск файлов|Поиск файлов]]
- [[#Поиск слов|Поиск слов]]
- [[#Поиск shell команд|Поиск shell команд]]
- [[#Навигация по каталогам|Навигация по каталогам]]
- [[#PATH|PATH]]
- [[#Усовершенствование пользовательских команд|Усовершенствование пользовательских команд]]
	- [[#Усовершенствование пользовательских команд#Резервное копированией файлов при удалении|Резервное копированией файлов при удалении]]
---
До сих пор мы видели, как выполнять команды в оболочке и соединять их по конвейеру.
Однако во многих сценариях вам потребуется выполнить ряд команд и использовать выражения потока управления, такие как условные выражения или циклы.

Сценарии оболочки — это следующий шаг в сложности.
Большинство оболочек имеют собственный язык сценариев с переменными, потоком управления и собственным синтаксисом.
Что отличает сценарии оболочки от других языков программирования сценариев, так это то, что они оптимизированы для выполнения задач, связанных с оболочкой.
Таким образом, создание командных конвейеров, сохранение результатов в файлы и чтение из стандартного ввода — это примитивы в сценариях оболочки, что упрощает их использование по сравнению с языками сценариев общего назначения.
В этом разделе мы сосредоточимся на сценариях bash, поскольку они наиболее распространены.

Чтобы назначить переменные в bash, используйте синтаксис `foo=bar` и получите доступ к значению переменной с помощью `$foo`.
Обратите внимание, что `foo = bar` не будет работать, поскольку он интерпретируется как вызов программы `foo` с аргументами `=` и `bar`.
Обычно в сценариях оболочки символ пробела выполняет разделение аргументов. Поначалу такое поведение может сбивать с толку, поэтому всегда проверяйте его.

Строки в bash могут определяться с помощью разделителей `'` и `"`, но они не эквивалентны.
Строки, разделенные `'`, являются литеральными строками и не заменяют значения переменных, тогда как строки с разделителями `"` заменяют.

```bash
foo=bar
echo "$foo"
# prints bar
echo '$foo'
# prints $foo
```

Как и большинство языков программирования, bash поддерживает методы управления потоками, включая `if`, `case`, `while` и `for`.
Аналогично, в bash есть функции, которые принимают аргументы и могут с ними работать. Вот пример функции, которая создает каталог и записывает в него компакт-диски.


```bash
mcd () {
    mkdir -p "$1"
    cd "$1"
}
```


Здесь `$1` — это первый аргумент скрипта/функции.
В отличие от других языков сценариев, bash использует множество специальных переменных для ссылки на аргументы, коды ошибок и другие соответствующие переменные. Ниже приведен список некоторых из них. Более полный список можно найти [здесь](https://tldp.org/LDP/abs/html/special-chars.html).
- `$0` - Имя скрипта
- от `$1` до `$9` — аргументы сценария. `$1` — первый аргумент и так далее.
- `$@` - Все аргументы
- `$#` - Количество аргументов
- `$?` - Код возврата предыдущей команды
- `$$` - Идентификатор процесса (PID) для текущего скрипта
- `!!` - Вся последняя команда, включая аргументы. Распространенным шаблоном является выполнение команды только для ее сбоя из-за отсутствия разрешений; вы можете быстро повторно выполнить команду с помощью sudo, выполнив `sudo !!`
- `$_` - Последний аргумент последней команды. Если вы находитесь в интерактивной оболочке, вы также можете быстро получить это значение, набрав «Esc», а затем «.» или «Alt+».

Команды часто возвращают выходные данные с использованием STDOUT, ошибки — через STDERR, а код возврата позволяет сообщать об ошибках более удобным для сценариев способом.
Код возврата или статус выхода — это способ, с помощью которого сценарии/команды сообщают о ходе выполнения.
Значение 0 обычно означает, что все прошло нормально; любое значение, отличное от 0, означает, что произошла ошибка.

Коды выхода можно использовать для условного выполнения команд с использованием `&&` (и оператора) и `||` (или оператора), оба из которых являются [коротким замыканием](https://en.wikipedia.org/wiki/Short-circuit_evaluation) операторы. Команды также можно разделять в одной строке точкой с запятой `;`.
Программа `true` всегда будет иметь код возврата 0, а команда `false` всегда будет иметь код возврата 1.
Давайте посмотрим несколько примеров

```bash
false || echo "Oops, fail"
# Oops, fail

true || echo "Will not be printed"
#

true && echo "Things went well"
# Things went well

false && echo "Will not be printed"
#

true ; echo "This will always run"
# This will always run

false ; echo "This will always run"
# This will always run
```

Другой распространенный шаблон — желание получить вывод команды в виде переменной. Это можно сделать с помощью _командной подстановки_.
Всякий раз, когда вы размещаете `$( CMD )`, он выполняет `CMD`, получает выходные данные команды и заменяет их на место.
Например, если вы выполните `for file in $(ls)`, оболочка сначала вызовет `ls`, а затем переберет эти значения.
Менее известная подобная функция — это _process substitution_, `<( CMD )` выполнит `CMD`, поместит выходные данные во временный файл и заменит `<()` именем этого файла. Это полезно, когда команды ожидают передачи значений по файлу, а не по STDIN. Например, `diff <(ls foo) <(ls bar)` покажет различия между файлами в каталогах `foo` и `bar`.

Поскольку это была огромная куча информации, давайте посмотрим на пример, демонстрирующий некоторые из этих функций. Он будет перебирать предоставленные нами аргументы, `grep` для строки `foobar`, и добавит ее в файл в качестве комментария, если она не найдена.

```bash
#!/bin/bash

echo "Starting program at $(date)" # Date will be substituted

echo "Running program $0 with $# arguments with pid $$"

for file in "$@"; do
    grep foobar "$file" > /dev/null 2> /dev/null
    # When pattern is not found, grep has exit status 1
    # We redirect STDOUT and STDERR to a null register since we do not care about them
    if [[ $? -ne 0 ]]; then
        echo "File $file does not have any foobar, adding one"
        echo "# foobar" >> "$file"
    fi
done
```


В ходе сравнения мы проверяли, не равен ли `$?` 0.
Bash реализует множество подобных сравнений — подробный список можно найти на странице руководства по [`test`](https://www.man7.org/linux/man-pages/man1/test.1.html).
При выполнении сравнений в bash старайтесь использовать двойные скобки `[[ ]]` вместо простых скобок `[ ]`. Шансы на ошибку ниже, хотя его нельзя переносить в `sh`. Более подробное объяснение можно найти [здесь](http://mywiki.wooledge.org/BashFAQ/031).

При запуске сценариев вам часто потребуется предоставить схожие аргументы. В Bash есть способы упростить эту задачу, расширяя выражения путем расширения имен файлов. Эти методы часто называют _globbing_ оболочки.
- Подстановочные знаки. Всякий раз, когда вы хотите выполнить какое-либо сопоставление с подстановочными знаками, вы можете использовать `?` и `*` для сопоставления одного или любого количества символов соответственно. Например, для файлов `foo`, `foo1`, `foo2`, `foo10` и `bar` команда `rm foo?` удалит `foo1` и `foo2`, тогда как `rm foo*` удалит все но `бар`.
- Фигурные скобки `{}`. Если у вас есть общая подстрока в серии команд, вы можете использовать фигурные скобки для bash, чтобы автоматически расширить ее. Это очень удобно при перемещении или преобразовании файлов.

```bash
convert image.{png,jpg}
# Will expand to
convert image.png image.jpg

cp /path/to/project/{foo,bar,baz}.sh /newpath
# Will expand to
cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath

# Globbing techniques can also be combined
mv *{.py,.sh} folder
# Will move all *.py and *.sh files


mkdir foo bar
# This creates files foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h
touch {foo,bar}/{a..h}
touch foo/x bar/y
# Show differences between files in foo and bar
diff <(ls foo) <(ls bar)
# Outputs
# < x
# ---
# > y
```


Написание bash-скриптов может быть сложным и неинтуитивным. Существуют такие инструменты, как [shellcheck](https://github.com/koalaman/shellcheck), которые помогут вам найти ошибки в ваших сценариях sh/bash.

Обратите внимание, что сценарии не обязательно должны быть написаны на bash, чтобы их можно было вызывать с терминала. Например, вот простой скрипт Python, который выводит аргументы в обратном порядке:

```python
#!/usr/local/bin/python
import sys
for arg in reversed(sys.argv[1:]):
    print(arg)
```

Ядро знает, что этот сценарий следует выполнять с помощью интерпретатора Python, а не с помощью команды оболочки, поскольку мы включили строку [shebang](https://en.wikipedia.org/wiki/Shebang_(Unix)) в верхней части сценария.
Хорошей практикой является написание строк shebang с использованием команды [`env`](https://www.man7.org/linux/man-pages/man1/env.1.html), которая будет определять, где находится команда. системе, увеличивая переносимость ваших сценариев. Чтобы определить местоположение, env будет использовать переменную среды PATH.
В этом примере строка shebang будет выглядеть как `#!/usr/bin/env python`.

Некоторые различия между функциями оболочки и сценариями, о которых вам следует помнить:
— Функции должны быть на том же языке, что и оболочка, а скрипты можно писать на любом языке. Вот почему важно включать shebang для скриптов.
— Функции загружаются один раз при чтении их определения. Скрипты загружаются каждый раз при выполнении. Это ускоряет загрузку функций, но всякий раз, когда вы их меняете, вам придется перезагрузить их определение.
- Функции выполняются в текущей среде оболочки, тогда как сценарии выполняются в своем собственном процессе. Таким образом, функции могут изменять переменные среды, например. измените текущий каталог, тогда как сценарии не могут. Скрипты будут передаваться по значениям переменных среды, которые были экспортированы с помощью [`export`](https://www.man7.org/linux/man-pages/man1/export.1p.html).
- Как и в любом языке программирования, функции представляют собой мощную конструкцию, позволяющую добиться модульности, повторного использования кода и ясности кода оболочки. Часто сценарии оболочки включают собственные определения функций.

## Как использовать команды

At this point, you might be wondering how to find the flags for the commands in the aliasing section such as `ls -l`, `mv -i` and `mkdir -p`.
More generally, given a command, how do you go about finding out what it does and its different options?
You could always start googling, but since UNIX predates StackOverflow, there are built-in ways of getting this information.

As we saw in the shell lecture, the first-order approach is to call said command with the `-h` or `--help` flags. A more detailed approach is to use the `man` command.
Short for manual, [`man`](https://www.man7.org/linux/man-pages/man1/man.1.html) provides a manual page (called manpage) for a command you specify.
For example, `man rm` will output the behavior of the `rm` command along with the flags that it takes, including the `-i` flag we showed earlier.
In fact, what I have been linking so far for every command is the online version of the Linux manpages for the commands.
Even non-native commands that you install will have manpage entries if the developer wrote them and included them as part of the installation process.
For interactive tools such as the ones based on ncurses, help for the commands can often be accessed within the program using the `:help` command or typing `?`.

Sometimes manpages can provide overly detailed descriptions of the commands, making it hard to decipher what flags/syntax to use for common use cases.
[TLDR pages](https://tldr.sh/) are a nifty complementary solution that focuses on giving example use cases of a command so you can quickly figure out which options to use.
For instance, I find myself referring back to the tldr pages for [`tar`](https://tldr.inbrowser.app/pages/common/tar) and [`ffmpeg`](https://tldr.inbrowser.app/pages/common/ffmpeg) way more often than the manpages.


## Поиск файлов

Одна из наиболее распространенных повторяющихся задач, с которой сталкивается каждый программист, — это поиск файлов или каталогов.
Все UNIX-подобные системы поставляются с [`find`](https://www.man7.org/linux/man-pages/man1/find.1.html), отличным инструментом оболочки для поиска файлов. `find` будет рекурсивно искать файлы, соответствующие некоторым критериям. Некоторые примеры:

```bash
# Find all directories named src
find . -name src -type d
# Find all python files that have a folder named test in their path
find . -path '*/test/*.py' -type f
# Find all files modified in the last day
find . -mtime -1
# Find all zip files with size in range 500k to 10M
find . -size +500k -size -10M -name '*.tar.gz'
```
Помимо перечисления файлов, `find` также может выполнять действия над файлами, которые соответствуют вашему запросу.
Это свойство может быть невероятно полезным для упрощения довольно монотонных задач.
```bash
# Delete all files with .tmp extension
find . -name '*.tmp' -exec rm {} \;
# Find all PNG files and convert them to JPG
find . -name '*.png' -exec convert {} {}.jpg \;
```


Несмотря на повсеместное распространение команды find, ее синтаксис иногда бывает сложно запомнить.
Например, чтобы просто найти файлы, соответствующие некоторому шаблону `PATTERN`, вам нужно выполнить `find -name '*PATTERN*'` (или `-iname`, если вы хотите, чтобы сопоставление с шаблоном не учитывало регистр).
Вы можете начать создавать псевдонимы для этих сценариев, но часть философии оболочки заключается в том, что полезно исследовать альтернативы.
Помните, одно из лучших свойств оболочки состоит в том, что вы просто вызываете программы, поэтому для некоторых из них вы можете найти (или даже написать самостоятельно).
Например, [`fd`](https://github.com/sharkdp/fd) — это простая, быстрая и удобная альтернатива `find`.
Он предлагает некоторые приятные настройки по умолчанию, такие как цветной вывод, сопоставление регулярных выражений по умолчанию и поддержку Unicode. На мой взгляд, он также имеет более интуитивный синтаксис.
Например, синтаксис для поиска шаблона PATTERN — fd PATTERN.

Большинство согласится, что `find` и `fd` хороши, но некоторые из вас могут задаться вопросом, насколько эффективнее каждый раз искать файлы по сравнению с компиляцией какого-то индекса или базы данных для быстрого поиска.
Для этого и нужен [`locate`](https://www.man7.org/linux/man-pages/man1/locate.1.html).
`locate` использует базу данных, которая обновляется с помощью [`updatedb`](https://www.man7.org/linux/man-pages/man1/updatedb.1.html).
В большинстве систем `updatedb` обновляется ежедневно через [`cron`](https://www.man7.org/linux/man-pages/man8/cron.8.html).
Поэтому одним из компромиссов между ними является скорость и свежесть.
Более того, `find` и подобные инструменты также могут находить файлы, используя такие атрибуты, как размер файла, время модификации или права доступа к файлу, тогда как `locate` просто использует имя файла.
Более подробное сравнение можно найти [здесь] (https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other).

## Поиск слов


Поиск файлов по имени полезен, но довольно часто вам нужно искать по *содержимому* файла.
Распространенным сценарием является поиск всех файлов, содержащих некоторый шаблон, а также место, где в этих файлах встречается этот шаблон.
Для достижения этой цели большинство UNIX-подобных систем предоставляют [`grep`](https://www.man7.org/linux/man-pages/man1/grep.1.html), общий инструмент для сопоставления шаблонов из входных данных. текст.
`grep` — невероятно ценный инструмент оболочки.

А пока знайте, что `grep` имеет множество флагов, которые делают его очень универсальным инструментом.
Некоторые из них, которые я часто использую, — это `-C` для получения **C**контекста вокруг совпадающей строки и `-v` для вставки**переноса совпадения, т. е. печати всех строк, которые **не** соответствуют шаблон. Например, `grep -C 5` напечатает 5 строк до и после совпадения.
Когда дело доходит до быстрого поиска по множеству файлов, вы можете использовать `-R`, поскольку он будет **R**рекурсивно заходить в каталоги и искать файлы по соответствующей строке.

Но `grep -R` можно улучшить разными способами, например, игнорирование папок `.git`, использование поддержки нескольких процессоров и т. д.
Было разработано множество альтернатив grep, включая [ack](https://github.com/beyondgrep/ack3), [ag](https://github.com/ggreer/the_silver_searcher) и [rg](https: //github.com/BurntSushi/ripgrep).
Все они фантастические и в значительной степени предоставляют одинаковую функциональность.

Обратите внимание: как и в случае с `find`/`fd`, важно знать, что эти проблемы можно быстро решить с помощью одного из этих инструментов, тогда как конкретные инструменты, которые вы используете, не так важны.

## Поиск shell команд

До сих пор мы видели, как находить файлы и код, но по мере того, как вы начнете проводить больше времени в оболочке, вам может понадобиться найти определенные команды, которые вы в какой-то момент набрали.
Первое, что нужно знать, это то, что нажатие стрелки вверх вернет вам последнюю команду, и если вы продолжите нажимать ее, вы медленно просматриваете историю своей оболочки.

Команда `history` позволит вам программно получить доступ к истории вашей оболочки.
Он выведет историю вашей оболочки на стандартный вывод.
Если мы хотим выполнить поиск там, мы можем передать этот вывод в grep и выполнить поиск шаблонов.
`history | grep find` выведет команды, содержащие подстроку «find».

В большинстве оболочек вы можете использовать «Ctrl+R» для выполнения обратного поиска по вашей истории.
Нажав `Ctrl+R`, вы можете ввести подстроку, которую хотите сопоставить для команд в вашей истории.
Продолжая нажимать на нее, вы будете циклически просматривать матчи в своей истории.
Это также можно включить с помощью стрелок ВВЕРХ/ВНИЗ в [zsh](https://github.com/zsh-users/zsh-history-substring-search).
Хорошим дополнением к `Ctrl+R` является использование привязок [fzf](https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r).
`fzf` — это средство нечеткого поиска общего назначения, которое можно использовать со многими командами.
Здесь он используется для нечеткого сопоставления вашей истории и представления результатов в удобной и визуально приятной форме.

Еще один крутой трюк, связанный с историей, который мне очень нравится, — это **самовнушение на основе истории**.
Впервые представленная в оболочке [fish](https://fishshell.com/), эта функция динамически автоматически дополняет текущую команду оболочки самой последней введенной вами командой, имеющей общий с ней префикс.
Его можно включить в [zsh](https://github.com/zsh-users/zsh-autosuggestions), и это отличный трюк для повышения качества жизни вашей оболочки.

Вы можете изменить поведение истории вашей оболочки, например запретить включение команд с начальным пробелом. Это удобно, когда вы вводите команды с паролями или другой конфиденциальной информацией.
Для этого добавьте HISTCONTROL=ignorespace в ваш .bashrc или setopt HIST_IGNORE_SPACE в .zshrc.
Если вы допустили ошибку, не добавив начальный пробел, вы всегда можете удалить запись вручную, отредактировав свой `.bash_history` или `.zsh_history`.

## Навигация по каталогам


До сих пор мы предполагали, что вы уже находитесь там, где вам нужно быть для выполнения этих действий. Но как быстро перемещаться по каталогам?
Есть много простых способов сделать это, например, написание псевдонимов оболочки или создание символических ссылок с помощью [ln -s](https://www.man7.org/linux/man-pages/man1/ln.1.html). , но правда в том, что разработчики уже придумали довольно умные и изощренные решения.

Как и в случае с темой этого курса, часто требуется оптимизировать систему для общего случая.
Поиск часто используемых и/или последних файлов и каталогов можно выполнить с помощью таких инструментов, как [`fasd`](https://github.com/clvv/fasd) и [`autojump`](https://github.com/wting/autojump).
Fasd ранжирует файлы и каталоги по [_frecency_](https://web.archive.org/web/20210421120120/https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm), что то есть как по _частоте_, так и по _давности_.
По умолчанию `fasd` добавляет команду `z`, которую вы можете использовать для быстрого `cd`, используя подстроку каталога _frecent_. Например, если вы часто заходите в `/home/user/files/cool_project`, вы можете просто использовать `z Cool`, чтобы перейти туда. Используя autojump, то же самое изменение каталога можно выполнить с помощью `j Cool`.

Существуют более сложные инструменты для быстрого получения обзора структуры каталогов: [`tree`](https://linux.die.net/man/1/tree), [`broot`](https://github.com/Canop/broot) или даже полноценные файловые менеджеры, такие как [`nnn`](https://github.com/jarun/nnn) или [`ranger`](https://github.com/ranger/ranger).

## PATH
После запуска операционной системы пользователю доступны различные инструменты, как системные (входящие в состав ОС), так и сторонние (установленные дополнительно). Часто в процессе работы возникает необходимость использования командной строки для вызова различных утилит, помогающих в процессе работы. Например, в случае, когда браузеру не удается открыть страницу удаленного веб-сервиса: зайти на почту или открыть новостную ленту, мы можем наблюдать следующую ошибку — "404 NotFound". Чтобы определить, на чьей стороне ошибка: вашей сети или удаленного сервера, часто используют системные утилиты, консоли для работы с сетью. Такие как PING, IPCONFIG, ARP, NETSTAT и т.д.

В Linux (также UNIX)  **$PATH**  — это переменная среды, используемая для указания оболочке, где искать исполняемые файлы.  **$PATH**  обеспечивает большую гибкость и безопасность для систем  [**Linux**](https://blog.sedicomm.com/2018/01/21/kak-ustanovit-golang-yazyk-programmirovaniya-go-v-linux/), и, безусловно, можно сказать, что это одна из самых важных переменных среды.

Программы/скрипты, расположенные в каталоге  **$PATH**, могут быть выполнены непосредственно в вашей оболочке без указания полного пути к ним.

> Чтобы выяснить путь к домашнему каталогу, дайте команду `echo $HOME`, кото-
рая выведет в окне терминала полный путь. Перейдите в указанный каталог
и создайте папку для разрабатываемых сценариев (`scripts`). Затем добавьте эту папку в свой сценарий входа, для чего откройте файл сценария в текстовом редакторе и добавьте в начало файла следующую строку, заменив /path/to/scripts/ на путь к папке с вашими сценариями:
> `export PATH="/path/to/scripts/:$PATH"`
```bash
root@de30378728be:/test# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
root@de30378728be:/test#
```

Результат отображает список каталогов, разделенных двоеточиями. Вы можете легко добавить больше каталогов, отредактировав файл профиля оболочки вашего пользователя.

В разных оболочках это делается так:

оболочка Bash -> `~/ .bash_profile`, `~/ .bashrc` или `.profile`
оболочка Korn -> `~/.kshrc` или `.profile`
оболочка Z -> `~/.zshrc` или `.zprofile`
Обратите внимание, в зависимости от того, как вы регистрировались в системе, могут прочитаться разные файлы конфигурации оболочки. Вот что говорит руководство по bash, помните, что есть файлы конфигурации и на других оболочках:

`/bin/bash` — запуск оболочки
`/etc/profile` — глобальный системный файл инициализации, запускается при входе в оболочку
`/etc/bash.bashrc` — глобальный системный файл сценария конфигурации оболочки
`~/.bash_profile` — персональный файл инициализации пользователя, запускается при входе в оболочку
`~/.bashrc` — персональный файл сценария конфигурации оболочки
`~/.bash_logout` — персональный файл сценария выхода для очистки оболочки, запускается когда пользователь выходит с оболочки
`~/.inputrc` — персональный файл конфигурации клавиатуры для специфических ситуаций

Пример подсчета установленных коммнад в ОС.
```bash
#!/bin/bash
# Подсчет количества команд: простой сценарий для подсчета количества выполняемых команд в каталогах из списка PATH

IFS=":"
count=0
nonex=0

for directory in $PATH ; do
    if [ -d "$directory" ] ; then
        for command in "$directory"/* ; do
            if [ -x "$command" ] ; then
                count=$(( count + 1 ))
            else
                nonex=$(( nonex + 1 ))
            fi
        done
    fi
done

echo "$count commands, and $nonex entries that weren't executable"
exit 0
```

## Усовершенствование пользовательских команд 
**1. Добавление команд в PATH**
Одним из способов использования пользовательских команд является добавление их в переменную PATH, чтобы они были доступны в любой директории. Для этого достаточно скопировать исполняемый файл в директорию, указанную в PATH.
**2. Параметры команды**
Для улучшения функциональности пользовательских команд можно добавить параметры, которые будут изменять поведение команды в зависимости от переданных значений. В Bash-скриптах параметры передаются через переменные `$1`, `$2`, `$3` и т.д., где `$1` - первый параметр, `$2` - второй параметр и т.д.

Например, пользовательская команда  `mycommand`  может принимать параметр  `-l`, который будет выводить длину переданного текста:

```bash
#!/bin/bash

if [ "$1" = "-l" ]; then
    echo "Length: ${#2}"
else
    echo "Unknown parameter"
fi

```

Вызов команды  `mycommand -l "Hello, World!"`  выведет длину строки "Hello, World!".

**3. Обработка ошибок**

Важной частью пользовательских команд является обработка ошибок. Баш-скрипты могут возвращать коды ошибок, которые могут быть использованы для определения типа ошибки и выполнения соответствующих действий.

Например, команда  `awk`  возвращает код ошибки 0, если выполнение прошло успешно, и код ошибки 1, если во время выполнения произошла ошибка. Можно использовать эту информацию, чтобы определить, был ли успешно выполнен вызов команды  `awk`:

```bash
#!/bin/bash

awk -F',' '{print $1}' file.csv

if [ $? -eq 0 ]; then
    echo "Command executed successfully"
else
    echo "An error occurred" 
fi
```
### Резервное копированией файлов при удалении
Одна из распространенных проблем, с которыми часто сталкиваются пользователи Unix, — сложность восстановления удаленных по ошибке файлов или каталогов. В Unix нет приложения, такого же удобного, как Undelete 360, WinUndelete или утилита для OS X, которое позволяло бы просматривать и восстанавливать удаленные файлы щелчком на кнопке. Как только вы нажмете клавишу enter после ввода команды rm filename, файл станет историей. Чтобы решить эту проблему, нужно организовать тайное и автоматическое архивирование файлов и каталогов в архив .deleted-files. Немного подумав, можно написать сценарий, который сделает все это почти незаметно для пользователя.
>  Синтаксис [if](https://ryanstutorials.net/bash-scripting-tutorial/bash-if-statements.php)
>  
> `if ANY_COMMAND_YOU_WANT_AT_ALL; then `
> `# ... stuff to do`
>  `fi`
> Любые переданные им аргументы могут назначаться позиционно с помощью особых переменных `$1`, `$2`, `$3` и т. д. Число аргументов содержится в переменной `$#`.
> [getopts](https://habr.com/ru/articles/169133/)
```bash
#!/bin/bash
# newrm -- замена существующей команды rm.
#
# Этот сценарий предоставляет простую возможность восстановления, создавая и
# используя новый каталог в домашнем каталоге пользователя. Может обрабатывать
# каталоги и отдельные файлы. Если пользователь добавляет флаг -f, файлы
# удаляются БЕЗ архивирования. 
# Важное предупреждение: возможно, вам понадобится создать задание для cron или
# нечто подобное для очистки удаленных каталогов и файлов через некоторое
# время. Иначе файлы не будут удаляться из системы и вы рискуете исчерпать
# дисковое пространство!

archivedir="$HOME/.deleted-files"
realrm="$(which rm)"
copy="$(which cp) -R"
if [ $# -eq 0 ] ; then # Позволить 'rm’ вывести сообщение о порядке использования.
    exec $realrm # Our shell is replaced by /bin/rm.
fi
# Проверить все параметры на наличие флага '-f’
flags=""
while getopts "dfiPRrvW" opt
do
    case $opt in
        f ) exec $realrm "$@"
            ;; # exec позволяет покинуть сценарий немедленно.
        * ) flags="$flags -$opt" ;; # Другие флаги предназначены команде rm.
    esac
done
shift $(( $OPTIND - 1 ))
# НАЧАЛО ОСНОВНОГО СЦЕНАРИЯ
# =================
# Гарантировать наличие каталога $archivedir.
if [ ! -d $archivedir ] ; then
    if [ ! -w $HOME ] ; then
        echo "$0 failed: can't create $archivedir in $HOME" >&2
        exit 1
    fi
    mkdir $archivedir
    chmod 700 $archivedir # Ограничить доступ к каталогу.
fi
for arg do
    newname="$archivedir/$(date "+%S.%M.%H.%d.%m").$(basename "$arg")"
    if [ -f "$arg" -o -d "$arg" ] ; then
        $copy "$arg" "$newname"
    fi
done
exec $realrm $flags "$@" # Текущий сценарий будет вытеснен командой realrm."
```
Пример использования 
```bash
root@de30378728be:/test# chmod 777 newrm.sh
root@de30378728be:/test# ./newrm.sh wap.txt
root@de30378728be:/test# ls
newrm.sh
root@de30378728be:/test# ls $HOME/.
./              .config/
../             .deleted-files/
.bashrc         .profile
.cache/         .viminfo
root@de30378728be:/test# ls $HOME/.deleted-files/
26.30.10.22.09.wap.txt
root@de30378728be:/test#
```

Улучшение функции `ls -l` 
```bash
#!/bin/bash
# formatdir -- выводит содержимое каталога в дружественном и информативном виде
# Обратите внимание: необходимо, чтобы "scriptbc" (сценарий № 9) находился в одном из каталогов, перечисленных в PATH, потому что он неоднократно вызывается в данном сценарии.
scriptbc=$(which scriptbc)
# Функция для преобразования размеров из KB в KB, MB или GB для большей удобочитаемости вывода
readablesize()
{
    if [ $1 -ge 1048576 ] ; then
        echo "$($scriptbc -p 2 $1 / 1048576)GB"
    elif [ $1 -ge 1024 ] ; then
        echo "$($scriptbc -p 2 $1 / 1024)MB"
    else
        echo "${1}KB"
    fi
}
#################
## КОД ОСНОВНОГО СЦЕНАРИЯ
if [ $# -gt 1 ] ; then
    echo "Usage: $0 [dirname]" >&2
    exit 1
elif [ $# -eq 1 ] ; then # Указан определенный каталог, не текущий?
    cd "$@" # Тогда перейти в него.
    if [ $? -ne 0 ] ; then # Или выйти, если каталог не существует.
        exit 1
    fi
fi

for file in *
do
    if [ -d "$file" ] ; then
        size=$(ls "$file" | wc -l | sed 's/[^[:digit:]]//g')
        if [ $size -eq 1 ] ; then
            echo "$file ($size entry)|"
        else
            echo "$file ($size entries)|"
        fi
    else
        size="$(ls -sk "$file" | awk '{print $1}')"
        echo "$file ($(readablesize $size))|"
    fi
done | \
sed 's/ /^^^/g' | \
xargs -n 2 | \
sed 's/\^\^\^/ /g' | \
awk -F\| '{ printf "%-39s %-39s\n", $1, $2 }'

exit 0
```
Пример использования 
```bash
root@de30378728be:/test# chmod 777 formatdir.sh
root@de30378728be:/test# ./formatdir.sh
formatdir.sh (4KB)                       newrm.sh (4KB)
root@de30378728be:/test# ./formatdir.sh /
bin (562 entries)                        boot (0 entries)
dev (16 entries)                         etc (95 entries)
home (0 entries)                         lib (30 entries)
lib32 (0 entries)                        lib64 (1 entry)
libx32 (0 entries)                       media (0 entries)
mnt (0 entries)                          opt (0 entries)
proc (74 entries)                        root (0 entries)
run (3 entries)                          sbin (123 entries)
srv (0 entries)                          sys (11 entries)
test (2 entries)                         tmp (0 entries)
usr (12 entries)                         var (11 entries)
root@de30378728be:/test#
```
