# Курс: Информатика
#computer_science #python #flash 

# Flask (веб-фреймоворк)

**Flask** — [фреймворк](https://ru.wikipedia.org/wiki/%D0%A4%D1%80%D0%B5%D0%B9%D0%BC%D0%B2%D0%BE%D1%80%D0%BA "Фреймворк") для создания [веб-приложений](https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%B1-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5 "Веб-приложение") на языке программирования [Python](https://ru.wikipedia.org/wiki/Python "Python"), использующий набор инструментов Werkzeug, а также шаблонизатор [Jinja2](https://ru.wikipedia.org/wiki/Jinja "Jinja"). Относится к категории так называемых [микрофреймворков](https://ru.wikipedia.org/w/index.php?title=%D0%9C%D0%B8%D0%BA%D1%80%D0%BE%D1%84%D1%80%D0%B5%D0%B9%D0%BC%D0%B2%D0%BE%D1%80%D0%BA&action=edit&redlink=1 "Микрофреймворк (страница отсутствует)")[[en]](https://en.wikipedia.org/wiki/microframework "en:microframework") — минималистичных каркасов веб-приложений, сознательно предоставляющих лишь самые базовые возможности.

Поддерживается установка посредством пакетного менеджера [PyPI](https://ru.wikipedia.org/wiki/PyPI "PyPI"), версия 1.0 совместима с Python 2.7, Python 3.3 и выше.

Создатель и основной автор — австрийский программист [Армин Ронахер](https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BD%D0%B0%D1%85%D0%B5%D1%80,_%D0%90%D1%80%D0%BC%D0%B8%D0%BD "Ронахер, Армин"), начал работу над проектом в 2010 году.

Пример веб-приложения, которое показывает «[Hello World](https://ru.wikipedia.org/wiki/Hello_World "Hello World")!»:

```python
from flask import Flask
app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello World!"

if __name__ == "__main__":
    app.run()
```

Основные возможности:
- Сервер и отладчик времени разработки
- Интегрированная поддержка [модульного тестирования](https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5 "Модульное тестирование")
- [RESTful](https://ru.wikipedia.org/wiki/RESTful "RESTful")-маршрутизация запросов
- Использует [шаблонизатор](https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%82%D0%BE%D1%80 "Шаблонизатор") [Jinja](https://ru.wikipedia.org/wiki/Jinja "Jinja")
- Поддержка безопасных [cookie](https://ru.wikipedia.org/wiki/Cookie "Cookie") (сессии на стороне клиента)
- Полностью совместим с [WSGI](https://ru.wikipedia.org/wiki/WSGI "WSGI") 1.0
- Основан на [Unicode](https://ru.wikipedia.org/wiki/Unicode "Unicode")
- Полная документация
- Совместимость с [Google App Engine](https://ru.wikipedia.org/wiki/Google_App_Engine "Google App Engine")
- Возможности расширения функциональности

# Установка

Возможно, Virtualenv - именно то, что вы захотите использовать при разработке, а если у вас на рабочем сервере есть доступ к командной оболочке, вероятно, вы захотите использовать Virtualenv и здесь.

Какую из проблем решает virtualenv? Если вам нравится Python так, как он нравится мне, скорее всего, вы захотите использовать его и в других проектах - вне приложений, созданных на базе Flask.

Но чем больше у вас проектов, тем больше вероятность, что вы будете работать с разными версиями самого Python, или, по крайней мере, с различными версиями библиотек Python. Посмотрим правде в глаза: довольно часто библиотеки нарушают обратную совместимость, и маловероятно, что серьёзное приложение будет работать вообще без каких-либо зависимостей. Так что же делать, если два или более из ваших проектов имеют конфликтующие зависимости?

Наше спасение - Virtualenv! Virtualenv предоставляет несколько соседствующих друг с другом установленных версий Python, по одной для каждого проекта. На самом деле он реально не устанавливает различные версии Python, но обеспечивает хитрый способ создать для проектов несколько изолированных друг от друга окружений. Давайте посмотрим, как работает virtualenv.

```bash
sudo pip install virtualenv
```

После того, как virtualenv была установлена, просто запустите командный интерпретатор и создайте ваше собственное окружение. Обычно в таких случаях я создаю папку проекта, а в ней - папку venv:

```bash
$ mkdir myproject
$ cd myproject
$ virtualenv venv
New python executable in venv/bin/python
Installing setuptools, pip............done.
```

Теперь, когда вы захотите работать над проектом, вам необходимо лишь активировать соответствующее окружение. Под MacOS X и Linux, выполните следующее:

```bash
$ . venv/bin/activate
```

Если вы используете Windows, для вас подойдёт следующая команда:

```bash
$ venv\scripts\activate
```

В любом случае, теперь вы должны использовать ваш virtualenv (обратите внимание, как изменилось приглашение вашей командной оболочки - для того, чтобы показать активное окружение).

А если вы захотите вернуться обратно в «реальный мир», используйте команду:

```
$ deactivate
```

Полсе этого подсказка вашей командной оболочки вернёт свой прежний привычный вид.

Теперь, двинемся дальше. Для того, чтобы Flask появился в вашем виртуальном окружении, введите команду:

```
$ pip install Flask
```

Через несколько секунд вы сможете двинуться в дальнейший путь.

## Установка непосредственно в систему

Возможен и такой вариант установки, но я бы вам его не рекомендовал. Просто запустите pip с привилегиями суперпользователя:

```
$ sudo pip install Flask
```

(Под Windows, запустите ту же команду, но только без sudo, внутри окна с командной строкой, запущенного с привилегиями администратора системы)

## Жизнь на переднем краю
Если вы хотите работать с самой последней версией Flask, существует два пути: можно указать pip, чтобы он загрузил версию для разработки, или можно работать со срезом с текущего состояния репозитория git. В обоих случаях, рекомендуется пользоваться virtualenv.

Получите срез с последнего состояния git в новом окружении virtualenv и запустите в режиме разработки:
```bash
$ git clone http://github.com/mitsuhiko/flask.git
Initialized empty Git repository in ~/dev/flask/.git/
$ cd flask
$ virtualenv venv
New python executable in venv/bin/python
Installing setuptools, pip............done.
$ . venv/bin/activate
$ python setup.py develop
...
Finished processing dependencies for Flask
```

Будет скачана и активирована в virtualenv текущая версия, соответствующая последнему (головному) срезу из git. В дальнейшем, чтобы обновиться до последней версии, всё, что вам будет необходимо сделать - это выполнить `git pull origin`.

## pip и setuptools в MS Windows[](https://flask-russian-docs.readthedocs.io/ru/0.10.1/installation.html#pip-setuptools-ms-windows "Ссылка на этот заголовок")

Иногда получение стандартных инструментов по работе с пакетами в Python - таких, как _pip_, _setuptools_ и _virtualenv_ может быть несколько мудрёным, но на самом деле в этом нет ничего сложного. Вам нужны два ключевых пакета - setuptools и pip - которые позволят вам инсталлировать всё остальное (в том числе virtualenv). К счастью, есть два готовых скрипта, запустив которые вы можете развернуть оба пакета «с нуля».

Если у вас их нет, скрипт get-pip.py осуществит инсталляцию обоих (вам не нужно будет запускать ez_setup.py).

[get-pip.py](https://raw.githubusercontent.com/pypa/pip/master/contrib/get-pip.py)

Для инсталляции последней версии setuptools, вы можете использовать следующий скрипт, предназначенный для разворачивания «с нуля»:

[ez_setup.py](https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez_setup.py)

Оба этих скрипта необходимо скачать и запустить двойным щелчком мыши. Если у вас уже есть pip, вы можете обновить его, запустив команду:
```cmd
pip install --upgrade pip setuptools
```

Чаще всего, получив приглашение командной строки, вы захотите иметь возможность набрать `pip` и `python`, что должно привести к запуску этих команд, однако в Windows этого автоматически не происходит, потому что операционная система не знает, где располагаются их исполнимые файлы (вы можете попробовать!).

Чтобы исправить это, вам необходимо перейти в папку, куда вы установили Python (например, `C:\Python27`), а затем в подпапки `Tools`, `Scripts`; затем найти файл `win_add2path.py` и запустить его. Далее открыть **новую** Командную строку и проверить, что при вводе `python` запускается командный интерпретатор.

Наконец, для того, чтобы инсталлировать [virtualenv](https://flask-russian-docs.readthedocs.io/ru/0.10.1/installation.html#virtualenv), вы можете просто ввести:

```bash
pip install virtualenv
```

Теперь, когда вы установили всё, что нужно, выполнив вышеизложенные инструкции, можно откинуться на спинку кресла.

# Минимальное приложение 

```python
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello World!'

if __name__ == '__main__':
    app.run()
```

Просто сохраните его под именем наподобие `hello.py` и запустите с помощью вашего интерпретатора Python. Только, пожалуйста, не давайте приложению имя `flask.py`, так как это вызовет конфликт с самим Flask.

```bash
$ python hello.py
 * Running on http://127.0.0.1:5000/
```
проследовав по ссылке [http://127.0.0.1:5000/](http://127.0.0.1:5000/) вы увидите ваше приветствие миру.

Итак, что же делает этот код?

1. Сначала мы импортировали класс [`Flask`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.Flask "flask.Flask"). Экземпляр этого класса и будет вашим WSGI-приложением.
2. Далее мы создаём экземпляр этого класса. Первый аргумент - это имя модуля или пакета приложения. Если вы используете единственный модуль (как в этом примере), вам следует использовать __name__, потому что в зависимости от того, запущен ли код как приложение, или был импортирован как модуль, это имя будет разным (`'__main__'` или актуальное имя импортированного модуля соответственно). Это нужно, чтобы Flask знал, где искать шаблоны, статические файлы и прочее. Для дополнительной информации, смотрите документацию [`Flask`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.Flask "flask.Flask").
3. Далее, мы используем декоратор [`route()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.Flask.route "flask.Flask.route"), чтобы сказать Flask, какой из URL должен запускать нашу функцию.
4. Функция, которой дано имя, используемое также для генерации URL-адресов для этой конкретной функции, возвращает сообщение, которое мы хотим отобразить в браузере пользователя.
5. Наконец, для запуска локального сервера с нашим приложением, мы используем функцию [`run()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.Flask.run "flask.Flask.run"). Благодаря конструкции `if __name__ == '__main__'` можно быть уверенным, что сервер запустится только при непосредственном вызове скрипта из интерпретатора Python, а не при его импортировании в качестве модуля.

Для остановки сервера, нажмите Ctrl+C.

> Публично доступный сервер
> Если вы запустите сервер, вы заметите, что он доступен только с вашего собственного компьютера, а не с какого-либо другого в сети. Так сделано по умолчанию, потому что в режиме отладки пользователь приложения может выполнить код на Python на вашем компьютере.
> Если у вас отключена опция debug или вы доверяете пользователям в сети, вы можете сделать сервер публично доступным, просто изменив вызов метода [`run()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.Flask.run "flask.Flask.run") таким вот образом:
> app.run(host='0.0.0.0')
> Это укажет вашей операционной системе, чтобы она слушала сеть со всех публичных IP-адресов.


## Режим отладки

Метод [`run()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.Flask.run "flask.Flask.run") чудесно подходит для запуска локального сервера для разработки, но вы будете должны перезапускать его всякий раз при изменении вашего кода. Это не очень здорово, и Flask здесь может облегчить жизнь. Если вы включаете поддержку отладки, сервер перезагрузит сам себя при изменении кода, кроме того, если что-то пойдёт не так, это обеспечит вас полезным отладчиком.

Существует два способа включить отладку. Или установите флаг в объекте приложения:

```python
app.debug = True
app.run()
```
Или передайте его как параметр при запуске:

```python
app.run(debug=True)
```

Оба метода вызовут одинаковый эффект.

Внимание.

Несмотря на то, что интерактивный отладчик не работает в многопоточных окружениях (что делает его практически неспособным к использованию на реальных рабочих серверах), тем не менее, он позволяет выполнение произвольного кода. Это делает его главной угрозой безопасности, и поэтому **он никогда не должен использоваться на реальных «боевых» серверах**.

Снимок экрана с отладчиком в действии:

![screenshot of debugger in action](https://flask-russian-docs.readthedocs.io/ru/0.10.1/_images/debugger.png)

Предполагаете использовать другой отладчик? Тогда смотрите [Работа с отладчиками](https://flask-russian-docs.readthedocs.io/ru/0.10.1/errorhandling.html#working-with-debuggers).

## Маршрутизация

Современные веб-приложения используют «красивые» URL. Это помогает людям запомнить эти URL, это особенно удобно для приложений, используемых с мобильных устройств с более медленным сетевым соединением. Если пользователь может перейти сразу на желаемую страницу, без предварительного посещения начальной страницы, он с большей вероятностью вернётся на эту страницу и в следующий раз.

Как вы увидели ранее, декоратор [`route()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.Flask.route "flask.Flask.route") используется для привязки функции к URL. Вот простейшие примеры:

```python
@app.route('/')
def index():
    return 'Index Page'
```

```python
@app.route('/hello')
def hello():
    return 'Hello World'
```

Но это еще не все! Вы можете сделать определенные части URL динамически меняющимися и задействовать в функции несколько правил.

### Правила для переменной части

Чтобы добавлять к адресу URL переменные части, можно эти особые части выделить как `<variable_name>`. Затем подобные части передаются в вашу функцию в качестве аргумента - в виде ключевого слова. Также может быть использован конвертер - с помощью задания правила следующего вида `<converter:variable_name>`. Вот несколько интересных примеров

```python
@app.route('/user/<username>')
def show_user_profile(username):
    # показать профиль данного пользователя
    return 'User %s' % username

@app.route('/post/<int:post_id>')
def show_post(post_id):
    # вывести сообщение с данным id, id - целое число
    return 'Post %d' % post_id
```
Существуют следующие конвертеры:

|   |   |
|---|---|
|int|принимаются целочисленные значения|
|float|как и int, только значения с плавающей точкой|
|path|подобно поведению по умолчанию, но допускаются слэши|

### Уникальные URL / Перенаправления

Правила для URL, работающие в Flask, основаны на модуле маршрутизации Werkzeug. Этот модуль реализован в соответствие с идеей обеспечения красивых и уникальных URL-адресов на основе исторически попавшего в обиход - из поведения Apache и более ранних HTTP серверов.

Возьмём два правила:

```python
@app.route('/projects/')
def projects():
    return 'The project page'

@app.route('/about')
def about():
    return 'The about page'
```

Хоть они и выглядят довольно похожими, есть разница в использовании слэша в _определении_ URL. В первом случае, канонический URL имеет завершающую часть projects со слэшем в конце. В этом смысле он похож на папку в файловой системе. В данном случае, при доступе к URL без слэша, Flask перенаправит к каноническому URL с завершающим слэшем.

Однако, во втором случае, URL определен без косой черты - как путь к файлу на UNIX-подобных системах. Доступ к URL с завершающей косой чертой будет приводить к появлению ошибки 404 «Not Found».

Такое поведение позволяет продолжить работать с относительными URL, даже если в конце строки URL пропущен слэш - в соответствии с тем, как работают Apache и другие сервера. Кроме того, URL-адреса останутся уникальными, что поможет поисковым системам избежать повторной переиндексации страницы.

### Построение (генерация) URL
Раз Flask может искать соответствия в URL, может ли он их генерировать? Конечно, да. Для построения URL для специфической функции, вы можете использовать функцию [`url_for()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.url_for "flask.url_for"). В качестве первого аргумента она принимает имя функции, кроме того она принимает ряд именованных аргументов, каждый из которых соответствует переменной части правила для URL. Неизвестные переменные части добавляются к URL в качестве параметров запроса. Вот некоторые примеры:
```python
>>> from flask import Flask, url_for
>>> app = Flask(__name__)
>>> @app.route('/')
... def index(): pass
...
>>> @app.route('/login')
... def login(): pass
...
>>> @app.route('/user/<username>')
... def profile(username): pass
...
>>> with app.test_request_context():
...  print url_for('index')
...  print url_for('login')
...  print url_for('login', next='/')
...  print url_for('profile', username='John Doe')
...
/
/login
/login?next=/
/user/John%20Doe
```

(Здесь также использован метод [`test_request_context()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.Flask.test_request_context "flask.Flask.test_request_context"), который будет объяснён ниже. Он просит Flask вести себя так, как будто он обрабатывает запрос, даже если мы взаимодействуем с ним через оболочку Python. Взгляните на нижеследующее объяснение. [Локальные объекты контекста (context locals)](https://flask-russian-docs.readthedocs.io/ru/0.10.1/quickstart.html#context-locals).

Зачем Вам может потребоваться формировать URL-ы с помощью функции их обращения [`url_for()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.url_for "flask.url_for") вместо того, чтобы жёстко задать их в ваших шаблонах? Для этого есть три веские причины:

1. По сравнению с жёстким заданием URL внутри кода обратный порядок часто является более наглядным. Более того, он позволяет менять URL за один шаг, и забыть про необходимость изменять URL повсюду. 2. Построение URL будет прозрачно для вас осуществлять экранирование специальных символов и данных Unicode, так что вам не придётся отдельно иметь с ними дела. 3. Если ваше приложение размещено не в корневой папке URL root (а, скажем, в `/myapplication` вместо `/`), данную ситуацию нужным для вас образом обработает функция [`url_for()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.url_for "flask.url_for").

### Методы HTTP
HTTP (протокол, на котором общаются веб-приложения) может использовать различные методы для доступа к URL-адресам. По умолчанию, route отвечает лишь на запросы типа GET, но это можно изменить, снабдив декоратор [`route()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.Flask.route "flask.Flask.route") аргументом methods. Вот некоторые примеры:

```python
from flask import request

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        do_the_login()
    else:
        show_the_login_form()
```

Если присутствует метод GET, то автоматически будет добавлен и HEAD. Вам не придётся иметь с ним дело. Также, при этом можно быть уверенным, что запросы HEAD будут обработаны в соответствии с требованиями [HTTP RFC](http://www.ietf.org/rfc/rfc2068.txt) (документ с описанием протокола HTTP), так что вам не требуется ничего знать об этой части спецификации HTTP. Кроме того, начиная с Flask версии 0.6, для вас будет автоматически реализован метод OPTIONS автоматически.

Не имеете понятия, что такое метод HTTP? Не беспокойтесь, здесь приводится быстрое введение в методы HTTP, и почему они важны:

HTTP-метод (также часто называемый командой) сообщает серверу, что хочет сделать клиент с запрашиваемой страницей. Очень распространены Следующие методы:

#### GET

Браузер говорит серверу, чтобы он просто получил информацию, хранимую на этой странице, и отослал её. Возможно, это самый распространённый метод.

#### HEAD

Браузер просит сервер получить информацию, но его интересует только _заголовки_, а не содержимое страницы. Приложение предполагает обработать их так же, как если бы был получен запрос GET, но без доставки фактического содержимого. В Flask, вам вовсе не требуется иметь дело с этим методом, так как нижележащая библиотека Werkzeug сделает всё за вас.

#### POST

Браузер говорит серверу, что он хочет сообщить этому URL некоторую новую информацию, и что сервер должен убедиться, что данные сохранены и сохранены в единожды. Обычно, аналогичным образом происходит передача из HTML форм на сервер данных.

#### PUT

Похоже на POST, только сервер может вызвать процедуру сохранения несколько раз, перезаписывая старые значения более одного раза. Здесь вы можете спросить, зачем это нужно, и есть несколько веских причин, чтобы делать это подобным образом. Предположим, во время передачи произошла потеря соединения: в этой ситуации система между браузером и сервером, ничего не нарушая, может совершенно спокойно получить запрос во второй раз. С POST такое было бы невозможно, потому что он может быть вызван только один раз.

#### DELETE

Удалить информацию, расположенную в указанном месте.

#### OPTIONS

Обеспечивает быстрый способ выяснения клиентом поддерживаемых для данного URL методов. Начиная с Flask 0.6, это работает для вас автоматически.

Теперь самое интересное: в HTML 4 и XHTML1, единственными методами, которыми форма может отправить серверу данные, являются GET и POST. Но для JavaScript и будущих стандартов HTML вы также можете использовать и другие методы. Кроме того, в последнее время HTTP стал довольно популярным, и теперь браузеры уже не единственные клиенты, использующие HTTP. Например, его используют многие системы контроля версий.

## Статические файлы

Динамические веб-приложения также нуждаются и в статических файлах. Обычно, именно из них берутся файлы CSS и JavaScript. В идеале ваш веб-сервер уже сконфигурирован так, чтобы обслуживать их для вас, однако в ходе разработке это также может делать и сам Flask. Просто создайте внутри вашего пакета или модуля папку с названием static, и она будет доступна из приложения как /static.

Чтобы сформировать для статических файлов URL, используйте специальное окончание `'static'`:

```python
url_for('static', filename='style.css')
```

Этот файл должен храниться в файловой системе как `static/style.css`.

## Визуализация шаблонов

Генерация HTML из Python - невесёлое и на самом деле довольно сложное занятие, так как вам необходимо самостоятельно заботиться о безопасности приложения, производя для HTML обработку специальных последовательностей (escaping). Поэтому внутри Flask уже автоматически преднастроен шаблонизатор [Jinja2](http://jinja.pocoo.org/).

Для визуализации шаблона вы можете использовать метод [`render_template()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.render_template "flask.render_template"). Всё, что вам необходимо - это указать имя шаблона, а также переменные в виде именованных аргументов, которые вы хотите передать движку обработки шаблонов:

```python
from flask import render_template

@app.route('/hello/')
@app.route('/hello/<name>')
def hello(name=None):
    return render_template('hello.html', name=name)
```

Flask будет искать шаблоны в папке templates. Поэтому, если ваше приложение выполнено в виде модуля, эта папка будет рядом с модулем, а если в виде пакета, она будет внутри вашего пакета:

**Первый случай** - модуль:

```python
/application.py
/templates
    /hello.html
```

**Второй случай** - пакет:

```python
/application
    /__init__.py
    /templates
        /hello.html
```

При работе с шаблонами вы можете использовать всю мощь Jinja2. За дополнительной информацией обратитесь к официальной [Документации по шаблонам Jinja2](http://jinja.pocoo.org/docs/templates)

Вот пример шаблона:

```html
<!doctype html>
<title>Hello from Flask</title>
{% if name %}
  <h1>Hello {{ name }}!</h1>
{% else %}
  <h1>Hello World!</h1>
{% endif %}
```
Также, внутри шаблонов вы имеете доступ к объектам [`request`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.request "flask.request"), [`session`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.session "flask.session") и [`g`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.g "flask.g") [1](https://flask-russian-docs.readthedocs.io/ru/0.10.1/quickstart.html#id10), а также к функции [`get_flashed_messages()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.get_flashed_messages "flask.get_flashed_messages").

Шаблоны особенно полезны при использовании наследования. Если вам интересно, как это работает, обратитесь к документации по заготовкам [Template Inheritance](http://jinja.pocoo.org/docs/templates/#template-inheritance "(в Jinja2 v2.11)"). Проще говоря, наследование шаблонов позволяет разместить определённые элементы (такие, как заголовки, элементы навигации и «подвал» страницы) на каждой странице.

Автоматическая обработка специальных (escape-) последовательностей (escaping) включена по умолчанию, поэтому если name содержит HTML, он будет экранирован автоматически. Если вы можете доверять переменной и знаете, что в ней будет безопасный HTML (например, потому что он пришёл из модуля конвертирования разметки wiki в HTML), вы можете пометить её в шаблоне, как безопасную - с использованием класса [`Markup`](http://jinja.pocoo.org/docs/api/#jinja2.Markup "(в Jinja2 v2.11)") или фильтра `|safe`. За дополнительными примерами обратитесь к документации по Jinja2.

Вот основные возможности по работе с классом [`Markup`](http://jinja.pocoo.org/docs/api/#jinja2.Markup "(в Jinja2 v2.11)"):

```python
>>> from flask import Markup
>>> Markup('<strong>Hello %s!</strong>') % '<blink>hacker</blink>'
Markup(u'<strong>Hello &lt;blink&gt;hacker&lt;/blink&gt;!</strong>')
>>> Markup.escape('<blink>hacker</blink>')
Markup(u'&lt;blink&gt;hacker&lt;/blink&gt;')
>>> Markup('<em>Marked up</em> &raquo; HTML').striptags()
u'Marked up \xbb HTML'
```


|   |   |
|---|---|
|[[1]](https://flask-russian-docs.readthedocs.io/ru/0.10.1/quickstart.html#id9)|Затрудняетесь понять, что это за объект - [`g`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.g "flask.g")? Это то, в чём вы можете хранить информацию для ваших собственных нужд, для дополнительной информации смотрите документацию на этот объект ([`g`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.g "flask.g")) и sqlite3.|

## Доступ к данным запроса
Для веб-приложений важно, чтобы они реагировали на данные, которые клиент отправляет серверу. В Flask эта информация предоставляется глобальным объектом [`request`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.request "flask.request"). Если у вас есть некоторый опыт по работе с Python, вас может удивить, как этот объект может быть глобальным, и как Flask при этом умудрился остаться ориентированным на многопоточное выполнение.

### Локальные объекты контекста (context locals)

>Информация от инсайдера
	Прочтите этот раздел, если вы хотите понять, как это работает, и как вы можете реализовать тесты с локальными переменными контекста. Если вам это неважно, просто пропустите его.

Некоторые объекты в Flask являются глобальными, но необычного типа. Эти объекты фактически являются прокси (посредниками) к объектам, локальным для конкретного контекста. Труднопроизносимо. Но на самом деле довольно легко понять.

Представьте себе контекст, обрабатывающий поток. Приходит запрос, и веб-сервер решает породить новый поток (или нечто иное - базовый объект может иметь дело с системой параллельного выполнения не на базе потоков). Когда Flask начинает осуществлять свою внутреннюю обработку запроса, он выясняет, что текущий поток является активным контекстом и связывает текущее приложение и окружение WSGI с этим контекстом (потоком). Он делает это с умом - так, что одно приложение может, не ломаясь, вызывать другое приложение.

Итак, что это означает для вас? В принципе, вы можете полностью игнорировать, что это так, если вы не делаете чего-либо вроде тестирования модулей. Вы заметите, что код, зависящий от объекта запроса, неожиданно будет работать неправильно, так как отсутствует объект запроса. Решением является самостоятельное создание объекта запроса и его привязка к контексту. Простейшим решением для тестирования модулей является использование менеджера контекстов [`test_request_context()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.Flask.test_request_context "flask.Flask.test_request_context"). В сочетании с оператором with этот менеджер свяжет тестовый запрос так, что вы сможете с ним взаимодействовать. Вот пример:

```python
from flask import request

with app.test_request_context('/hello', method='POST'):
    # теперь, и до конца блока with, вы можете что-либо делать
    # с контекстом, например, вызывать простые assert-ы:
    assert request.path == '/hello'
    assert request.method == 'POST'
```

Другая возможность - это передача целого окружения WSGI методу [`request_context()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.Flask.request_context "flask.Flask.request_context") method:

```python
from flask import request

with app.request_context(environ):
    assert request.method == 'POST'
```

### Объект запроса
Объект запроса документирован в секции API, мы не будем рассматривать его здесь подробно (смотри [`request`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.request "flask.request")). Вот широкий взгляд на некоторые наиболее распространённые операции. Прежде всего, вам необходимо импортировать его из модуля flask:

```python
from flask import request
```

В настоящее время метод запроса доступен через использование атрибута `method`. Для доступа к данным формы (данным, которые передаются в запросах типа POST или PUT), вы можете использовать атрибут `form`. Вот полноценный пример работы с двумя упомянутыми выше атрибутами:

```python
@app.route('/login', methods=['POST', 'GET'])
def login():
    error = None
    if request.method == 'POST':
        if valid_login(request.form['username'],
                       request.form['password']):
            return log_the_user_in(request.form['username'])
        else:
            error = 'Invalid username/password'
    # следущий код выполняется при методе запроса GET
    # или при признании полномочий недействительными
    return render_template('login.html', error=error)
```

Что произойдёт, если ключ, указанный в атрибуте form, не существует? В этом случае будет возбуждена специальная ошибка [`KeyError`](https://docs.python.org/dev/library/exceptions.html#KeyError "(в Python v3.8)"). Вы можете перехватить её подобно стандартной [`KeyError`](https://docs.python.org/dev/library/exceptions.html#KeyError "(в Python v3.8)"), но если вы этого не сделаете, вместо этого будет показана страница с ошибкой HTTP 400 Bad Request. Так что во многих ситуациях вам не придётся иметь дело с этой проблемой.

Для доступа к параметрам, представленным в URL (`?ключ=значение`), вы можете использовать атрибут `args`:

```python
searchword = request.args.get('key', '')
```

Мы рекомендуем доступ к параметрам внутри URL через get или через перехват KeyError, так как пользователь может изменить URL, а предъявление ему страницы с ошибкой 400 bad request не является дружественным.

За полным списком методов и атрибутов объекта запроса, обратитесь к следующей документации: [`request`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.request "flask.request").

### Загрузка файлов на сервер
В Flask обработка загружаемых на сервер файлов является несложным занятием. Просто убедитесь, что вы в вашей HTML-форме не забыли установить атрибут `enctype="multipart/form-data"`, в противном случае браузер вообще не передаст файл.

Загруженные на сервер файлы сохраняются в памяти или во временной папке внутри файловой системы. Вы можете получить к ним доступ, через атрибут объекта запроса `files`. Каждый загруженный файл сохраняется в этом словаре. Он ведёт себя так же, как стандартный объект Python `file`, однако он также имеет метод [`save()`](http://werkzeug.pocoo.org/docs/datastructures/#werkzeug.datastructures.FileStorage.save "(в Werkzeug v0.14-dev)"), который вам позволяет сохранить данный файл внутрь файловой системы сервера. Вот простой пример, показывающий, как это работает:

```python
from flask import request

@app.route('/upload', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        f = request.files['the_file']
        f.save('/var/www/uploads/uploaded_file.txt')
    ...
```
Если вы хотите до загрузки файла в приложение узнать, как он назван на стороне клиента, вы можете просмотреть атрибут [`filename`](http://werkzeug.pocoo.org/docs/datastructures/#werkzeug.datastructures.FileStorage.filename "(в Werkzeug v0.14-dev)"). Однако, имейте в виду, что данному значению никогда не стоит доверять, потому что оно может быть подделано. Если вы хотите использовать имя файла на клиентской стороне для сохранения файла на сервере, пропустите его через функцию [`secure_filename()`](http://werkzeug.pocoo.org/docs/utils/#werkzeug.utils.secure_filename "(в Werkzeug v0.14-dev)"), которой вас снабдил Werkzeug:

``` python
from flask import request
from werkzeug import secure_filename

@app.route('/upload', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        f = request.files['the_file']
        f.save('/var/www/uploads/' + secure_filename(f.filename))
    ...
```
Некоторые более удачные примеры можно найти в разделе заготовок: [Загрузка файлов](https://flask-russian-docs.readthedocs.io/ru/0.10.1/patterns/fileuploads.html#uploading-files).

### Cookies

Для доступа к cookies можно использовать атрибут [`cookies`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.Request.cookies "flask.Request.cookies"). Для установки cookies можно использовать метод объектов ответа [`set_cookie`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.Response.set_cookie "flask.Response.set_cookie"). Атрибут объектов запроса [`cookies`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.Request.cookies "flask.Request.cookies") - это словарь со всеми cookies, которые передаёт клиент. Если вы хотите использовать сессии, то не используйте cookies напрямую, вместо этого используйте во Flask [Сессии](https://flask-russian-docs.readthedocs.io/ru/0.10.1/quickstart.html#sessions), который при работе с cookies даст вам некоторую дополнительную безопасность.

Чтение cookies:

```python
from flask import request

@app.route('/')
def index():
    username = request.cookies.get('username')
    # Чтобы не получить в случае отсутствия cookie ошибку KeyError
    # используйте cookies.get(key) вместо cookies[key]

Сохранение cookies:

from flask import make_response

@app.route('/')
def index():
    resp = make_response(render_template(...))
    resp.set_cookie('username', 'the username')
    return resp
```

Заметьте, что cookies устанавливаются в объектах ответа. Так как вы обычно просто возвращаете строки из функций представления, Flask конвертирует их для вас в объекты ответа. Если вы это хотите сделать явно, то можете использовать функцию, [`make_response()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.make_response "flask.make_response"), затем изменив её.

Иногда вы можете захотеть установить cookie в точке, где объект ответа ещё не существует. Это можно сделать, используя заготовку deferred-callbacks.

Также об этом можно почитать здесь: [Об ответах](https://flask-russian-docs.readthedocs.io/ru/0.10.1/quickstart.html#about-responses).

## Ошибки и перенаправления[](https://flask-russian-docs.readthedocs.io/ru/0.10.1/quickstart.html#id15 "Ссылка на этот заголовок")

Чтобы перенаправить пользователя в иную конечную точку, используйте функцию [`redirect()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.redirect "flask.redirect"); для того, чтобы преждевременно прервать запрос с кодом ошибки, используйте функцию [`abort()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.abort "flask.abort") function:

```python
from flask import abort, redirect, url_for

@app.route('/')
def index():
    return redirect(url_for('login'))

@app.route('/login')
def login():
    abort(401)
    this_is_never_executed()
```

Это довольно бессмысленный пример, потому что пользователь будет перенаправлен с индексной страницы на страницу, на которую у него нет доступа (`401` означает отказ в доступе), однако он показывает, как это работает.

По умолчанию, для каждого кода ошибки отображается чёрно-белая страница с ошибкой. Если вы хотите видоизменить страницу с ошибкой, то можете использовать декоратор [`errorhandler()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.Flask.errorhandler "flask.Flask.errorhandler"):

```python
from flask import render_template

@app.errorhandler(404)
def page_not_found(error):
    return render_template('page_not_found.html'), 404
```

Обратите внимание на `404` после вызова [`render_template()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.render_template "flask.render_template"). Это сообщит Flask, что код статуса для этой страницы должен быть 404, что означает «не найдено». По умолчанию предполагается код «200», который означает «всё прошло хорошо».

## Об ответах

Возвращаемое из функции представления значение автоматически для вас конвертируется вас в объект ответа. Если возвращаемое значение является строкой, оно конвертируется в объект ответа в строку в виде тела ответа, код статуса `200 OK` и в mimetype со значением `text/html`. Логика, которую применяет Flask для конвертации возвращаемых значений в объекты ответа следующая:

1. Если возвращается объект ответа корректного типа, он прямо возвращается из представления.
2. Если это строка, создаётся объект ответа с этими же данными и параметрами по умолчанию.
3. Если возвращается кортеж, его элементы могут предоставлять дополнительную информацию. Такие кортежи должны соответствовать форме `(ответ, статус, заголовки)`, кортеж должен содержать хотя бы один из перечисленных элементов. Значение статус заменит код статуса, а элемент заголовки может быть или списком или словарём с дополнительными значениями заголовка.
4. Если ничего из перечисленного не совпало, Flask предполагает, что возвращаемое значение - это допустимая WSGI-заявка, и конвертирует его в объект ответа.

Если вы хотите в результате ответа заполучить объект внутри представления, то можете использовать функцию [`make_response()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.make_response "flask.make_response").

Представим, что вы имеете подобное представление:

```python
@app.errorhandler(404)
def not_found(error):
    return render_template('error.html'), 404
```

Вам надо всего лишь обернуть возвращаемое выражение функцией [`make_response()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.make_response "flask.make_response") и получить объект ответа для его модификации, а затем вернуть его:

```python
@app.errorhandler(404)
def not_found(error):
    resp = make_response(render_template('error.html'), 404)
    resp.headers['X-Something'] = 'A value'
    return resp
```

## Сессии

В дополнение к объекту ответа есть ещё один объект, называемый [`session`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.session "flask.session"), который позволяет вам сохранять от одного запроса к другому информацию, специфичную для пользователя. Это реализовано для вас поверх cookies, при этом используется криптографическая подпись этих cookie. Это означает, что пользователь может посмотреть на содержимое cookie, но не может ничего в ней изменить, если он конечно не знает значение секретного ключа, использованного для создания подписи.

В случае использования сессий вам необходимо установить значение этого секретного ключа. Вот как работают сессии:

```python
from flask import Flask, session, redirect, url_for, escape, request

app = Flask(__name__)

@app.route('/')
def index():
    if 'username' in session:
        return 'Logged in as %s' % escape(session['username'])
    return 'You are not logged in'

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        session['username'] = request.form['username']
        return redirect(url_for('index'))
    return '''
        <form action="" method="post">
            <p><input type=text name=username>
            <p><input type=submit value=Login>
        </form>
    '''

@app.route('/logout')
def logout():
    # удалить из сессии имя пользователя, если оно там есть
    session.pop('username', None)
    return redirect(url_for('index'))

# set the secret key.  keep this really secret:
app.secret_key = 'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT'
```

<form action="" method="post">
<p><input type=text name=username>
<p><input type=submit value=Login>
</form>


Упомянутая [`escape()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.escape "flask.escape") осуществляет для вас обработку специальных последовательностей (escaping), что необходимо, если вы не используете движок шаблонов (как в этом примере).

Как генерировать хорошие секретные ключи

Проблемой случайных значений является то, что трудно сказать, что действительно является является случайным. А секретный ключ должен быть настолько случайным, насколько это возможно. У вашей операционной системы есть способы для генерации достаточно случайных значений на базе криптографического случайного генератора, который может быть использован для получения таких ключей:

```python
>>> import os
>>> os.urandom(24)
'\xfd{H\xe5<\x95\xf9\xe3\x96.5\xd1\x01O<!\xd5\xa2\xa0\x9fR"\xa1\xa8'
```

Просто возьмите, скопируйте/вставьте это в ваш код, вот и готово.

Замечание о сессиях на базе cookie: Flask возьмёт значения, которые вы помещаете в объект сессии, и сериализует их в cookie. Если вы обнаружили какие-либо значения, которые не сохраняются между запросами, а cookies реально включены, а никаких ясных сообщений об ошибках не было, проверьте размер cookie в ответах вашей страницы и сравните с размером, поддерживаемым веб-браузером.

## Message Flashing
Хорошие приложения и интерфейсы пользователя дают обратную связь. Если пользователь не получает достаточной обратной связи, вскоре он может начать ненавидеть приложение. При помощи системы всплывающих сообщений Flask предоставляет пользователю по-настоящему простой способ обратной связи. Система всплывающих сообщений обычно делает возможным записать сообщение в конце запроса и получить к нему доступ во время обработки следующего и только следующего запроса. Обычно эти сообщения используются в шаблонах макетов страниц, которые его и отображают.

Чтобы вызвать всплывающие сообщения, используйте метод [`flash()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.flash "flask.flash"), чтобы заполучить сообщения, можно использовать метод, также доступный для шаблонов - [`get_flashed_messages()`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.get_flashed_messages "flask.get_flashed_messages"). Полный пример приведён в разделе [Всплывающие сообщения](https://flask-russian-docs.readthedocs.io/ru/0.10.1/patterns/flashing.html#message-flashing-pattern).

## Ведение журналов

Иногда может возникнуть ситуация, в которой вы имеете дело с данными, которые должны быть корректными, но в действительности это не так. К примеру, у вас может быть некий код клиентской стороны, который посылает HTTP-запрос к серверу, однако он очевидным образом неверен. Это может произойти из-за манипуляции пользователя с данными, или из-за неудачной работы клиентского кода. В большинстве случаев ответом, адекватным ситуации будет `400 Bad Request`, но иногда, когда надо, чтобы код продолжал работать, это не годится.

Вы по-прежнему хотите иметь журнал того, что пошло не так. Вот где могут пригодиться объекты создания журнала logger. Начиная с Flask 0.3, инструмент для журналирования уже настроен для использования.

Вот некоторые примеры вызовов функции журналирования:

```python
app.logger.debug('Значение для отладки')
app.logger.warning('Предупреждение: (%d яблок)', 42)
app.logger.error('Ошибка')
```

Прилагаемый [`logger`](https://flask-russian-docs.readthedocs.io/ru/0.10.1/api.html#flask.Flask.logger "flask.Flask.logger") это стандартный класс журналирования [`Logger`](https://docs.python.org/dev/library/logging.html#logging.Logger "(в Python v3.8)"), так что за подробностями вы можете обратиться к официальной [документации по журналированию](https://docs.python.org/library/logging.html).