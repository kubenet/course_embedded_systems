Команды bash являются неотъемлемой частью разработки. Командная строка, не только bash, но и другие, дает **бОльшие** возможности по сравнению с любым графическим интерфейсом. Любой интерфейс полагается на эти команды и вызывает их с соответствующими параметрами. 

---
## Мотивация

1. Относитесь к `bash` как универсальному скриптовому языку, который покажет одинаковое поведение на разных системах **Linux**. С помощью bash и различных утилит мы можем получать доступ к "железу" машины, на которой работаем, и настраивать автоматические сценарии. Это можно осуществить и с использованием языков программирования, но сделать это будет сложнее, и реализация будет зависеть от конкретного языка программирования. Но если мы напишем `bash`, то "дернуть" его из любого языка программирования не составит труда, так как большинство из них поддерживает системные вызовы. Если же вызов системных функций невозможен или неудобен, обмен информацией всегда доступен через файлы, куда можно записать информацию из `bash`-скрипта, а прочитать из `python`.


2. При работе на своей компьютере вы можете не оценить все достоинства командной строки, однако она точно понадобится, чтобы настроить работу вашего приложения на удаленном сервере, физическом или виртуальном, к которому вы будете подключаться по ssh и на котором может быть в принципе не установлен оконный интерфейс. 

## ПОЧЕМУ LINUX ПОПУЛЯРЕН?
Подавляющее большинство пользователей Linux — разработчики, инженеры, учёные и другого рода профессионалы. Они выбирают эту систему, поскольку:
- под Linux написаны тысячи специализированных программ;
- при правильной настройке она быстрее, стабильнее и безопаснее, чем Windows и Mac OS;
- в ней предусмотрен удобный механизм обновления — можно обновить только необходимые компоненты; можно полностью настроить систему под свои вкусы.
## 0

```
command -settings/flags argv
```

Ниже будут описаны команды, которые помогут ходить по файловой системе, создавать, копировать и перемещать файлы, изменять разрешения для файлов, передавать владельца у файла, просматривать запущенные процессы и открытые порты.
Предположим, у нас есть пользователь с именем **user**, на машине, которая называется **pc**. Тогда при запуске командной строки мы увидим предложение ввода команды:

```bash
user@pc:/$ 
```

Мы видим, что здесь указаны имя пользователя и имя компьютера через символ `@`. Далее после двоеточия (`:`) указан текущий путь, сейчас мы находимся в корневой директории, далее символ `$` для отделения команды. Начнем изучение командной строки с команды, которая позволяет ходить по файловой системе. 

**Hint: при нажатии на стрелку вверх в командную строку будет подставлена предыдущая команда. Стрелку можно нажимать несколько раз**

**Hint: Дополнительные информацию и опции по каждой команде можно увидеть вызвав** `man command` **или** `command --help`, `man` **сокращенно от manual**

Мы надеемся, что это было достаточно убедительно, чтобы не пройти мимо темы `bash`. 

## cd - change directory

Команда для смены директории. При вызове происходит переход в директорию, которая указана после команды `cd /path/to/destination`. Предположим, у нас есть пользователь с именем **user**. Следующие команды можно выполнить, чтобы перейти сначала в директорию `home`, а затем в домашнюю директорию пользователя `/home/user`:
```bash
user@pc:/$ cd /home
user@pc:/home$ cd ./user
user@pc:~$
```
Заметьте, что во втором случае мы использовали `./` для перехода по относительному пути. Также видно, что меняется текущий путь, в котором мы находимся: в первой строке это была корневая директория (`/`), во второй — директория, в которой содержатся все домашние директории всех пользователей данной системы (`/home`). В третьей строке вместо пути мы видим символ `~`, который является сокращением для домашней папки конкретного пользователя. Две команды выше эквиваленты одной команде с указанием абсолютного пути:

```bash
user@pc:/$ cd /home/user
```

Команда `cd /user` вызовет ошибку, так как будет происходить поиск в корневой директории, а в ней **НЕ** содержится директории `user`. 
При использовании `cd` можно использовать сокращения, которые позволяют переходить по определенным путям, не прописывая полный путь (в примерах ниже `#` означает начало комментария): 

```bash
    cd ~        # переход в домашнюю папку
    cd ../      # переход на один уровень выше
    cd ../../   # переход на два уровня выше, чтобы уйти еще выше, можно добавлять ../
    cd -        # возврат в предыдущую директорию
    cd .        # текущий каталог
```

При использовании команды `cd` необязательно помнить полное наименование директории. Можно начать писать путь и затем нажать на TAB для автодополнения. 

```bash
user@pc:/$ cd /usr/loc     # нажимаем TAB
user@pc:/$ cd /usr/local/
```
Если написанного пользователем будет недостаточно для того, чтобы однозначно определить путь, командная строка выдаст все возможные варианты:
```bash
user#pc: cd /usr/l     # нажимаем TAB
lib/    libexec/    local/
user#pc: cd /usr/l
```

Вопросы для проверки: 

*Что можно указать после команды cd?*  

* Абсолютный путь (верно) 
* Относительный путь (верно)
* Адрес веб-сайта (НЕверно)
* Один из специальных наборов символов, например, `../` (верно)

## ls - list 

Для просмотра содержимого директории можно использовать **ls**. При вызове без параметров будет показано содержимое *текущей директории*. Также можно указать путь `ls /path/to/dir`, в этом случае будет показано содержимое *указанной директории*.
```terminal
root@de30378728be:/# ls
bin   etc   lib32   media  proc  sbin  tmp
boot  home  lib64   mnt    root  srv   usr
dev   lib   libx32  opt    run   sys   var
```

Мы видим, что разные имена подкрашены по-разному, на картинке выше три вида разметки. В вашей командой строке цвета могут отличаться. На картинке синий обозначает директорию, черный — обычный файл и зеленый — исполняемый файл. Но как понять это без цветовой индикации? Для этого вызовите `ls -l`:
```bash
root@de30378728be:/# ls -la
total 56
drwxr-xr-x   1 root root 4096 Sep 22 07:33 .
drwxr-xr-x   1 root root 4096 Sep 22 07:33 ..
-rwxr-xr-x   1 root root    0 Sep 22 07:33 .dockerenv
lrwxrwxrwx   1 root root    7 Aug 16 02:02 bin -> usr/bin
drwxr-xr-x   2 root root 4096 Apr 18  2022 boot
drwxr-xr-x   5 root root  360 Sep 22 07:33 dev
drwxr-xr-x   1 root root 4096 Sep 22 07:33 etc
drwxr-xr-x   2 root root 4096 Apr 18  2022 home
lrwxrwxrwx   1 root root    7 Aug 16 02:02 lib -> usr/lib
lrwxrwxrwx   1 root root    9 Aug 16 02:02 lib32 -> usr/lib32
lrwxrwxrwx   1 root root    9 Aug 16 02:02 lib64 -> usr/lib64
lrwxrwxrwx   1 root root   10 Aug 16 02:02 libx32 -> usr/libx32
drwxr-xr-x   2 root root 4096 Aug 16 02:03 media
drwxr-xr-x   2 root root 4096 Aug 16 02:03 mnt
drwxr-xr-x   2 root root 4096 Aug 16 02:03 opt
dr-xr-xr-x 604 root root    0 Sep 22 07:33 proc
drwx------   2 root root 4096 Aug 16 02:06 root
drwxr-xr-x   5 root root 4096 Aug 16 02:06 run
lrwxrwxrwx   1 root root    8 Aug 16 02:02 sbin -> usr/sbin
drwxr-xr-x   2 root root 4096 Aug 16 02:03 srv
dr-xr-xr-x  13 root root    0 Sep 22 07:33 sys
drwxrwxrwt   2 root root 4096 Aug 16 02:06 tmp
drwxr-xr-x  14 root root 4096 Aug 16 02:03 usr
drwxr-xr-x  11 root root 4096 Aug 16 02:06 var
```

Теперь мы видим больше информации по каждому файлу и директории в `/`. Среди этой информации: разрешение, владелец, группа, размер, дата последнего изменения, имя файла. Как видите, директория имеет букву `d` в разрешениях, а исполняемый файл, в отличие от неисполняемого, имеет атрибут `x`. 

Для просмотра скрытых файлов нужно указать параметр `a`. К скрытым файлам относятся директории, которые создаются при инициализации репозитория git.

```bash
root@de30378728be:/# ls -a
.           boot  lib     media  root  sys
..          dev   lib32   mnt    run   tmp
.dockerenv  etc   lib64   opt    sbin  usr
bin         home  libx32  proc   srv   var
```

## clear 

Командой **clear** можно очистить терминал от вывода. При этом история команд останется, и их по-прежнему можно доставать, нажимая на стрелку вверх. 

```bash
root@de30378728be:/# ls -a
.           boot  lib     media  root  sys
..          dev   lib32   mnt    run   tmp
.dockerenv  etc   lib64   opt    sbin  usr
bin         home  libx32  proc   srv   var
root@de30378728be:/# clear
```

При использовании clear мы увидим пустой терминал:
```bash
root@de30378728be:/#




```

## mkdir - make directory

Для создания директорий мы используем команду **mkdir**. Так же, как в случае с **cd** и **ls**, мы можем использовать относительный путь. Если директория уже существует, будет выдано сообщение об ошибке.
```bash
root@de30378728be:/# mkdir user
root@de30378728be:/# ls
bin   home   libx32  proc  srv   usr
boot  lib    media   root  sys   var
dev   lib32  mnt     run   user
etc   lib64  opt     sbin  tmp
root@de30378728be:/# cd user/
root@de30378728be:/user# ls -a
.  ..
root@de30378728be:/user#
```

## touch

Представьте ситуацию: нужно узнать время, когда последний раз запускалось то или иное приложение, которое запускается в фоне. Существует множество способов это сделать: запись в базе данных, анализ логов и так далее. Самой простой способ для bash-скрипта — изменение времени последнего изменения какого-либо файла. Это можно сделать, записав что-то в файл. Если такой вариант не подходит, воспользуйтесь командой `touch`, которая как раз предназначена для изменения времени обращения к файлу на текущее, при этом открытие файла не происходит. 

```bash
root@de30378728be:/user# touch .req.txt
root@de30378728be:/user# ls -l
total 0
root@de30378728be:/user# ls -l .req.txt
-rw-r--r-- 1 root root 0 Sep 22 07:54 .req.txt
root@de30378728be:/user# touch .req.txt
root@de30378728be:/user# ls -l .req.txt
-rw-r--r-- 1 root root 0 Sep 22 07:55 .req.txt
```

Если файл не существует, он будет создан пустым, если не указан аргумент `-с`.
```bash
root@de30378728be:/user# touch .req.txt
root@de30378728be:/user# ls -l
total 0
root@de30378728be:/user# ls -l .req.txt
-rw-r--r-- 1 root root 0 Sep 22 07:54 .req.txt
root@de30378728be:/user# touch .req.txt
root@de30378728be:/user# ls -l .req.txt
-rw-r--r-- 1 root root 0 Sep 22 07:55 .req.txt
root@de30378728be:/user# touch -c text.txt
root@de30378728be:/user# ls
root@de30378728be:/user# ls -a
.  ..  .req.txt
root@de30378728be:/user#
```

## cat - concatenate

Читает содержимое файлов и выводит его. Добавим в project директорию `data` и два файла `items_part1.txt` и `items_part2.txt`.

```bash
root@de30378728be:/user# echo "Hello" > text.txt
root@de30378728be:/user# echo "World" > text1.txt
root@de30378728be:/user# ls -la
total 16
drwxr-xr-x 2 root root 4096 Sep 22 07:56 .
drwxr-xr-x 1 root root 4096 Sep 22 07:53 ..
-rw-r--r-- 1 root root    6 Sep 22 07:56 text.txt
-rw-r--r-- 1 root root    6 Sep 22 07:56 text1.txt
root@de30378728be:/user# cat .
./  ../
root@de30378728be:/user# cat text
text.txt   text1.txt
root@de30378728be:/user# cat text.txt
Hello
root@de30378728be:/user# cat text1.txt
World
```

Можно использовать `cat` для склеивания содержимого нескольких файлов: укажите несколько файлов после cat, затем `>>` и имя файла, в который нужно слить данные. Символы `>>` означают перенаправление потока, т.е. мы делаем вывод не в стандартный поток, а, например, в файл.
```bash
root@de30378728be:/user# cat text.txt text1.txt >> text2.txt
root@de30378728be:/user# cat text2.txt
Hello
World
```

С помощью cat можно пронумеровать строки в файлах сквозной нумерацией.
```bash
root@de30378728be:/user# cat -n text.txt text1.txt
     1	Hello
     2	World
```

**Hint: посмотрите также команды `head` и `tail`, они выводят начало и конец файлов. `tail` будет удобен для просмотра журнала логов.**

**Hint: `>>` и `>` перенаправляют поток и создают файл, если его нет. Отличие состоит в том, что `>>` добавляет новое содержимое в конец файла, а `>` перезаписывает файл, удаляя предыдущее содержимое этого файла.**

## echo

Обычно используется в скриптах для вывода информации (как `print` в `python`). Также с помощью **echo** можно записать строку в файл, если файла не было, он будет создан.

```bash
root@de30378728be:/user# echo "Hello world" >> text2.txt
root@de30378728be:/user# cat text2.txt
Hello
World
Hello world
root@de30378728be:/user#
```

## export

Используется для установки переменных среды. Команда `export` отмечает переменную окружения для экспорта с любым новым дочерним процессом, и это позволяет дочернему процессу наследовать все отмеченные переменные. Они нам понадобятся для того, чтобы использовать ту информацию, которую мы не хотим прописывать в коде приложения, например, параметры доступа. Хардкодить такие значения неудобно, так как можно случайно закоммитить их, и придется все менять. Например, так сделано в проекте по созданию [чат-бота](https://github.com/gcatanese/SampleTelegramQuiz), посмотрите секцию **Setup** в README. Ниже приведен пример использования `export`.

```bash
root@de30378728be:/user# echo $INFO

root@de30378728be:/user# export INFO=42
root@de30378728be:/user# echo INFO
INFO
root@de30378728be:/user# echo $INFO
42
```
Подробнее с вариантами использования `export` можно ознакомиться [здесь](https://www.digitalocean.com/community/tutorials/export-command-linux). 

## $ 

Есть несколько конструкций, в которые входит `$`. Это может путать, но если относиться к этим конструкциям, как к обособленными элементам `bash`, так их легче воспринимать.

Символ `$` ставится перед переменной для того, чтобы получить ее значение. По умолчанию любое имя считается строкой.
```bash
root@de30378728be:/user# name=Jonh
root@de30378728be:/user# echo name
name
root@de30378728be:/user# echo $name
Jonh
root@de30378728be:/user# echo "Hello, $name"
Hello, Jonh
root@de30378728be:/user# echo "Hello, name"
Hello, name
```

При этом использование `$` внутри двойных кавычек и без них может вызвать разное поведение, если в значении переменной содержатся специальные символы. Если `$` используется в двойных кавычках, то значение переменной будет выдено как есть. Если `$` используется без кавычек, то `bash` проведет интерпретацию специальных символов, например, как ниже с `*`, которую мы использовали для поиска файлов по шаблону.

Другое использование `$` — запись вывода команды в переменную. В этом случае `$` используется совместно со скобками.
```
root@de30378728be:/user# echo "some text" > text.txt
root@de30378728be:/user# content=$(cat text.txt)root@de30378728be:/user# echo $content
some text
root@de30378728be:/user#
```

В `bash` нельзя просто так взять и выполнить математическую операцию. Для этого используется `$` совместно с двойными скобками.

```bash
root@de30378728be:/user# result=1+2
root@de30378728be:/user# echo $result
1+2
root@de30378728be:/user# result=$(1+2)
bash: 1+2: command not found
root@de30378728be:/user# result=$((1+2))
root@de30378728be:/user# echo $result
3
root@de30378728be:/user#
```

Также `$` используется для получения значений аргументов, переданных в скрипт. Можно считать, что сама оболочка присваивает номера переменным вместо того, чтобы именовать их. Это похоже на то, как мы используем `sys.argv[N]` в `python`, когда хотим получить то, что передано при вызове нашей программы. 
```bash
root@de30378728be:/user# echo "echo \"First is \$1 and second is \$2\"" > script.bash

root@de30378728be:/user# cat script.bash
echo "First is $1 and second is $2"
root@de30378728be:/user# chmod +x script.bash
root@de30378728be:/user# ./script.bash John Doel
First is John and second is Doel
root@de30378728be:/user#
```

Первая команда на скриншоте выше используется для того, чтобы создать код скрипта. Вы также можете взять код из двойных кавычек `echo "First is $1 and second is $2"` и сохранить его в файл `script.bash`, используя любой текстовый редактор. Описание `chmod` смотрите ниже.

Есть еще один вариант использования `$`, но на этот раз с фигурными скобками. Это назвается parameter expansion и позволяет произвести операции над значениями переменной и передать результат дальше. Ниже пример со строкой `name=userVesnin` и срезами, а также со списком `name=(user Vesnin)` и обращением к элементам списка.
```bash
root@de30378728be:/user# name=(user Doel)
root@de30378728be:/user# echo ${name[1]}
Doel
root@de30378728be:/user# echo ${name[0]}
user
```
Также существует специальная переменная `$?`, куда записывается статус выполнения последней команды.

```bash
ls non_existent_file.txt
if user $? -ne 0 ; then
  echo "Error: File not found or other issue occurred."
fi
```
```bash
root@de30378728be:/user# ls non_ext_file.txt
ls: cannot access 'non_ext_file.txt': No such file or directory
root@de30378728be:/user# user $? -eq 0 && echo "File ext"
root@de30378728be:/user# touch file_ext.txt
root@de30378728be:/user# ls file_ext.txt
file_ext.txt
root@de30378728be:/user# user $? -eq 0 && echo "File ext"
File ext
root@de30378728be:/user#
```
![command_output_status](/graphics/command_output_status.png)

Здесь мы использовали `user` для проведения операций сравнения. `-eq` сокращенно от equal. 

## rm — remove

Для удаления файлов используется команда **rm**. Удалить можно один файл, указав путь до него, или несколько, указав ту часть пути, которая может меняться через `*`, т.е. задав шаблон, в который должны вписаться пути.
```bash
root@de30378728be:/user# ls
file_ext.txt  text.txt   text2.txt
script.bash   text1.txt
root@de30378728be:/user# rm script.bash
root@de30378728be:/user# ls
file_ext.txt  text.txt  text1.txt  text2.txt
root@de30378728be:/user# rm text*
root@de30378728be:/user# ls
file_ext.txt
root@de30378728be:/user#
```

Удаление каталогов требует дополнительных опций, так как удаляются не отдельные файлы, а все содержимое каталога, поэтому нужно делать это рекурсивно, заходя во все вложенные каталоги.
```bash
root@de30378728be:/user# mkdir dir
root@de30378728be:/user# ls
dir  file_ext.txt
root@de30378728be:/user# rm dir/
rm: cannot remove 'dir/': Is a directory
root@de30378728be:/user# rm -r dir/
root@de30378728be:/user# ls
file_ext.txt
root@de30378728be:/user#
```

## rmdir — remove directory

Удаление пустых директорий или группы вложенных пустых директорий. 
```bash
root@de30378728be:/user# ls
file_ext.txt
root@de30378728be:/user# mkdir a
root@de30378728be:/user# mkdir -p a/{a..z}
root@de30378728be:/user# tree a/
a/
|-- a
|-- b
|-- c
|-- d
|-- e
|-- f
|-- g
|-- h
|-- i
|-- j
|-- k
|-- l
|-- m
|-- n
|-- o
|-- p
|-- q
|-- r
|-- s
|-- t
|-- u
|-- v
|-- w
|-- x
|-- y
`-- z

26 directories, 0 files
root@de30378728be:/user# rmdir a/
a/ c/ e/ g/ i/ k/ m/ o/ q/ s/ u/ w/ y/
b/ d/ f/ h/ j/ l/ n/ p/ r/ t/ v/ x/ z/
root@de30378728be:/user# rmdir a/a/
root@de30378728be:/user# tree a/
a/
|-- b
|-- c
|-- d
|-- e
|-- f
|-- g
|-- h
|-- i
|-- j
|-- k
|-- l
|-- m
|-- n
|-- o
|-- p
|-- q
|-- r
|-- s
|-- t
|-- u
|-- v
|-- w
|-- x
|-- y
`-- z

25 directories, 0 files
root@de30378728be:/user# rmdir -rf a/
rmdir: invalid option -- 'r'
Try 'rmdir --help' for more information.
root@de30378728be:/user# rmdir -p a/
rmdir: failed to remove 'a/': Directory not empty
root@de30378728be:/user# rm -rf a/
b/ d/ f/ h/ j/ l/ n/ p/ r/ t/ v/ x/ z/
c/ e/ g/ i/ k/ m/ o/ q/ s/ u/ w/ y/
root@de30378728be:/user# rm -rf a/
root@de30378728be:/user# tree a
a  [error opening dir]

0 directories, 0 files
root@de30378728be:/user#
```

Обратите внимание на сообщение об ошибке (вообще всегда смотрите на результат ваших действий, чтобы понимать, выполнилась ли команда). Часть работы была сделана: удалены директории `./a/b` и `./a`. А самый верхний уровень этого пути (`.`) — это, как мы помним, текущая директория, т.е. `~/project/data`, и rmdir сам не дает пользователю удалить директорию, в которой он находится. Правильным будет `mkdir -p a/b`, хотя в большинстве случаев ./a/b и a/b равнозначны.

## cp — copy

Копирует один или несколько файлов из одного места в другое. Так же, как и в случае с `rm`, можно указывать шаблон, которому должны соответствовать пути. 
```bash
root@de30378728be:/user# mkdir a
root@de30378728be:/user# mkdir b
root@de30378728be:/user# touch a/a.txt a/b.txt a/c.txt
root@de30378728be:/user# ls a
a.txt  b.txt  c.txt
root@de30378728be:/user# cp a/*.txt b/
root@de30378728be:/user# ls a
a.txt  b.txt  c.txt
root@de30378728be:/user# ls b
a.txt  b.txt  c.txt
root@de30378728be:/user#
```

## mv — move

Перемещает один или несколько файлов из одного места в другое. Так же, как и в случае с `rm`, можно указывать шаблон, которому должны соответствовать пути. 

```bash
root@de30378728be:/user# ls a/
a.txt  b.txt  c.txt
root@de30378728be:/user# mkdir c
root@de30378728be:/user# mv a/*.txt c
root@de30378728be:/user# ls a
root@de30378728be:/user# ls c
a.txt  b.txt  c.txt
```

`mv` можно использовать для переименования файлов.

```bash
root@de30378728be:/user# ls
a  b  c  file_ext.txt
root@de30378728be:/user# mv file_ext.txt file_change.txt
root@de30378728be:/user# ls
a  b  c  file_change.txt
root@de30378728be:/user#
```
## chmod — change mode

Изменяет разрешения файлов и директорий. Помните, на рисунке, который уже был выше, `script.bash` подсвечивался зеленым? Это означало, что у него есть разрешение на исполнение. Давайте удалим его. Создадим скрипт заново и запишем туда строку `ls -l` с помощью `echo`, попробуем выполнить, получим ошибку, потом попробуем дать разрешение на исполнение и выполним еще раз.
```bash
root@de30378728be:/user# touch script.sh
root@de30378728be:/user# echo "ls -a" >> script.sh
root@de30378728be:/user# ./scrpit.sh
bash: ./scrpit.sh: No such file or directory
root@de30378728be:/user# ls
script.bash  script.sh  typescript
root@de30378728be:/user# ./script.sh
bash: ./script.sh: Permission denied
root@de30378728be:/user# ls -l script.sh
-rw-r--r-- 1 root root 6 Sep 22 08:18 script.sh
root@de30378728be:/user# chmod +x script.sh
root@de30378728be:/user# ./script.sh
.  ..  script.bash  script.sh  typescript
root@de30378728be:/user# ls -l script.sh
-rwxr-xr-x 1 root root 6 Sep 22 08:18 script.sh
```

Разрешения делятся на три категории:
- **`r`** *(read)* — чтение; 
- **`w`** *(write)* — запись; 
- **`x`** *(execute)* — исполнение. 

А также на три уровня: 
1. Владелец файла или директории.
2. Группа пользователей, к которой принадлежит владелец.
3. Все остальные. 

К примеру, права доступа `[drwxrwxrwx]` дают полный доступ на чтение, редактирование и запуск абсолютно всем пользователям. Рассмотрим этот случай подробнее. Ключи доступа из примера можно поделить на 4 секции: 1 — `[d]`, 2 — `[rwx]`, 3 — `[rwx]`, 4 — `[rwx]`.

1 секция может быть либо «d» — директория, либо «-» — файл.
2 секция показывает права доступа владельца файла или директории (r — чтение, w — запись, x — выполнение).
3 секция показывает права доступа группы, в которой находится владелец, rwx — аналогично.
4 секция показывает права доступа всех остальных пользователей системы.

Например, `-rwxr-xr--` означает, что владелец может читать, писать и исполнять файл, пользователи из группы — только читать и исполнять, все остальные — только читать. Можно вообще не давать разрешений, например, `-rwxr-x---` запретит доступ к файлу всем пользователям, кроме его владельца (того, кто создал этот файл) и участникам группы, к которой он относится.

> Все группы, созданные в системе, находятся в файле /etc/group. Посмотрев содержимое этого файла, вы увидите список групп linux, которые уже есть в вашей системе. Этот список может быть большим и малоинформативным для рядового пользователя. Чтобы вывести список всех групп, членом которых является текущий пользователь, можно использовать команду `groups`.

## sudo — superuser do

В большинстве случае для выполнения команд описанных, выше достаточно обычных прав, которые имеются у пользователя. Но в ряде случаев, при использовании системных утилит или смене владельца у файла (см. `chown` ниже), необходимо использовать права суперпользователя. Первый способ — авторизоваться, используя аккаунт суперпользователя в системе. Но такой сценарий не является предпочтительным, так может привести к случайному выполнению команды, которая может нанести вред системе. Более широкое применение получил способ, при котором для выполнения команды с правами суперпользователя перед командой добавляется **`sudo`**. Ниже представлен пример передачи владения скрипта пользователю root, после этого мы сможем выполнять скрипт только от имени нового владельца, т.е. `root` (для текущих разрешений скрипта `-rwxrwxr--`).

## chown — change owner

Изменяет владельца файла или директории. При этом, если вы хотите сделать это рекурсивно, для всех файлов внутри директории, нужно указать специальный флаг `-R` для рекурсивной работы. При использовании мы указываем имя пользователя и группу через двоеточие `username:group`. Каждый пользователь может состоять в одной или нескольких группах. Можно менять владельца и не менять группу. В примере ниже мы вернули владение группе `user`, и теперь можем запускать файл от обычного пользователя (для текущих разрешений скрипта `-rwxrwxr--`).

## history 

Выводит историю выполненных команд.

```bash
  136  ./script.sh
  137  ls -a script.sh
  138  ls -l script.sh
  139  chmod +x script.sh
  140  ./script.sh
  141  ls -l script.sh
  142  sudo chown root:user script.sh
  143  chown root:user script.sh
  144  history
root@de30378728be:/user#
```

## grep — global regular expression print

Производит поиск в тексте строки, содержащей определенную подстроку. При этом текст можно получить прямо из стандартного вывода или из файла. Бывает полезным, чтобы вспомнить, как выполнялась та или иная команда в `bash`. 
```bash
root@de30378728be:/user# history | grep "ls"
    1  ls
    2  ls -la
    4  ls -a
    6  ls -a
    9  ls
   11  ls -a
   14  ls -la .req.txt
   16  ls -la
   18  ls -la
   20  ls -l
   21  ls -l .req.txt
   23  ls -l .req.txt
   25  ls
   26  ls -a
   30  ls -la
   71  ls non_ext_file.txt
   74  ls file_ext.txt
   76  ls
   78  ls
   80  ls
   82  ls
   85  ls
   99  ls
  100  ls -la
  101  ls
  114  ls a
  116  ls a
  117  ls b
  118  ls a/
  121  ls a
  122  ls c
  123  ls
  125  ls
  129  echo "ls -a" >> script.bash
  130  ls
  133  echo "ls -a" >> script.sh
  135  ls
  137  ls -a script.sh
  138  ls -l script.sh
  141  ls -l script.sh
```


Также можно облегчить себе поиск документации по `man`, если примерно помнить термин.

```bash
man ls | grep -
 ls - list directory contents
       entries  alphabetically if none of -cf‐
       tuvSUX nor --sort is specified.
       -a, --all
       -A, --almost-all
       --author
              with -l,  print  the  author  of
       -b, --escape
              print  C-style  escapes for non‐
       --block-size=SIZE
              with -l,  scale  sizes  by  SIZE
              '--block-size=M'; see SIZE  for‐
```

Или найти что-нибудь в документе, который вы читаете:


**Hint: `|` перенаправляет выходной поток от одной команды к входу другой. Можно использовать, чтобы миновать запись в файл на диске.**

## top — table of process

Выводит активные процессы, а также информацию по загрузке процессора и памяти. Информация будет обновляться в терминале. Чтобы выйти из этого режима, нажмите `Ctrl-C`. 
```
top - 08:25:04 up  2:48,  0 users,  load average
Tasks:   2 total,   1 running,   1 sleeping,   0
%Cpu(s):  0.9 us,  2.3 sy,  0.0 ni, 96.7 id,  0.
MiB Mem : 128642.9 total, 119383.9 free,   4106.
MiB Swap:   2048.0 total,   2048.0 free,      0.

    PID USER      PR  NI    VIRT    RES    SHR
      1 root      20   0    4624   3584   3072
    465 root      20   0    7332   3328   2816
```


**Hint: `htop` дополняет функциональность `top`. Поставьте `htop` через менеджер пакетов, который используется в вашем дистрибутиве (`sudo apt install htop` в Ubuntu).**

## Работа в оболочке

Запустите команду несколько раз:

```bash
for i in $(seq 1 5); do echo hello; done
```


Есть что распаковать:

  - `for` x в списке; делать ТЕЛО; готово
    - `;` завершает команду – эквивалент новой строки
    - разделить `list`, присвоить каждому `x` и запустить тело
    - разделение — это «разделение пробелов», к которому мы еще вернемся.
    - в оболочке нет фигурных скобок, поэтому `do` + `done`
  - `$(seq 1 5)`
    - запустить программу `seq` с аргументами `1` и `5`
    - заменить всю `$()` выводом этой программы
    - эквивалентно
     ```bash
     for i in 1 2 3 4 5
     ```
- `echo hello `
    - все в сценарии оболочки является командой
    — в этом случае запустите команду `echo`, которая выведет свои аргументы
      с аргументом «hello».
    - все команды ищутся в `$PATH` (через двоеточие)

У нас есть переменные:
```bash
for f in $(ls); do echo $f; done
```

Будет печатать каждое имя файла в текущем каталоге.
Также можно устанавливать переменные, используя `=` (без пробела!):

```bash
foo=bar
echo $foo
```

Также есть несколько «специальных» переменных:

 - `$1` to `$9`: arguments to the script
 - `$0` name of the script itself
 - `$#` number of arguments
 - `$$` process ID of current shell

Чтобы печатать только каталоги

```bash
for f in $(ls); do if user -d $f; then echo dir $f; fi; done
```

  - `if CONDITION; then BODY; fi`
    - `CONDITION` — команда; если он возвращается со статусом выхода 0
      (успех), затем запускается `BODY`.
    - также можно подключить `else` или `elif`.
    - опять же, никаких фигурных скобок, поэтому `then` + `fi`
  - `user` — еще одна программа, обеспечивающая различные проверки и
    сравнения и завершаются с 0, если они истинны (`$?`)
    - `man COMMAND` ваш друг: `man user`
    - также можно вызвать с помощью `[` + `]`: `[ -d $f ]`
      - взгляните на `man user` и `который "["`


Но подождите! Это не верно! Что делать, если файл называется «My Documents»?

  - `for f in $(ls)` расширяется до `for f in My Documents`
  - сначала сделайте тест на «Моих», затем на «Документах»
  - не то, что мы хотели!
  - самый большой источник ошибок в сценариях оболочки

## Разделение аргументов

Bash разделяет аргументы по пробелам;не всегда то, что вы хотите!

  - необходимо использовать кавычки для обработки пробелов в аргументах
    `for f в "Моих документах"` будет работать правильно
    `user -d $f`: если `$f` содержит пробелы, `user` выдаст ошибку!
  - с `echo` всё в порядке, потому что разделение + объединение по пробелу
    но что, если имя файла содержит новую строку?! превращается в космос!
  - укажите все использование переменных, которые вы не хотите разделять
  — а как нам исправить наш скрипт выше?
    как вы думаете, что означает `for f в "$(ls)"`?

Глоббинг – вот ответ!

  — bash умеет искать файлы по шаблонам:
    - `*` любая строка символов
    - `?` любой одиночный символ
    - `{a,b,c}` любой из этих символов
  - `for f in *`: все файлы в этом каталоге
  - при подстановке каждый соответствующий файл становится отдельным аргументом
    - все равно нужно обязательно ставить кавычки при использовании_: `user -d "$f"`
  - можно создавать сложные выкройки:
    - `for f in a*`: все файлы, начинающиеся с `a`, в текущем каталоге.
    - `for f in foo/*.txt`: все файлы `.txt` в `foo`
    - `для f в foo/*/p??.txt`
      все трехбуквенные текстовые файлы, начинающиеся с p в подкаталогах `foo`

Проблемы с пробелами на этом не заканчиваются:

  - `if [ $foo = "бар"]; then` -- видите проблему?
  — что, если `$foo` пуст? аргументами `[` являются `=` и `bar`...
  - _можно_ обойти это с помощью `[ x$foo = "xbar" ]`, но блин
  - вместо этого используйте `[[`: встроенный компаратор bash, который имеет специальный синтаксический анализ
    - также позволяет использовать `&&` вместо `-a`, `||` поверх `-o` и т. д.

## Возможность компоновки
Shell является мощным инструментом отчасти благодаря возможности компоновки. Можно объединить несколько
программы вместе, а не иметь одну программу, которая делает все.

Ключевой символ — `|` (вертикальная черта).

  - `а | b` означает запуск как `a`, так и `b`
    отправить весь вывод `a` в качестве входных данных `b`
    распечатать вывод `b`

Все запускаемые вами программы («процессы») имеют три «потока»:

  - `STDIN`: когда программа читает ввод, он поступает отсюда.
  - `STDOUT`: когда программа что-то печатает, это отправляется сюда.
  - `STDERR`: второй выход, который программа может использовать.
  - по умолчанию `STDIN` – это ваша клавиатура, `STDOUT` и `STDERR` — оба
    ваш терминал. но ты можешь это изменить!
    - `а | b` создает `STDOUT` из `a` `STDIN` из `b`.
    - Также есть:
      - `a > foo` (`STDOUT` `a` переходит в файл `foo`)
      - `a 2> foo` (`STDERR` `a` переходит в файл `foo`)
      - `a < foo` (`STDIN` `a` считывается из файла `foo`)
      - подсказка: `tail -f` будет печатать файл по мере его записи
  - почему это полезно? позволяет вам манипулировать выводом программы!
    - `ls | grep foo`: все файлы, содержащие слово `foo`
    - `ps | grep foo`: все процессы, содержащие слово `foo`
    - `journalctl | grep -i intel | хвост -n5`:
      последние 5 сообщений системного журнала со словом Intel (без учета регистра)
    - `who | sendmail -t me@example.com`
      отправьте список вошедших пользователей на адрес `me@example.com`
    - формирует основу для большого количества споров с данными, о чем мы поговорим позже

Bash также предоставляет ряд других способов создания программ.

Вы можете группировать команды с помощью `(a; b) | tac`: запустите `a`, затем `b` и отправьте
весь их вывод в `tac`, который печатает входные данные в обратном порядке.

Менее известный, но очень полезный вариант — «подмена процесса».
`b <(a)` запустит `a`, сгенерирует временное имя файла для вывода
поток и передайте это имя файла в `b`. Например:

```bash
diff <(journalctl -b -1 | head -n20) <(journalctl -b -2 | head -n20)
```
покажет вам разницу между первыми 20 строками последней загрузки
log и тот, что был до этого.

<!-- TODO: exit codes? -->

## Контроль работ и процессов


Что, если вы хотите запускать долгосрочные задачи в фоновом режиме?

  - суффикс `&` запускает программу "в фоновом режиме"
    - он немедленно вернет вам подсказку
    - удобно, если вы хотите запустить две программы одновременно
      как сервер и клиент: `сервер и клиент`
    - обратите внимание, что запущенная программа по-прежнему использует ваш терминал как STDOUT!
      попробуйте: `server > server.log & client`
  - увидеть все такие процессы с помощью `заданий`
    - обратите внимание, что он показывает «Бег»
  - выведите его на передний план с помощью `fg %JOB` (ни один аргумент не является последним)
  - если вы хотите сделать фоном текущую программу: `^Z` + `bg` (здесь `^Z` означает нажатие `Ctrl+Z`)
    - `^Z` останавливает текущий процесс и превращает его в "задание"
    - `bg` запускает последнее задание в фоновом режиме (как если бы вы выполнили `&`)
  - фоновые задания по-прежнему привязаны к текущему сеансу и завершаются, если
    вы выходите из системы. `disown` позволяет разорвать это соединение. или используйте nohup.
  - `$!` — это pid последнего фонового процесса

<!-- TODO: управление выводом процесса (^S и ^Q)? -->

А как насчет других вещей, работающих на вашем компьютере?

  - `ps` ваш друг: список запущенных процессов
    - `ps -A`: печатать процессы от всех пользователей (также `ps ax`)
    - `ps` имеет *много* аргументов: см. `man ps`
  - `pgrep`: найти процессы с помощью поиска (например, `ps -A | grep`)
    - `pgrep -af`: поиск и отображение с аргументами
  - `kill`: отправить _сигнал_ процессу по идентификатору (`pkill` по поиску + `-f`)
    - сигналы говорят процессу «что-то сделать»
    - наиболее распространенный: `SIGKILL` (`-9` или `-KILL`): прикажите ему выйти *сейчас*
      эквивалент `^\`
    - также `SIGTERM` (`-15` или `-TERM`): сообщите ему о корректном выходе
      эквивалент `^C`


## Флаги

Большинство утилит командной строки принимают параметры с помощью **флагов**. Флаги обычно имеют короткую (`-h`) и длинную форму (`--help`). Обычно запуск `CMD -h` или `man CMD` дает вам список флагов, которые принимает программа.
Короткие флаги обычно можно комбинировать, запуск `rm -r -f` эквивалентен запуску `rm -rf` или `rm -fr`.
Некоторые общие флаги являются стандартом де-факто, и вы увидите их во многих приложениях:

* `-a` обычно относится ко всем файлам (т. е. включая те, которые начинаются с точки)
* `-f` обычно относится к принудительному выполнению чего-либо, например `rm -f`
* `-h` отображает справку по большинству команд
* `-v` обычно включает подробный вывод
* `-V` обычно печатает версию команды

Кроме того, двойное тире `--` используется во встроенных командах и многих других командах для обозначения конца опций команды, после чего принимаются только позиционные параметры. Итак, если у вас есть файл с именем «-v» (что вы можете) и вы хотите его выполнить с помощью grep, «шаблон grep ---v» будет работать, а шаблон «grep -v» — нет. Фактически, один из способов создать такой файл — это выполнить `touch -- -v`.

## Практические примеры

Ниже мы рассмотрим несколько примеров использования `bash` и еще раз повторим написанное в мотивации к этому уроку: рассматривайте `bash` как дополнительный инструмент, который может облегчить решение некоторых задач. Ради тренировки можно написать, например, калькулятор, но его легко сделать на вашем любимом языке программирования гораздо быстрее, поэтому ниже мы рассмотрим примеры, которые используют доступ к системным утилитам и позволяют нам получить информацию о подключенных устройствах и их состоянии.

### Мониторинг подключения usb-устройств

Ниже приведены примеры скрипта, отслеживающего подключение и отключение usb-устройства

```bash
#!/bin/bash

# Define the log file path
LOG_FILE="./usb-monitor.log"

# Get the initial list of connected USB devices
initial_devices=$(lsusb)

# Function to log the events
log_event() {
    local event_time="$(date +'%Y-%m-%d %H:%M:%S')"
    local event_type="$1"
    local device_id="$2"

    echo "$event_time | $event_type | $device_id" >> "$LOG_FILE"
}

# Function to check for new devices
check_devices() {
    while true 
    do
        current_devices=$(lsusb)
        echo "$initial_devices" | sort > "./idev.txt"
        echo "$current_devices" | sort > "./cdev.txt"
        new_devices=$(comm -13 "./idev.txt" "./cdev.txt")
        removed_devices=$(comm -13 "./cdev.txt" "./idev.txt")
        if user "$new_devices" != ""
        then
            for device in "$new_devices"; do
                log_event "connected" "$device"
            done
        fi
        if user "$removed_devices" != ""
        then
            for device in "$removed_devices"; do
                log_event "disconnected" "$device"
            done
        fi
        initial_devices=$current_devices
        sleep 1  # Adjust the update interval as needed
    done
}

# Start monitoring, just call check_devices()
check_devices
```


Мы видим ряд конструкций, которые доступны в обычном языке программирования, например, условные операторы, циклы, функции. Реализация их в `bash` имеет свои особенности, но понять их синтаксис несложно, если вы знаете хотя бы один язык программирования. Вызов функции также имеет особенности, например, мы передаем аргументы не в скобках, а после вызова функции. Особенности использования `$` мы рассмотрели выше. 

В скрипте мы используем новую команду `comm`, которая сравнивает два файла и выводит результат в три колонки, вторая из которых — строки, уникальные для второго файла (что находится в других колонках, можно посмотреть в документации `man comm`). Аргументы `-13` удаляют колонки 1 и 3, оставляя только вторую. Поэтому мы меняем файлы местами, чтобы определить `new_devices` и `removed_devices`. Функция `log_event()` записывает информацию о новых или отключенных устройствах в файл. Обратите внимание на вызов `check_devices` в конце скрипта. 

Мы проверяем устройства каждую секунду `sleep 1`, поэтому при быстром подключении и отключении можем потерять информацию о событии. Далее мы рассмотрим пример того, как этого избежать.

Также мы использовали команду `user`, которая производит сравнение аргументов с использовании логических операторов. Вы можете встреть `["$new_devices" != ""]` вместо `user "$new_devices" != ""`, это одно и то же. 

### Мониторинг подключения устройств с помощью dmesg

Выше мы рассмотрели скрипт для мониторинга usb-устройств с помощью `lsusb`. В Линукс есть команда для мониторинга всех сообщений, которые появляются в системе. Мы можем настроить шаблоны, которые позволят нам отфильтровать нужные нам сообщения. Ниже приведен пример, которые позволит отловить все сообщения, где встречается подстрока "usb". При этом, в отличие от скрипта с `lsusb`, мы лучше защищены от потери события, так как dmesg выводит сообщения из буфера, который хранит не только последнее сообщение, но и историю сообщений

```bash
#!/bin/bash
prev_records=$(dmesg | tail -20)
 
monitor_devices_records() {

    while true
    do
        curr_records=$(dmesg | tail -20)
        new_records=$(comm -13 <(echo "$prev_records") <(echo "$curr_records"))
        usb_records=$(echo "$new_records" | grep usb)
        if user "$usb_records" != ""
        then
            echo "$usb_records"
        fi
        prev_records=$curr_records
    done
}
# Start monitoring
monitor_devices_records
```

### Мониторинг оставшегося места на диске

Скрипт, приведенный ниже мониторит доступное на диске место и предупреждает, когда процент занятого места превышен. Конструкцию `${}` мы описывали выше. Из нового мы видим конструкцию `($df_record)`, которая позволяет создать список из значения переменной `df_record`, например, "one two three" → ("one", "two", "three")


```bash
#!/bin/bash
monitor_device=$1  #device to monitor eg. /dev/sdc1
alert_level=$2     #available percentage to alert eg. 1
 
monitor_space_usage() {

    while true
    do
        df_record=$(df | grep "$monitor_device")
        df_record_array=($df_record)
        avail=${df_record_array[3]}
        total=${df_record_array[1]}
        if user $(( 100 * $avail / $total)) -le $alert_level
        then
            echo "Alert disk is almost full"
        fi
        sleep 1
    done
}
monitor_space_usage
```
----

> Если вы новичок в оболочке, возможно, вам захочется прочитать более подробное руководство по ней, например [BashGuide](http://mywiki.wooledge.org/BashGuide). Если вы хотите получить более подробное представление, [Командная строка Linux](http://linuxcommand.org/tlcl.php) — хороший ресурс.

"Сценарии оболочки"

---
До сих пор мы видели, как выполнять команды в оболочке и соединять их по конвейеру.
Однако во многих сценариях вам потребуется выполнить ряд команд и использовать выражения потока управления, такие как условные выражения или циклы.

Сценарии оболочки — это следующий шаг в сложности.
Большинство оболочек имеют собственный язык сценариев с переменными, потоком управления и собственным синтаксисом.
Что отличает сценарии оболочки от других языков программирования сценариев, так это то, что они оптимизированы для выполнения задач, связанных с оболочкой.
Таким образом, создание командных конвейеров, сохранение результатов в файлы и чтение из стандартного ввода — это примитивы в сценариях оболочки, что упрощает их использование по сравнению с языками сценариев общего назначения.
В этом разделе мы сосредоточимся на сценариях bash, поскольку они наиболее распространены.

Чтобы назначить переменные в bash, используйте синтаксис `foo=bar` и получите доступ к значению переменной с помощью `$foo`.
Обратите внимание, что `foo = bar` не будет работать, поскольку он интерпретируется как вызов программы `foo` с аргументами `=` и `bar`.
Обычно в сценариях оболочки символ пробела выполняет разделение аргументов. Поначалу такое поведение может сбивать с толку, поэтому всегда проверяйте его.

Строки в bash могут определяться с помощью разделителей `'` и `"`, но они не эквивалентны.
Строки, разделенные `'`, являются литеральными строками и не заменяют значения переменных, тогда как строки с разделителями `"` заменяют.

```bash
foo=bar
echo "$foo"
# prints bar
echo '$foo'
# prints $foo
```

Как и большинство языков программирования, bash поддерживает методы управления потоками, включая `if`, `case`, `while` и `for`.
Аналогично, в bash есть функции, которые принимают аргументы и могут с ними работать. Вот пример функции, которая создает каталог и записывает в него компакт-диски.


```bash
mcd () {
    mkdir -p "$1"
    cd "$1"
}
```


Здесь `$1` — это первый аргумент скрипта/функции.
В отличие от других языков сценариев, bash использует множество специальных переменных для ссылки на аргументы, коды ошибок и другие соответствующие переменные. Ниже приведен список некоторых из них. Более полный список можно найти [здесь](https://tldp.org/LDP/abs/html/special-chars.html).
- `$0` - Имя скрипта
- от `$1` до `$9` — аргументы сценария. `$1` — первый аргумент и так далее.
- `$@` - Все аргументы
- `$#` - Количество аргументов
- `$?` - Код возврата предыдущей команды
- `$$` - Идентификатор процесса (PID) для текущего скрипта
- `!!` - Вся последняя команда, включая аргументы. Распространенным шаблоном является выполнение команды только для ее сбоя из-за отсутствия разрешений; вы можете быстро повторно выполнить команду с помощью sudo, выполнив `sudo !!`
- `$_` - Последний аргумент последней команды. Если вы находитесь в интерактивной оболочке, вы также можете быстро получить это значение, набрав «Esc», а затем «.» или «Alt+».

Команды часто возвращают выходные данные с использованием STDOUT, ошибки — через STDERR, а код возврата позволяет сообщать об ошибках более удобным для сценариев способом.
Код возврата или статус выхода — это способ, с помощью которого сценарии/команды сообщают о ходе выполнения.
Значение 0 обычно означает, что все прошло нормально; любое значение, отличное от 0, означает, что произошла ошибка.

Коды выхода можно использовать для условного выполнения команд с использованием `&&` (и оператора) и `||` (или оператора), оба из которых являются [коротким замыканием](https://en.wikipedia.org/wiki/Short-circuit_evaluation) операторы. Команды также можно разделять в одной строке точкой с запятой `;`.
Программа `true` всегда будет иметь код возврата 0, а команда `false` всегда будет иметь код возврата 1.
Давайте посмотрим несколько примеров

```bash
false || echo "Oops, fail"
# Oops, fail

true || echo "Will not be printed"
#

true && echo "Things went well"
# Things went well

false && echo "Will not be printed"
#

true ; echo "This will always run"
# This will always run

false ; echo "This will always run"
# This will always run
```

Другой распространенный шаблон — желание получить вывод команды в виде переменной. Это можно сделать с помощью _командной подстановки_.
Всякий раз, когда вы размещаете `$( CMD )`, он выполняет `CMD`, получает выходные данные команды и заменяет их на место.
Например, если вы выполните `for file in $(ls)`, оболочка сначала вызовет `ls`, а затем переберет эти значения.
Менее известная подобная функция — это _process substitution_, `<( CMD )` выполнит `CMD`, поместит выходные данные во временный файл и заменит `<()` именем этого файла. Это полезно, когда команды ожидают передачи значений по файлу, а не по STDIN. Например, `diff <(ls foo) <(ls bar)` покажет различия между файлами в каталогах `foo` и `bar`.

Поскольку это была огромная куча информации, давайте посмотрим на пример, демонстрирующий некоторые из этих функций. Он будет перебирать предоставленные нами аргументы, `grep` для строки `foobar`, и добавит ее в файл в качестве комментария, если она не найдена.

```bash
#!/bin/bash

echo "Starting program at $(date)" # Date will be substituted

echo "Running program $0 with $# arguments with pid $$"

for file in "$@"; do
    grep foobar "$file" > /dev/null 2> /dev/null
    # When pattern is not found, grep has exit status 1
    # We redirect STDOUT and STDERR to a null register since we do not care about them
    if [[ $? -ne 0 ]]; then
        echo "File $file does not have any foobar, adding one"
        echo "# foobar" >> "$file"
    fi
done
```


В ходе сравнения мы проверяли, не равен ли `$?` 0.
Bash реализует множество подобных сравнений — подробный список можно найти на странице руководства по [`test`](https://www.man7.org/linux/man-pages/man1/test.1.html).
При выполнении сравнений в bash старайтесь использовать двойные скобки `[[ ]]` вместо простых скобок `[ ]`. Шансы на ошибку ниже, хотя его нельзя переносить в `sh`. Более подробное объяснение можно найти [здесь](http://mywiki.wooledge.org/BashFAQ/031).

При запуске сценариев вам часто потребуется предоставить схожие аргументы. В Bash есть способы упростить эту задачу, расширяя выражения путем расширения имен файлов. Эти методы часто называют _globbing_ оболочки.
- Подстановочные знаки. Всякий раз, когда вы хотите выполнить какое-либо сопоставление с подстановочными знаками, вы можете использовать `?` и `*` для сопоставления одного или любого количества символов соответственно. Например, для файлов `foo`, `foo1`, `foo2`, `foo10` и `bar` команда `rm foo?` удалит `foo1` и `foo2`, тогда как `rm foo*` удалит все но `бар`.
- Фигурные скобки `{}`. Если у вас есть общая подстрока в серии команд, вы можете использовать фигурные скобки для bash, чтобы автоматически расширить ее. Это очень удобно при перемещении или преобразовании файлов.

```bash
convert image.{png,jpg}
# Will expand to
convert image.png image.jpg

cp /path/to/project/{foo,bar,baz}.sh /newpath
# Will expand to
cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath

# Globbing techniques can also be combined
mv *{.py,.sh} folder
# Will move all *.py and *.sh files


mkdir foo bar
# This creates files foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h
touch {foo,bar}/{a..h}
touch foo/x bar/y
# Show differences between files in foo and bar
diff <(ls foo) <(ls bar)
# Outputs
# < x
# ---
# > y
```


Написание bash-скриптов может быть сложным и неинтуитивным. Существуют такие инструменты, как [shellcheck](https://github.com/koalaman/shellcheck), которые помогут вам найти ошибки в ваших сценариях sh/bash.

Обратите внимание, что сценарии не обязательно должны быть написаны на bash, чтобы их можно было вызывать с терминала. Например, вот простой скрипт Python, который выводит аргументы в обратном порядке:

```python
#!/usr/local/bin/python
import sys
for arg in reversed(sys.argv[1:]):
    print(arg)
```

Ядро знает, что этот сценарий следует выполнять с помощью интерпретатора Python, а не с помощью команды оболочки, поскольку мы включили строку [shebang](https://en.wikipedia.org/wiki/Shebang_(Unix)) в верхней части сценария.
Хорошей практикой является написание строк shebang с использованием команды [`env`](https://www.man7.org/linux/man-pages/man1/env.1.html), которая будет определять, где находится команда. системе, увеличивая переносимость ваших сценариев. Чтобы определить местоположение, env будет использовать переменную среды PATH.
В этом примере строка shebang будет выглядеть как `#!/usr/bin/env python`.

Некоторые различия между функциями оболочки и сценариями, о которых вам следует помнить:
— Функции должны быть на том же языке, что и оболочка, а скрипты можно писать на любом языке. Вот почему важно включать shebang для скриптов.
— Функции загружаются один раз при чтении их определения. Скрипты загружаются каждый раз при выполнении. Это ускоряет загрузку функций, но всякий раз, когда вы их меняете, вам придется перезагрузить их определение.
- Функции выполняются в текущей среде оболочки, тогда как сценарии выполняются в своем собственном процессе. Таким образом, функции могут изменять переменные среды, например. измените текущий каталог, тогда как сценарии не могут. Скрипты будут передаваться по значениям переменных среды, которые были экспортированы с помощью [`export`](https://www.man7.org/linux/man-pages/man1/export.1p.html).
- Как и в любом языке программирования, функции представляют собой мощную конструкцию, позволяющую добиться модульности, повторного использования кода и ясности кода оболочки. Часто сценарии оболочки включают собственные определения функций.

## Как использовать команды

На данный момент вы, возможно, задаетесь вопросом, как найти флаги для команд из раздела aliasing, таких как `ls -l`, `mv -i` и `mkdir -p`.
И вообще, если вам дана команда, как узнать, что она делает и каковы ее различные опции?
Вы всегда можете начать гуглить, но поскольку UNIX появился еще до появления StackOverflow, существуют встроенные способы получения этой информации.

Как мы видели в лекции по shell, первый способ - вызвать команду с флагами `-h` или `--help`. Более подробный подход заключается в использовании команды `man`.
Сокращенно от manual, [`man`](https://www.man7.org/linux/man-pages/man1/man.1.html) предоставляет страницу руководства (называемую manpage) для указанной вами команды.
Например, `man rm` выведет поведение команды `rm` вместе с флагами, которые она принимает, включая флаг `-i`, который мы показывали ранее.
Фактически, то, на что я ссылался до сих пор для каждой команды, - это онлайн-версии руководств Linux по этим командам.
Даже неродные команды, которые вы устанавливаете, будут иметь записи в manpage, если разработчик написал их и включил в процесс установки.
Для интерактивных инструментов, например, основанных на ncurses, справку по командам часто можно получить внутри программы, используя команду `:help` или набрав `?`.

Иногда в manpages можно найти слишком подробное описание команд, что затрудняет расшифровку того, какие флаги/синтаксис следует использовать в обычных случаях.
[TLDR-страницы](https://tldr.sh/) - это удобное дополнительное решение, которое фокусируется на

## Поиск файлов

Одна из наиболее распространенных повторяющихся задач, с которой сталкивается каждый программист, — это поиск файлов или каталогов.
Все UNIX-подобные системы поставляются с [`find`](https://www.man7.org/linux/man-pages/man1/find.1.html), отличным инструментом оболочки для поиска файлов. `find` будет рекурсивно искать файлы, соответствующие некоторым критериям. Некоторые примеры:

```bash
# Find all directories named src
find . -name src -type d
# Find all python files that have a folder named test in their path
find . -path '*/test/*.py' -type f
# Find all files modified in the last day
find . -mtime -1
# Find all zip files with size in range 500k to 10M
find . -size +500k -size -10M -name '*.tar.gz'
```
Помимо перечисления файлов, `find` также может выполнять действия над файлами, которые соответствуют вашему запросу.
Это свойство может быть невероятно полезным для упрощения довольно монотонных задач.
```bash
# Delete all files with .tmp extension
find . -name '*.tmp' -exec rm {} \;
# Find all PNG files and convert them to JPG
find . -name '*.png' -exec convert {} {}.jpg \;
```


Несмотря на повсеместное распространение команды find, ее синтаксис иногда бывает сложно запомнить.
Например, чтобы просто найти файлы, соответствующие некоторому шаблону `PATTERN`, вам нужно выполнить `find -name '*PATTERN*'` (или `-iname`, если вы хотите, чтобы сопоставление с шаблоном не учитывало регистр).
Вы можете начать создавать псевдонимы для этих сценариев, но часть философии оболочки заключается в том, что полезно исследовать альтернативы.
Помните, одно из лучших свойств оболочки состоит в том, что вы просто вызываете программы, поэтому для некоторых из них вы можете найти (или даже написать самостоятельно).
Например, [`fd`](https://github.com/sharkdp/fd) — это простая, быстрая и удобная альтернатива `find`.
Он предлагает некоторые приятные настройки по умолчанию, такие как цветной вывод, сопоставление регулярных выражений по умолчанию и поддержку Unicode. На мой взгляд, он также имеет более интуитивный синтаксис.
Например, синтаксис для поиска шаблона PATTERN — fd PATTERN.

Большинство согласится, что `find` и `fd` хороши, но некоторые из вас могут задаться вопросом, насколько эффективнее каждый раз искать файлы по сравнению с компиляцией какого-то индекса или базы данных для быстрого поиска.
Для этого и нужен [`locate`](https://www.man7.org/linux/man-pages/man1/locate.1.html).
`locate` использует базу данных, которая обновляется с помощью [`updatedb`](https://www.man7.org/linux/man-pages/man1/updatedb.1.html).
В большинстве систем `updatedb` обновляется ежедневно через [`cron`](https://www.man7.org/linux/man-pages/man8/cron.8.html).
Поэтому одним из компромиссов между ними является скорость и свежесть.
Более того, `find` и подобные инструменты также могут находить файлы, используя такие атрибуты, как размер файла, время модификации или права доступа к файлу, тогда как `locate` просто использует имя файла.
Более подробное сравнение можно найти [здесь] (https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other).

## Поиск слов

Поиск файлов по имени полезен, но довольно часто вам нужно искать по *содержимому* файла.
Распространенным сценарием является поиск всех файлов, содержащих некоторый шаблон, а также место, где в этих файлах встречается этот шаблон.
Для достижения этой цели большинство UNIX-подобных систем предоставляют [`grep`](https://www.man7.org/linux/man-pages/man1/grep.1.html), общий инструмент для сопоставления шаблонов из входных данных. текст.
`grep` — невероятно ценный инструмент оболочки.

А пока знайте, что `grep` имеет множество флагов, которые делают его очень универсальным инструментом.
Некоторые из них, которые я часто использую, — это `-C` для получения **C**контекста вокруг совпадающей строки и `-v` для вставки**переноса совпадения, т. е. печати всех строк, которые **не** соответствуют шаблон. Например, `grep -C 5` напечатает 5 строк до и после совпадения.
Когда дело доходит до быстрого поиска по множеству файлов, вы можете использовать `-R`, поскольку он будет **R**рекурсивно заходить в каталоги и искать файлы по соответствующей строке.

Но `grep -R` можно улучшить разными способами, например, игнорирование папок `.git`, использование поддержки нескольких процессоров и т. д.
Было разработано множество альтернатив grep, включая [ack](https://github.com/beyondgrep/ack3), [ag](https://github.com/ggreer/the_silver_searcher) и [rg](https: //github.com/BurntSushi/ripgrep).
Все они фантастические и в значительной степени предоставляют одинаковую функциональность.

Обратите внимание: как и в случае с `find`/`fd`, важно знать, что эти проблемы можно быстро решить с помощью одного из этих инструментов, тогда как конкретные инструменты, которые вы используете, не так важны.

## Поиск shell команд

До сих пор мы видели, как находить файлы и код, но по мере того, как вы начнете проводить больше времени в оболочке, вам может понадобиться найти определенные команды, которые вы в какой-то момент набрали.
Первое, что нужно знать, это то, что нажатие стрелки вверх вернет вам последнюю команду, и если вы продолжите нажимать ее, вы медленно просматриваете историю своей оболочки.

Команда `history` позволит вам программно получить доступ к истории вашей оболочки.
Он выведет историю вашей оболочки на стандартный вывод.
Если мы хотим выполнить поиск там, мы можем передать этот вывод в grep и выполнить поиск шаблонов.
`history | grep find` выведет команды, содержащие подстроку «find».

В большинстве оболочек вы можете использовать «Ctrl+R» для выполнения обратного поиска по вашей истории.
Нажав `Ctrl+R`, вы можете ввести подстроку, которую хотите сопоставить для команд в вашей истории.
Продолжая нажимать на нее, вы будете циклически просматривать матчи в своей истории.
Это также можно включить с помощью стрелок ВВЕРХ/ВНИЗ в [zsh](https://github.com/zsh-users/zsh-history-substring-search).
Хорошим дополнением к `Ctrl+R` является использование привязок [fzf](https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r).
`fzf` — это средство нечеткого поиска общего назначения, которое можно использовать со многими командами.
Здесь он используется для нечеткого сопоставления вашей истории и представления результатов в удобной и визуально приятной форме.

Еще один крутой трюк, связанный с историей, который мне очень нравится, — это **самовнушение на основе истории**.
Впервые представленная в оболочке [fish](https://fishshell.com/), эта функция динамически автоматически дополняет текущую команду оболочки самой последней введенной вами командой, имеющей общий с ней префикс.
Его можно включить в [zsh](https://github.com/zsh-users/zsh-autosuggestions), и это отличный трюк для повышения качества жизни вашей оболочки.

Вы можете изменить поведение истории вашей оболочки, например запретить включение команд с начальным пробелом. Это удобно, когда вы вводите команды с паролями или другой конфиденциальной информацией.
Для этого добавьте HISTCONTROL=ignorespace в ваш .bashrc или setopt HIST_IGNORE_SPACE в .zshrc.
Если вы допустили ошибку, не добавив начальный пробел, вы всегда можете удалить запись вручную, отредактировав свой `.bash_history` или `.zsh_history`.

## Навигация по каталогам


До сих пор мы предполагали, что вы уже находитесь там, где вам нужно быть для выполнения этих действий. Но как быстро перемещаться по каталогам?
Есть много простых способов сделать это, например, написание псевдонимов оболочки или создание символических ссылок с помощью [ln -s](https://www.man7.org/linux/man-pages/man1/ln.1.html). , но правда в том, что разработчики уже придумали довольно умные и изощренные решения.

Как и в случае с темой этого курса, часто требуется оптимизировать систему для общего случая.
Поиск часто используемых и/или последних файлов и каталогов можно выполнить с помощью таких инструментов, как [`fasd`](https://github.com/clvv/fasd) и [`autojump`](https://github.com/wting/autojump).
Fasd ранжирует файлы и каталоги по [_frecency_](https://web.archive.org/web/20210421120120/https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm), что то есть как по _частоте_, так и по _давности_.
По умолчанию `fasd` добавляет команду `z`, которую вы можете использовать для быстрого `cd`, используя подстроку каталога _frecent_. Например, если вы часто заходите в `/home/user/files/cool_project`, вы можете просто использовать `z Cool`, чтобы перейти туда. Используя autojump, то же самое изменение каталога можно выполнить с помощью `j Cool`.

Существуют более сложные инструменты для быстрого получения обзора структуры каталогов: [`tree`](https://linux.die.net/man/1/tree), [`broot`](https://github.com/Canop/broot) или даже полноценные файловые менеджеры, такие как [`nnn`](https://github.com/jarun/nnn) или [`ranger`](https://github.com/ranger/ranger).

## PATH

После запуска операционной системы пользователю доступны различные инструменты, как системные (входящие в состав ОС), так и сторонние (установленные дополнительно). Часто в процессе работы возникает необходимость использования командной строки для вызова различных утилит, помогающих в процессе работы. Например, в случае, когда браузеру не удается открыть страницу удаленного веб-сервиса: зайти на почту или открыть новостную ленту, мы можем наблюдать следующую ошибку — "404 NotFound". Чтобы определить, на чьей стороне ошибка: вашей сети или удаленного сервера, часто используют системные утилиты, консоли для работы с сетью. Такие как PING, IPCONFIG, ARP, NETSTAT и т.д.

В Linux (также UNIX)  **`$PATH`**  — это переменная среды, используемая для указания оболочке, где искать исполняемые файлы.  **`$PATH`**  обеспечивает большую гибкость и безопасность для систем  [**Linux**](https://blog.sedicomm.com/2018/01/21/kak-ustanovit-golang-yazyk-programmirovaniya-go-v-linux/), и, безусловно, можно сказать, что это одна из самых важных переменных среды.

Программы/скрипты, расположенные в каталоге  **`$PATH`**, могут быть выполнены непосредственно в вашей оболочке без указания полного пути к ним.

> Чтобы выяснить путь к домашнему каталогу, дайте команду `echo $HOME`, которая выведет в окне терминала полный путь. Перейдите в указанный каталог и создайте папку для разрабатываемых сценариев (`scripts`). Затем добавьте эту папку в свой сценарий входа, для чего откройте файл сценария в текстовом редакторе и добавьте в начало файла следующую строку, заменив /path/to/scripts/ на путь к папке с вашими сценариями:
> `export PATH="/path/to/scripts/:$PATH"`
```bash
root@de30378728be:/test# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
root@de30378728be:/test#
```

Результат отображает список каталогов, разделенных двоеточиями. Вы можете легко добавить больше каталогов, отредактировав файл профиля оболочки вашего пользователя.

В разных оболочках это делается так:

оболочка Bash -> `~/ .bash_profile`, `~/ .bashrc` или `.profile`
оболочка Korn -> `~/.kshrc` или `.profile`
оболочка Z -> `~/.zshrc` или `.zprofile`
Обратите внимание, в зависимости от того, как вы регистрировались в системе, могут прочитаться разные файлы конфигурации оболочки. Вот что говорит руководство по bash, помните, что есть файлы конфигурации и на других оболочках:

`/bin/bash` — запуск оболочки
`/etc/profile` — глобальный системный файл инициализации, запускается при входе в оболочку
`/etc/bash.bashrc` — глобальный системный файл сценария конфигурации оболочки
`~/.bash_profile` — персональный файл инициализации пользователя, запускается при входе в оболочку
`~/.bashrc` — персональный файл сценария конфигурации оболочки
`~/.bash_logout` — персональный файл сценария выхода для очистки оболочки, запускается когда пользователь выходит с оболочки
`~/.inputrc` — персональный файл конфигурации клавиатуры для специфических ситуаций

Пример подсчета установленных коммнад в ОС.
```bash
#!/bin/bash
# Подсчет количества команд: простой сценарий для подсчета количества выполняемых команд в каталогах из списка PATH

IFS=":"
count=0
nonex=0

for directory in $PATH ; do
    if [ -d "$directory" ] ; then
        for command in "$directory"/* ; do
            if [ -x "$command" ] ; then
                count=$(( count + 1 ))
            else
                nonex=$(( nonex + 1 ))
            fi
        done
    fi
done

echo "$count commands, and $nonex entries that weren't executable"
exit 0
```

## Усовершенствование пользовательских команд 
**1. Добавление команд в PATH**
Одним из способов использования пользовательских команд является добавление их в переменную PATH, чтобы они были доступны в любой директории. Для этого достаточно скопировать исполняемый файл в директорию, указанную в PATH.
**2. Параметры команды**
Для улучшения функциональности пользовательских команд можно добавить параметры, которые будут изменять поведение команды в зависимости от переданных значений. В Bash-скриптах параметры передаются через переменные `$1`, `$2`, `$3` и т.д., где `$1` - первый параметр, `$2` - второй параметр и т.д.

Например, пользовательская команда  `mycommand`  может принимать параметр  `-l`, который будет выводить длину переданного текста:

```bash
#!/bin/bash

if [ "$1" = "-l" ]; then
    echo "Length: ${#2}"
else
    echo "Unknown parameter"
fi

```

Вызов команды  `mycommand -l "Hello, World!"`  выведет длину строки "Hello, World!".

**3. Обработка ошибок**

Важной частью пользовательских команд является обработка ошибок. Баш-скрипты могут возвращать коды ошибок, которые могут быть использованы для определения типа ошибки и выполнения соответствующих действий.

Например, команда  `awk`  возвращает код ошибки 0, если выполнение прошло успешно, и код ошибки 1, если во время выполнения произошла ошибка. Можно использовать эту информацию, чтобы определить, был ли успешно выполнен вызов команды  `awk`:

```bash
#!/bin/bash

awk -F',' '{print $1}' file.csv

if [ $? -eq 0 ]; then
    echo "Command executed successfully"
else
    echo "An error occurred" 
fi
```
### Резервное копированией файлов при удалении
Одна из распространенных проблем, с которыми часто сталкиваются пользователи Unix, — сложность восстановления удаленных по ошибке файлов или каталогов. В Unix нет приложения, такого же удобного, как Undelete 360, WinUndelete или утилита для OS X, которое позволяло бы просматривать и восстанавливать удаленные файлы щелчком на кнопке. Как только вы нажмете клавишу enter после ввода команды rm filename, файл станет историей. Чтобы решить эту проблему, нужно организовать тайное и автоматическое архивирование файлов и каталогов в архив .deleted-files. Немного подумав, можно написать сценарий, который сделает все это почти незаметно для пользователя.
>  Синтаксис [if](https://ryanstutorials.net/bash-scripting-tutorial/bash-if-statements.php)
>  
> `if ANY_COMMAND_YOU_WANT_AT_ALL; then `
> `# ... stuff to do`
>  `fi`
> Любые переданные им аргументы могут назначаться позиционно с помощью особых переменных `$1`, `$2`, `$3` и т. д. Число аргументов содержится в переменной `$#`.
> [getopts](https://habr.com/ru/articles/169133/)
```bash
#!/bin/bash
# newrm -- замена существующей команды rm.
#
# Этот сценарий предоставляет простую возможность восстановления, создавая и
# используя новый каталог в домашнем каталоге пользователя. Может обрабатывать
# каталоги и отдельные файлы. Если пользователь добавляет флаг -f, файлы
# удаляются БЕЗ архивирования. 
# Важное предупреждение: возможно, вам понадобится создать задание для cron или
# нечто подобное для очистки удаленных каталогов и файлов через некоторое
# время. Иначе файлы не будут удаляться из системы и вы рискуете исчерпать
# дисковое пространство!

archivedir="$HOME/.deleted-files"
realrm="$(which rm)"
copy="$(which cp) -R"
if [ $# -eq 0 ] ; then # Позволить 'rm’ вывести сообщение о порядке использования.
    exec $realrm # Our shell is replaced by /bin/rm.
fi
# Проверить все параметры на наличие флага '-f’
flags=""
while getopts "dfiPRrvW" opt
do
    case $opt in
        f ) exec $realrm "$@"
            ;; # exec позволяет покинуть сценарий немедленно.
        * ) flags="$flags -$opt" ;; # Другие флаги предназначены команде rm.
    esac
done
shift $(( $OPTIND - 1 ))
# НАЧАЛО ОСНОВНОГО СЦЕНАРИЯ
# =================
# Гарантировать наличие каталога $archivedir.
if [ ! -d $archivedir ] ; then
    if [ ! -w $HOME ] ; then
        echo "$0 failed: can't create $archivedir in $HOME" >&2
        exit 1
    fi
    mkdir $archivedir
    chmod 700 $archivedir # Ограничить доступ к каталогу.
fi
for arg do
    newname="$archivedir/$(date "+%S.%M.%H.%d.%m").$(basename "$arg")"
    if [ -f "$arg" -o -d "$arg" ] ; then
        $copy "$arg" "$newname"
    fi
done
exec $realrm $flags "$@" # Текущий сценарий будет вытеснен командой realrm."
```
Пример использования 
```bash
root@de30378728be:/test# chmod 777 newrm.sh
root@de30378728be:/test# ./newrm.sh wap.txt
root@de30378728be:/test# ls
newrm.sh
root@de30378728be:/test# ls $HOME/.
./              .config/
../             .deleted-files/
.bashrc         .profile
.cache/         .viminfo
root@de30378728be:/test# ls $HOME/.deleted-files/
26.30.10.22.09.wap.txt
root@de30378728be:/test#
```

Улучшение функции `ls -l` 
```bash
#!/bin/bash
# formatdir -- выводит содержимое каталога в дружественном и информативном виде
# Обратите внимание: необходимо, чтобы "scriptbc" (сценарий № 9) находился в одном из каталогов, перечисленных в PATH, потому что он неоднократно вызывается в данном сценарии.
scriptbc=$(which scriptbc)
# Функция для преобразования размеров из KB в KB, MB или GB для большей удобочитаемости вывода
readablesize()
{
    if [ $1 -ge 1048576 ] ; then
        echo "$($scriptbc -p 2 $1 / 1048576)GB"
    elif [ $1 -ge 1024 ] ; then
        echo "$($scriptbc -p 2 $1 / 1024)MB"
    else
        echo "${1}KB"
    fi
}
#################
## КОД ОСНОВНОГО СЦЕНАРИЯ
if [ $# -gt 1 ] ; then
    echo "Usage: $0 [dirname]" >&2
    exit 1
elif [ $# -eq 1 ] ; then # Указан определенный каталог, не текущий?
    cd "$@" # Тогда перейти в него.
    if [ $? -ne 0 ] ; then # Или выйти, если каталог не существует.
        exit 1
    fi
fi

for file in *
do
    if [ -d "$file" ] ; then
        size=$(ls "$file" | wc -l | sed 's/[^[:digit:]]//g')
        if [ $size -eq 1 ] ; then
            echo "$file ($size entry)|"
        else
            echo "$file ($size entries)|"
        fi
    else
        size="$(ls -sk "$file" | awk '{print $1}')"
        echo "$file ($(readablesize $size))|"
    fi
done | \
sed 's/ /^^^/g' | \
xargs -n 2 | \
sed 's/\^\^\^/ /g' | \
awk -F\| '{ printf "%-39s %-39s\n", $1, $2 }'

exit 0
```
Пример использования 
```bash
root@de30378728be:/test# chmod 777 formatdir.sh
root@de30378728be:/test# ./formatdir.sh
formatdir.sh (4KB)                       newrm.sh (4KB)
root@de30378728be:/test# ./formatdir.sh /
bin (562 entries)                        boot (0 entries)
dev (16 entries)                         etc (95 entries)
home (0 entries)                         lib (30 entries)
lib32 (0 entries)                        lib64 (1 entry)
libx32 (0 entries)                       media (0 entries)
mnt (0 entries)                          opt (0 entries)
proc (74 entries)                        root (0 entries)
run (3 entries)                          sbin (123 entries)
srv (0 entries)                          sys (11 entries)
test (2 entries)                         tmp (0 entries)
usr (12 entries)                         var (11 entries)
root@de30378728be:/test#
```

---


# Задания
## Hello world v1
Выведите Hello world в терминал
## Hello world v2
Выведите Hello world используя переменные 
## Hello world v3
Выведите Hello world используя ввод пользователя 
```./your_script.sh
What are you doing?
Sleep
You are Sleeping
```
## Как это запустить
```bash
#!/bin/bash
deploy=false
uglify=false
while (( $# > 1 )); do case $1 in
--deploy) deploy="$2";;
--uglify) uglify="$2";;
*) break;
esac; shift 2
done
$deploy && echo "will deploy... deploy = $deploy"
$uglify && echo "will uglify... uglify = $uglify"
# how to run it ?
```

## Список файлов без использования `ls`
Необходимо вывести список файлов без использования команды `ls`, используйте возможности оболочки Bash по расширению имен файлов и расширению скобок, чтобы получить имена файлов. 

### Существует ли пользователь
Необходимо написать скрипт которому на вход передается имя пользователя и если он существует выводиться  сообщение. Проверить существует ли пользователь можно через `grep $user /etc/passwd`
```bash
"The user $user Exists"
"The user $user doesn’t exist"
```

## Сравнение чисел
> `n1 -eq n2`Возвращает истинное значение, если `n1` равно `n2`.  
   `n1 -ge n2` Возвращает истинное значение, если `n1`больше или равно `n2`.  
   `n1 -gt n2`Возвращает истинное значение, если `n1` больше `n2`.  
   `n1 -le n2`Возвращает истинное значение, если `n1`меньше или равно `n2`.  
   `n1 -lt n2`Возвращает истинное значение, если `n1` меньше `n2`.  
  `n1 -ne n2`Возвращает истинное значение, если `n1`не равно `n2`.

Необходимо написать скрипт которому на вход передается число и он сравнивает его с переменной скрипта
```bash
echo "The test value $val1 is greater than 5"
echo "The test value $val1 is not greater than 5"
```

## Проверка файлов

> `-d file`Проверяет, существует ли файл, и является ли он директорией.  
`-e file`Проверяет, существует ли файл.  
`-f file` Проверяет, существует ли файл, и является ли он файлом.  
`-r file`Проверяет, существует ли файл, и доступен ли он для чтения.  
`-s file П`роверяет, существует ли файл, и не является ли он пустым.  
`-w file`Проверяет, существует ли файл, и доступен ли он для записи.  
`-x file`Проверяет, существует ли файл, и является ли он исполняемым.  
`file1 -nt file2` Проверяет, новее ли `file1`, чем `file2`.  
`file1 -ot file2`Проверяет, старше ли `file1`, чем `file2`.  
`-O file` Проверяет, существует ли файл, и является ли его владельцем текущий пользователь.  
`-G file`Проверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя.

Написать скрипт который проверят кем является файл
```bash
echo "The $mydir directory exists"
echo "The $mydir directory does not exist"
```

## 1. 
Прочтите [`man ls`](https://www.man7.org/linux/man-pages/man1/ls.1.html) и напишите команду `ls`, которая выводит список файлов следующим образом.

     - Включает все файлы, включая скрытые файлы
     - Размеры указаны в удобочитаемом формате (например, 454M вместо 454279954).
     - Файлы упорядочены по давности.
     - Вывод раскрашен

     Пример вывода будет выглядеть так

    ```
    -rw-r--r--   1 user group 1.1M Jan 14 09:53 baz
    drwxr-xr-x   5 user group  160 Jan 14 09:53 .
    -rw-r--r--   1 user group  514 Jan 14 06:42 bar
    -rw-r--r--   1 user group 106M Jan 13 12:12 foo
    drwx------+ 47 user group 1.5K Jan 12 18:08 ..
    ```

--------
## 2. 
Напишите функции bash `marco` и `polo`, которые делают следующее.
Всякий раз, когда вы выполняете `marco`, текущий рабочий каталог должен каким-то образом сохраняться, затем, когда вы выполняете `polo`, независимо от того, в каком каталоге вы находитесь, `polo` должен `cd` вернуться в каталог, в котором вы выполнили `marco`.
Для упрощения отладки вы можете записать код в файл `marco.sh` и (повторно) загрузить определения в свою оболочку, выполнив `source marco.sh`.

--------
## 3. 
Допустим, у вас есть команда, которая редко дает сбой. Чтобы отладить его, вам необходимо записать его выходные данные, но запуск сбоя может занять много времени.
Напишите сценарий bash, который запускает следующий сценарий до тех пор, пока он не завершится сбоем, записывает стандартный вывод и потоки ошибок в файлы и печатает все в конце.


```bash
#!/usr/bin/env bash

n=$(( RANDOM % 100 ))

if [[ n -eq 42 ]]; then
    echo "Something went wrong"
    >&2 echo "The error was using magic numbers"
    exit 1
fi

echo "Everything went according to plan"
```


--------

## 4. 
Как мы уже говорили, `-exec` команды `find` может быть очень мощным инструментом для выполнения операций над файлами, которые мы ищем.
Однако что, если мы захотим что-то сделать со **всеми** файлами, например создать zip-файл?
Как вы видели до сих пор, команды будут принимать входные данные как из аргументов, так и из `STDIN`.
При передаче команд мы подключаем `STDOUT` к `STDIN`, но некоторые команды, такие как tar, принимают входные данные из аргументов.
Чтобы преодолеть это отключение, существует команда [`xargs`](https://www.man7.org/linux/man-pages/man1/xargs.1.html), которая выполнит команду, используя STDIN в качестве аргументов.
Например `ls | xargs rm` удалит файлы в текущем каталоге.
Ваша задача — написать команду, которая рекурсивно находит все HTML-файлы в папке и архивирует их. Обратите внимание, что ваша команда должна работать, даже если в файлах есть пробелы (подсказка: проверьте флаг `-d` для `xargs`).

Для создания файлов можете использовать данный скрипт:
```bash
	for i in {1..100}; do 
		file_extension=('.HTML'  '.txt'  '.cpp'  '.o'  '.so') 
		file_type=${file_extension[$RANDOM % ${#file_extension[@]}]} 
		file_name=generated_file_$i$file_type  
		touch  $file_name  
		echo  "This is file number $i" > $file_name  
	done  
```
> Если вы используете macOS, обратите внимание, что функция поиска BSD по умолчанию отличается от той, которая включена в [GNU coreutils](https://en.wikipedia.org/wiki/List_of_GNU_Core_Utilities_commands). Вы можете использовать `-print0` для `find` и флаг `-0` для `xargs`. Как пользователь macOS, вы должны знать, что утилиты командной строки, поставляемые с macOS, могут отличаться от аналогов GNU; вы можете установить версии GNU, если хотите, [используя Brew](https://formulae.brew.sh/formula/coreutils).
--------
## 5. 
Напишите команду или сценарий для рекурсивного поиска последнего измененного файла в каталоге. В более общем плане, можете ли вы перечислить все файлы по давности?



--------
