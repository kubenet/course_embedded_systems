Библиотека NumPy стала фактическим стандартом в целом для научного программирования на Python. Ее ядром является объект ndarray, многомерный массив данных одного типа, который можно сортировать, изменять его форму, он может быть операндом в математических операциях и в статистическом анализе, его можно записывать в файлы, затем считывать из них и т. д. Реализации NumPy таких математических операций и алгоритмов обладают двумя главными преимуществами над основными объектами языка Python, которые мы использовали до сих пор. Во-первых, они реализованы как предварительно скомпилированный код на языке C, поэтому обеспечивают скорость выполнения, сравнимую со скоростью программы, написанной на C. Во-вторых, биб­лиотека NumPy поддерживает векторизацию: единственная операция может быть выполнена над всем массивом в целом вместо применения явного цикла для последовательной обработки элементов массива. Например, сравним операцию умножения двух одномерных списков a и b из n чисел в обычном языке
Python:

```python
c = []
for i in range(n):
	c.append(a[i] * b[i])
```
Используя `Numpy`
```python
c = a * b
```

# Основные методы массива


Классом массива NumPy является ndarray, который состоит из многомерной
таблицы элементов, индексируемых кортежем целых чисел. В отличие от списков и кортежей Python, элементы не могут принадлежать к различным типам: каждый элемент в массиве NumPy имеет один и тот же тип, который определяется соответствующим объектом типа данных (dtype). Тип dtype массива определяет не только общий класс элемента (целое число, число с плавающей точкой и т. п.), но также его представление в памяти (например, сколько битов занимает элемент)
Индексация многомерного массива NumPy немного отличается от индексации обычного списка списков в Python: вместо указания индекса требуемого элемента в отдельных квадратных скобках $b[i][j]$ используется кортеж целых чисел $b[i,j]$:

```python
import numpy as np
a = np.array( (100, 101, 102, 103) )
b = np.array( [[1.,2.], [3.,4.]] )
```

Тип данных логически выводится из типа элементов последовательности
и «принудительно приводится» к наиболее общему типу, если заданы элементы различных, но совместимых типов:

```python
In [x]: np.array( [-1, 0, 2.]) # Смешаны значения типов int и float: приведение к типу
float.
Out[x]: array([-1., 0., 2.])
```

Можно также явно установить тип данных с помощью необязательного аргумента `dtype`

```python
In [x]: np.array( [0, 4, -4], dtype=complex)
In [x]: array([ 0.+0.j, 4.+0.j, -4.+0.j])
```

Если массив большой или во время его создания значения элементов неизвестны, то предлагается несколько методов объявления массива заданной формы, заполненного значениями по умолчанию или произвольно выбранными значениями. Самый простой и быстрый метод np.empty принимает кортеж, описывающий форму, и создает массив без инициализации его элементов: начальные значения элементов не определены (обычно это случайный «мусор», содержащийся в памяти, выделенной Python для этого массива).

```python
In [x]: np.empty((2,2))
Out[x]:
		array([[ -2.31584178e+077, -1.72723381e-077],
		[ 2.15686807e-314,
		2.78134366e-309]])
```

Существуют также более удобные методы `np.zeros` и `np.ones`, создающие
массив заданной формы с элементами, равными `0` и `1` соответственно. Методы `np.empty`, `np.zeros` и `np.ones` принимают необязательный аргумент `dtype`.

```python
In [x]: np.zeros((3,2))# По умолчанию для dtype определен тип 'float'.
Out[x]:
array([[ 0., 0.],
		[ 0., 0.],
		[ 0., 0.]])
In [x]: np.ones((3,3), dtype=int)
Out[x]:
array([[1, 1, 1],
		[1, 1, 1],
		[1, 1, 1]])
```

Если уже существует некоторый массив и необходимо создать другой массив той же формы, то следует воспользоваться методами `np.empty_like`, `np.zeros_like` и `np.ones_like`:
```python
In [x]: a
Out[x]: array([100, 101, 102, 103])
In [x]: np.ones_like(a)
Out[x]: array([1, 1, 1, 1])
In [x]: np.zeros_like(a, dtype=float)
Out[x]: array([ 0., 0., 0., 0.])
```

## Инициализация массива из последовательности

Для создания массива, содержащего последовательность чисел, существуют два метода: `np.arange` и `np.linspace`. Метод `np.arange` равнозначен методу Python range, за исключением того, что он может генерировать последовательности чисел с плавающей точкой. Кроме того, он действительно выделяет память для элементов `ndarray`, а не возвращает объект, похожий на генератор

```python
In [x]: np.arange(7)
Out[x]: array([0, 1, 2, 3, 4, 5, 6])
In [x]: np.arange(1.5, 3., 0.5)
Out[x]: array([ 1.5, 2. , 2.5]))
```

Как и при использовании range, массивы, сгенерированные в этих примерах,
не включают последние элементы 7 и 3. Но с методом `arange` связана одна проблема: из-за ограниченной точности арифметики чисел с плавающей точкой не всегда можно узнать, сколько элементов будет создано. По этой причине, а также потому, что часто требуется самый последний элемент определяемой последовательности, метод `np.linspace` может оказаться более удобным способом создания числовой последовательности. Например, для генерации равномерно распределенных значений элементов массива из пяти чисел между 1 и 20, включая сами эти числа:
```python
In [x]: np.linspace(1, 20, 5)
Out[x]: array([ 1. , 5.75, 10.5, 15.25, 20. ])
```

Метод `np.linspace` может принимать несколько необязательных аргументов
с логическими значениями. Если для аргумента `retstep` задать значение `True`, то возвращается размер шага в генерируемой последовательности чисел:

```python
In [x]: x, dx = np.linspace(0., 2*np.pi, 100, retstep=True)
In [x]: dx
Out[x]: 0.06346651825433926
```

Это помогает избежать отдельного вычисления $dx = (end-start)/(num-1)$
В приведенном выше примере `100` точек между $0$ и $2π$, включая граничные
значения, разделены шагом, равным $2π/99 = 0.0634665….$
```python
In [x]: x = np.linspace(0, 5, 5, endpoint=False)
Out[x]: array([ 0., 1., 2., 3., 4.])
```

## Инициализация массива из функции

Для создания массива, инициализируемого значениями, которые вычисляются с помощью некоторой функции, используется метод `NumPy` `np.fromfunction`, принимающий в качестве аргументов эту функцию и кортеж, определяющий форму требуемого массива. Сама функция должна принимать количество аргументов, совпадающее с размерностями создаваемого массива: эти аргументы индексируют каждый элемент, в который функция возвращает значение. Приведенный ниже пример поможет лучше понять применение метода `np.fromfunction`:

```python
In [x]: def f(i, j):
...: return 2 * i * j
...:
In [x]: np.fromfunction(f,(4,3))
array([ [ 0., 0., 0.],
		[ 0., 2., 4.],
		[ 0., 4., 8.],
		[ 0., 6., 12.]])
```

Функция $f$ вызывается для каждого индекса в заданной форме, а возвращаемые значения используются для инициализации соответствующих элементов. Простое выражение, подобное приведенному выше, можно заменить на анонимную лямбда-функцию, если это более предпочтительно:
```python
In [x]: np.fromfunction(lambda i,j: 2*i*j, (4,3))
```