# Курс: Информатика
#computer_science #python #note 
# Практическое занятие №4. "Введение в Python"

`Python` представляет популярный высокоуровневый язык программирования, который предназначен для создания приложений различных типов. Это и веб-приложения, и игры, и настольные программы, и работа с базами данных. Довольно большое распространение питон получил в области машинного обучения и исследований искусственного интеллекта.

Впервые язык `Python` был анонсирован в 1991 году голландским разработчиком Гвидо Ван Россумом. С тех пор данный язык проделал большой путь развития. В 2000 году была издана версия 2.0, а в 2008 году - версия 3.0. Несмотря на вроде такие большие промежутки между версиями постоянно выходят подверсии. Так, текущей актуальной версией на момент написания данного материала является  3.11, которая вышла в октябре 2022 года.

Основные особенности языка программирования `Python`:

-   Скриптовый язык. Код программ определяется в виде скриптов.
    
-   Поддержка самых различных парадигм программирования, в том числе объектно-ориентированной и функциональной парадигм.
    
-   Интерпретация программ. Для работы со скриптами необходим интерпретатор, который запускает и выполняет скрипт.
    
    Выполнение программы на `Python` выглядит следующим образом. Сначала мы пишим в текстовом редакторе скрипт с набором выражений на данном языке программирования. Передаем этот скрипт на выполнение интерпретатору. Интерпретатор транслирует код в промежуточный байткод, а затем виртуальная машина переводит полученный байткод в набор инструкций, которые выполняются операционной системой.
    
    Здесь стоит отметить, что хотя формально трансляция интерпретатором исходного кода в байткод и перевод байткода виртуальной машиной в набор машинных команд представляют два разных процесса, но фактически они объединены в самом интерпретаторе.
    
    ![Выполнение программы на Python](https://metanit.com/python/tutorial/pics/1.9.png)
-   Портативность и платформонезависимость. Не имеет значения, какая у нас операционная система - Windows, Mac OS, Linux, нам достаточно написать скрипт, который будет запускаться на всех этих ОС при наличии интерпретатора
    
-   Автоматическое управление памяти
    
-   Динамическая типизация
    
 `Python` - очень простой язык программирования, он имеет лаконичный и в то же время довольно простой и понятный синтаксис. Соответственно его легко изучать, и собственно это одна из причин, по которой он является одним из самых популярных языков программирования именно для обучения. В частности, в 2014 году он был признан самым популярным языком программирования для обучения в США.
 
Естественные языки — это языки, на которых говорят люди, такие как английский, испанский и французский.
Они не были созданы людьми (хотя люди пытаются навести в них некоторый порядок); они развивались естественным путем.
Формальные языки — это языки, разработанные людьми для конкретных приложений. Для Например, обозначения, которые используют математики, представляют собой формальный язык, который особенно хорошо обозначает отношения между числами и символами. Химики используют формальный язык, чтобы представить химическую структуру молекул. И самое важное:
** Языки программирования — это формальные языки, созданные для записи компьютерных программ.**
В формальных языках обычно действуют строгие правила синтаксиса. Например, `3+3=6` — это
синтаксически правильное математическое утверждение, но `3+ = 3$6` — нет. $H_2O$ – это синтаксически химическая формула правильная, а $_2 Zz$ нет.
# Первая программа 
---
Первый запуск **командной строкой интерпретатора Python**
```python
$ python3
Python 3.3.0 (default, Oct 22 2012, 12:20:36)
[GCC 4.2.1 Compatible Apple Clang 4.0 ((tags/Apple/clang-421.0.60))] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> print('hello world')
hello world
>>>
```
Также можно создавать файлы с расширением `.py`
```python
print('Привет, Мир!')
```
И после вызывать
```python
$ python3 helloworld.py
Привет, Мир!
```
Как вы помните для простого запуска `bash` скриптов, в начала файла добваляли так называемый `shebang`, тоже самое можно делать и с файлами `python` 
```bash
#!/usr/bin/env python3
```

```python
#!/usr/bin/env python3
print('Привет, Мир!')
```
Теперь необходимо установить программе атрибут исполнимости, используя команду `chmod`, а затем выполнить программу.
```bash
chmod a+x helloworld.py
```
После этого мы можем запускать программу напрямую, потому что наша операционная система запустит `/usr/bin/env`, который, в свою очередь, найдёт `Python` 3, а значит, сможет запустить наш файл.
```bash
$ ./helloworld.py
Привет, Мир!
```
Интересный факт! Действительно, чтобы запускать программу из любого каталога, можно разместить ее в одном из каталогов, указанных в переменной окружения `PATH`. Переменная окружения `PATH` содержит список каталогов, в которых операционная система ищет исполняемые файлы. Когда вы вызываете программу из командной строки, система просматривает эти каталоги в порядке, указанном в переменной окружения `PATH`. Чтобы узнать, какие каталоги указаны в переменной `PATH`, вы можете выполнить команду `echo $PATH`. Это выведет список каталогов, разделенных двоеточием. Чтобы сделать программу доступной из любого места, вы можете скопировать ее в один из каталогов, перечисленных в переменной `PATH`. Например, если ваша программа называется `helloworld` и вы хотите, чтобы она была доступна в любом каталоге, вы можете скопировать ее в каталог `/usr/local/bin`, если он указан в переменной PATH. После этого вы сможете запустить программу из любого каталога, просто введя команду `./helloworld`.

```terminal
$ echo $PATH
/usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:/home/swaroop/bin
$ cp helloworld.py /home/swaroop/bin/helloworld
$ helloworld
Привет, Мир!
```
## Комментарии


_Комментарии_ — это любой текст справа от символа `#`, который в основном полезен в качестве примечаний для читателя программы.

Например:

```python
print('hello world') # Обратите внимание, что print - это функция
```

или:

```python
# Обратите внимание, что печать — это функция
print('Привет, мир')
```

Используйте в своей программе как можно больше полезных комментариев, чтобы:

- объяснить предположения
- объяснять важные решения
- объяснить важные детали
- объяснить проблемы, которые вы пытаетесь решить
- объясните проблемы, которые вы пытаетесь преодолеть в своей программе и т. д.

[*В коде указано, как, а в комментариях должно быть указано, почему*](http://www.codinghorror.com/blog/2006/12/code-tells-you-how-comments-tell-you-why.html).

Это полезно для читателей вашей программы, чтобы они могли легко понять, что делает программа. Помните, этот человек может стать вами уже через шесть месяцев!

## Литеральные константы

Примером буквальной константы может служить число типа «5», «1,23» или строка типа «Это строка» или «Это строка!».

Он называется литералом, потому что он _литерал_ — вы используете его значение буквально. Число `2` всегда представляет само себя и ничего больше — это _константа_, потому что ее значение нельзя изменить. Следовательно, все они называются буквальными константами.

## Числа

Числа в основном бывают двух типов — целые и с плавающей запятой.

Примером целого числа является `2`, которое представляет собой просто целое число.

Примерами чисел с плавающей запятой (или для краткости _floats_) являются `3.23` и `52.3E-4`. Обозначение `E` обозначает степень 10. В данном случае `52.3E-4` означает `52.3 * 10^-4^`.

> **Примечание для опытных программистов**
>
> Отдельного типа `long` не существует. Тип int может быть целым числом любого размера.

## Строки

Строка представляет собой _последовательность_ _символов_. Строки — это, по сути, просто набор слов.

Вы будете использовать строки почти в каждой написанной вами программе Python, поэтому обратите внимание на следующую часть.

### Одиночная кавычка

Вы можете указывать строки, используя одинарные кавычки, например «Цитируйте меня по этому поводу».

Все пробелы, то есть пробелы и табуляции внутри кавычек, сохраняются как есть.

### Двойные кавычки

Строки в двойных кавычках работают точно так же, как строки в одинарных кавычках. Пример: «Как тебя зовут?».

### Тройные кавычки

Вы можете указывать многострочные строки, используя тройные кавычки - (`"""` или `'''`). Вы можете свободно использовать одинарные и двойные кавычки внутри тройных кавычек. Пример:

```python
'''Это многострочная строка. Это первая линия.
Это вторая линия.
«Как тебя зовут?» — спросил я.
Он сказал: «Бонд, Джеймс Бонд».
'''
```
### Строки неизменяемы

Это означает, что после создания строки вы не сможете ее изменить. Хотя это может показаться
плохая вещь, это действительно не так. Мы увидим, почему это не является ограничением в различных программах, которые
мы увидим позже.

> **Примечание для программистов C/C++**
>
> В Python нет отдельного типа данных char. В этом нет реальной необходимости, и я уверен, что вы не пропустите это.

<!-- -->

> **Примечание для программистов Perl/PHP**
>
> Помните, что строки в одинарных и двойных кавычках — это одно и то же — они ничем не отличаются.

### Метод форматирования

Иногда нам может потребоваться создать строки из другой информации. Вот тут-то и пригодится метод format().

Сохраните следующие строки как файл `str_format.py`:

```python
age = 20
name = 'Сваруп'

print('{0} было {1} лет, когда он написал эту книгу'.format(name, age))
print('Почему {0} играет с этим питоном?'.format(name))
```

Выход:

```
$ python str_format.py
Сварупу было 20 лет, когда он написал эту книгу.
Почему Сваруп играет с этим питоном?
```

**Как это работает**

Строка может использовать определенные спецификации, и впоследствии можно вызвать метод format для замены этих спецификаций соответствующими аргументами метода format.

Обратите внимание на первое использование, когда мы используем `{0}`, и это соответствует переменной `name`, которая является первым аргументом метода формата. Аналогично, вторая спецификация — `{1}`, соответствующая `age`, который является вторым аргументом метода формата. Обратите внимание, что Python начинает отсчет с 0, что означает, что первая позиция имеет индекс 0, вторая позиция — индекс 1 и так далее.

Обратите внимание, что мы могли бы добиться того же, используя конкатенацию строк:

```python
имя + 'является' + str(возраст) + 'лет'
```

но это гораздо уродливее и более подвержено ошибкам. Во-вторых, преобразование в строку будет выполняться автоматически методом `format` вместо явного преобразования в строки, необходимого в этом случае. В-третьих, при использовании метода format мы можем изменить сообщение, не обращаясь к используемым переменным, и наоборот.

Также обратите внимание, что цифры не являются обязательными, поэтому вы могли бы также написать так:

```python
age = 20
name = 'Сваруп'

print('{} было {} лет, когда он написал эту книгу'.format(name, age))
print('Почему {} играет с этим питоном?'.format(name))
```

который даст тот же результат, что и предыдущая программа.

Мы также можем назвать параметры:

```python
age = 20
name = 'Сваруп'

print('{name} было {age} лет, когда он написал эту книгу'.format(name=name, age=age))
print('Почему {name} играет с этим питоном?'.format(name=name))
```

который даст тот же результат, что и предыдущая программа.

В `Python 3.6` представлен более короткий способ создания именованных параметров, называемый «f-строками»:

```python
age = 20
name = 'Сваруп'

print(f'{name} было {age} лет, когда он написал эту книгу') # обратите внимание на 'f' перед строкой
print(f'Почему {name} играет с этим питоном?') # обратите внимание на 'f' перед строкой
```

который даст тот же результат, что и предыдущая программа.

В методе `format` Python заменяет каждое значение аргумента на место спецификации. Могут быть более подробные характеристики, такие как:

```python
# decimal (.) precision of 3 for float '0.333'
print('{0:.3f}'.format(1.0/3))
# fill with underscores (_) with the text centered
# (^) to 11 width '___hello___'
print('{0:_^11}'.format('hello'))
# keyword-based 'Swaroop wrote A Byte of Python'
print('{name} wrote {book}'.format(name='Swaroop', book='A Byte of Python'))
```

Выход:

```
0.333
___hello___
Swaroop wrote A Byte of Python
```

Поскольку мы обсуждаем форматирование, обратите внимание, что `print` всегда заканчивается невидимым символом «новой строки» (`\n`), поэтому повторные вызовы `print` будут печататься на отдельной строке каждый. Чтобы предотвратить печать этого символа новой строки, вы можете указать, что он должен «заканчиваться» пробелом:

```python
print('a', end='')
print('b', end='')
```

Выход:

```
ab
```

Или вы можете закончить пробелом:

```python
print('a', end=' ')
print('b', end=' ')
print('c')
```

Выход:

```
a b c 
```
### Escape-последовательности

Предположим, вы хотите иметь строку, содержащую одинарную кавычку (`'`). Как вы укажете эту строку? Например, строка `"Как тебя зовут?"`. Вы не можете указать «Как вас зовут?», потому что Python не сможет понять, где начинается и заканчивается строка. Итак, вам придется указать, что эта одинарная кавычка не указывает на конец строки. Это можно сделать с помощью так называемой escape-последовательности. Вы указываете одинарную кавычку как `\'`: обратите внимание на обратную косую черту. Теперь вы можете указать строку как «Как вас зовут?».

Другой способ указать эту конкретную строку — «Как вас зовут?», т. е. использовать двойные кавычки. Аналогично, вам необходимо использовать escape-последовательность для использования самой двойной кавычки в строке с двойными кавычками. Кроме того, вам необходимо указать саму обратную косую черту, используя escape-последовательность `\\`.

Что, если вы хотите указать двухстрочную строку? Один из способов — использовать строку в тройных кавычках, как показано [ранее] (#triple-quotes), или вы можете использовать escape-последовательность для символа новой строки — `\n`, чтобы указать начало новой строки. Пример:

```python
'This is the first line\nThis is the second line'
```

Еще одна полезная escape-последовательность, которую следует знать, — это вкладка: `\t`. Существует еще много escape-последовательностей, но я упомянул здесь только самые полезные.

Следует отметить, что в строке одиночная обратная косая черта в конце строки указывает, что строка продолжается на следующей строке, но новая строка не добавляется. Например:

```python
"This is the first sentence. \
This is the second sentence."
```

эквивалентно

```python
"This is the first sentence. This is the second sentence."
```

### Необработанная строка

Если вам нужно указать некоторые строки, для которых не требуется специальная обработка, такая как escape-последовательности, то вам нужно указать строку _raw_, добавив к ней префикс `r` или `R`. Пример:

```python
r"Newlines are indicated by \n"
```

> **Примечание для пользователей регулярных выражений**
>
> Всегда используйте необработанные строки при работе с регулярными выражениями. В противном случае может потребоваться много обратных ударов. Например, обратные ссылки могут называться `'\\1'` или `'\\1'`.

## Переменная

Использование только буквальных констант вскоре может стать скучным — нам нужен какой-то способ хранения любой информации и манипулирования ею. Именно здесь на сцену выходят _переменные_. Переменные — это именно то, что следует из названия — их значение может варьироваться, т. е. с помощью переменной можно хранить что угодно. Переменные — это всего лишь части памяти вашего компьютера, где вы храните некоторую информацию. В отличие от литеральных констант, вам нужен какой-то метод доступа к этим переменным, и, следовательно, вы даете им имена.

## Именование идентификатора

Переменные являются примерами идентификаторов. _Идентификаторы_ — это имена, данные для идентификации _чего-то_. При именовании идентификаторов необходимо соблюдать некоторые правила:

- Первым символом идентификатора должна быть буква алфавита (прописная или строчная буква ASCII или символ Юникода) или знак подчеркивания (`_`).
- Остальная часть имени идентификатора может состоять из букв (прописных или строчных символов ASCII или символов Юникода), символов подчеркивания (`_`) или цифр (0–9).
- Имена идентификаторов чувствительны к регистру. Например, `myname` и `myName` _не_ одно и то же. Обратите внимание на строчную букву «n» в первом и прописную букву «N» во втором.
– Примеры имен _valid_ идентификаторов: `i`, `name_2_3`. Примерами имен _invalid_ идентификаторов являются `2things`, `this is outed`, `my-name` и `>a1b2_c3`.

## Типы данных

Переменные могут содержать значения разных типов, называемых _типами_ данных_. Базовыми типами являются числа и строки, о которых мы уже говорили. 
1.  **Числа**:
    -   **int**: целочисленные значения, такие как 1, 2, -3 и 0.
    -   **float**: числа с плавающей точкой, такие как 3.14, -0.5 и 2.0.
2.  **Строки**:
    -   **str**: последовательности символов, заключенные в кавычки (одинарные или двойные). Например, "Hello, World!".
3.  **Логический тип**:
    -   **bool**: может принимать только два значения: True (истина) или False (ложь). Используется для логических операций и условных выражений.
4.  **Списки**:
    -   **list**: упорядоченные коллекции элементов, которые могут иметь любой тип данных. Объявляются в квадратных скобках. Например, [1, 2, 3].
5.  **Кортежи**:
    -   **tuple**: упорядоченные неизменяемые коллекции элементов, которые могут иметь любой тип данных. Объявляются в круглых скобках. Например, (1, 2, 3).
6.  **Словари**:
    -   **dict**: неупорядоченные коллекции элементов, которые состоят из пар ключ-значение. Объявляются в фигурных скобках с использованием двоеточий для разделения ключей и значений. Например, {"name": "John", "age": 30}.
7.  **Множества**:
    -   **set**: неупорядоченные коллекции уникальных элементов. Объявляются в фигурных скобках. Например, {1, 2, 3}.
8.  **None**:
    -   **None**: специальное значение, которое представляет отсутствие или ничего. Часто используется для обозначения пустых или неинициализированных переменных.
9.  **Файлы**:
    -   **file**: тип данных, представляющий файлы на диске. Используется для работы с файловой системой и чтения/записи данных.

## Объект

Помните, Python относится ко всему, что используется в программе, как к _объекту_. Имеется в виду в общем смысле. Вместо того, чтобы говорить «что-то», мы говорим «объект».

> **Примечание для пользователей объектно-ориентированного программирования**:
>
> Python сильно объектно-ориентирован в том смысле, что все является объектом, включая числа, строки и функции.

Теперь мы увидим, как использовать переменные вместе с литеральными константами. Сохраните следующий пример и запустите программу.

## Как писать программы на Python

Отныне стандартная процедура сохранения и запуска программы Python выглядит следующим образом:

### Для PyCharm

1. Откройте PyCharm.
2. Создайте новый файл с указанным именем.
3. Введите код программы, указанный в примере.
4. Щелкните правой кнопкой мыши и запустите текущий файл.

### Для других редакторов

1. Откройте выбранный вами редактор.
2. Введите код программы, указанный в примере.
3. Сохраните его как файл с указанным именем.
4. Запустите интерпретатор с помощью команды `python program.py`, чтобы запустить программу.

### Пример: использование переменных и литеральных констант

Введите и запустите следующую программу:

```python
# Filename : var.py
i = 5
print(i)
i = i + 1
print(i)

s = '''This is a multi-line string.
This is the second line.'''
print(s)
```


Выход:

```
5
6
This is a multi-line string.
This is the second line.
```

**Как это работает**

Вот как работает эта программа. Сначала мы присваиваем буквальное константное значение `5` переменной `i` с помощью оператора присваивания (`=`). Эта строка называется оператором, поскольку в ней говорится, что что-то должно быть сделано, и в этом случае мы связываем имя переменной `i` со значением `5`. Затем мы печатаем значение `i`, используя оператор `print`, который, что неудивительно, просто выводит значение переменной на экран.

Затем мы добавляем «1» к значению, хранящемуся в «i», и сохраняем его обратно. Затем мы распечатываем его и, как и ожидалось, получаем значение «6».

Аналогичным образом мы присваиваем литеральную строку переменной `s` и затем печатаем ее.

> **Примечание для программистов на статических языках**
>
> Переменные используются путем простого присвоения им значения. Никакое объявление или определение типа данных не требуется/не используется.

## Логическая и физическая линия

Физическая линия — это то, что вы _видите_ при написании программы. Логическая линия — это то, что _Python_ воспринимает_ как один оператор. Python неявно предполагает, что каждая _физическая линия_ соответствует _логической линии_.

Примером логической строки является оператор типа `print('hello world')` — если он находился в отдельной строке (как вы видите ее в редакторе), то это также соответствует физической строке.

Неявно Python поощряет использование одного оператора в каждой строке, что делает код более читабельным.

Если вы хотите указать более одной логической строки в одной физической строке, вам необходимо явно указать это, используя точку с запятой (`;`), которая указывает на конец логической строки/оператора. Например:

```python
i = 5
print(i)
```

фактически то же самое, что

```python
i = 5;
print(i);
```

что также то же самое, что

```python
i = 5; print(i);
```

и то же, что

```python
i = 5; print(i)
```

Тем не менее, я *настоятельно рекомендую* придерживаться *записывания максимум одной логической строки на каждой физической линии*. Идея состоит в том, что вы никогда не должны использовать точку с запятой. На самом деле, я _никогда_ не использовал и даже не видел точку с запятой в программах на Python.

Есть одна ситуация, когда эта концепция действительно полезна: если у вас длинная строка кода, вы можете разбить ее на несколько физических строк, используя обратную косую черту. Это называется _явным соединением строк_:

```python
s = 'This is a string. \
This continues the string.'
print(s)
```

Выход:

```
This is a string. This continues the string.
```

Сходным образом,

```python
i = \
5
```

такой же как

```python
i = 5
```

Иногда существует неявное предположение, что вам не нужно использовать обратную косую черту. Это тот случай, когда логическая строка имеет начальные круглые скобки, начальные квадратные скобки или начальные фигурные скобки, но не имеет завершающей. Это называется *неявное соединение строк*. Вы можете увидеть это в действии, когда мы будем писать программы, используя list.

## Отступ

Пробелы важны в Python. На самом деле *пробелы в начале строки важны*. Это называется _отступ_. Ведущие пробелы (пробелы и табуляции) в начале логической строки используются для определения уровня отступа логической строки, который, в свою очередь, используется для определения группировки операторов.

Это означает, что операторы, которые идут вместе, _должны_ иметь одинаковый отступ. Каждый такой набор операторов называется *блоком*. В последующих главах мы увидим примеры важности блоков.

Вам следует помнить одну вещь: неправильный отступ может привести к ошибкам. Например:

```python
i = 5
# Error below! Notice a single space at the start of the line
 print('Value is', i)
print('I repeat, the value is', i)
```

Когда вы запустите это, вы получите следующую ошибку:

```
  File "whitespace.py", line 3
    print('Value is', i)
    ^
IndentationError: unexpected indent
```

Обратите внимание, что в начале второй строки стоит один пробел. Ошибка, указанная Python, говорит нам, что синтаксис программы


**Как это работает**

Вот как работает эта программа. Сначала мы присваиваем буквальное константное значение `5` переменной `i` с помощью оператора присваивания (`=`). Эта строка называется оператором, поскольку в ней говорится, что что-то должно быть сделано, и в этом случае мы связываем имя переменной `i` со значением `5`. Затем мы печатаем значение `i`, используя оператор `print`, который, что неудивительно, просто выводит значение переменной на экран.

Затем мы добавляем «1» к значению, хранящемуся в «i», и сохраняем его обратно. Затем мы распечатываем его и, как и ожидалось, получаем значение «6».

Аналогичным образом мы присваиваем литеральную строку переменной `s` и затем печатаем ее.

> **Примечание для программистов на статических языках**
>
> Переменные используются путем простого присвоения им значения. Никакое объявление или определение типа данных не требуется/не используется.


# Операторы и выражения

---

Большинство операторов (логических строк), которые вы пишете, будут содержать _выражения_. Простой пример выражения: `2 + 3`. Выражение можно разбить на операторы и операнды.

_Операторы_ — это функциональные возможности, которые что-то делают и могут быть представлены такими символами, как `+`, или специальными ключевыми словами. Операторам для работы требуются некоторые данные, и такие данные называются _операндами_. В данном случае операндами являются `2` и `3`.

## Операторы

Мы кратко рассмотрим операторы и их использование.

Обратите внимание, что вы можете вычислять выражения, приведенные в примерах, используя интерпретатор в интерактивном режиме. Например, чтобы проверить выражение `2 + 3`, используйте интерактивную подсказку интерпретатора Python:

```python
>>> 2 + 3
5
>>> 3 * 5
15
>>>
```

Вот краткий обзор доступных операторов:

- `+` (плюс)
     - Добавляет два объекта
     - `3 + 5` дает `8`. `'a' + 'b'` дает `'ab'`.

- `-` (минус)
     - Дает вычитание одного числа из другого; если первый операнд отсутствует, он считается равным нулю.
     - `-5.2` дает отрицательное число, а `50 - 24` дает `26`.

- `*` (умножить)
     - Дает умножение двух чисел или возвращает строку, повторенную столько раз.
     - `2 * 3` дает `6`. `'la' * 3` дает `'лалала'`.

- `**` (сила)
     - Возвращает x в степени y
     - `3 ** 4` дает `81` (т.е. `3 * 3 * 3 * 3`)

- `/` (разделить)
     - Разделить х на у
     - `13 / 3` дает `4.333333333333333`

- `//` (разделить и перекрыть)
     - Разделите x на y и округлите ответ _вниз_ до ближайшего целого значения. Обратите внимание: если одно из значений является числом с плавающей запятой, вы получите обратно число с плавающей запятой.
     - `13 // 3` дает `4`
     - `-13 // 3` дает `-5`
     - `9//1.81` дает `4.0`

- `%` (по модулю)
     - Возвращает остаток деления
     - `13 % 3` дает `1`. `-25,5 % 2,25` дает `1,5`.

- `<<` (сдвиг влево)
     - Сдвигает биты числа влево на указанное количество бит. (Каждое число представлено в памяти битами или двоичными цифрами, т.е. 0 и 1)
     - `2 << 2` дает `8`. «2» представлено «10» в битах.
     - Сдвиг влево на 2 бита дает «1000», что представляет собой десятичную цифру «8».

- `>>` (сдвиг вправо)
     - Сдвигает биты числа вправо на указанное количество бит.
     - `11 >> 1` дает `5`.
     - `11` представлено в битах как `1011`, что при сдвиге вправо на 1 бит дает `101`, что представляет собой десятичное число `5`.

- `&` (побитовое И)
     - Побитовое И чисел: если оба бита равны «1», результат равен «1». В противном случае это `0`.
     - `5 и 3` дают `1` (`0101 и 0011` дают `0001`)
    
- `|` (побитовое ИЛИ)
     - Побитовое ИЛИ чисел: если оба бита равны «0», результат равен «0». В противном случае это `1`.
     - `5 | 3` дает `7` (`0101 | 0011` дает `0111`)
    
- `^` (побитовое исключающее ИЛИ)
     - Побитовое исключающее ИЛИ чисел: если оба бита (`1 или 0`) одинаковы, результатом будет `0`. В противном случае это `1`.
     - `5 ^ 3` дает `6` (`O101 ^ 0011` дает `0110`)

- `~` (побитовое инвертирование)
     - Побитовая инверсия x равна -(x+1)
     - `~5` дает `-6`. Более подробную информацию можно найти по адресу http://stackoverflow.com/a/11810203.

- `<` (меньше чем)
     - Возвращает, меньше ли x, чем y. Все операторы сравнения возвращают True или False. Обратите внимание на написание этих имен с заглавной буквы.
     - `5 < 3` дает `False`, а `3 < 5` дает `True`.
     - Сравнения можно объединять в произвольную цепочку: `3 < 5 < 7` дает `True`.

- `>` (больше чем)
     - Возвращает, больше ли x, чем y
     - `5 > 3` возвращает `True`. Если оба операнда являются числами, они сначала преобразуются к общему типу. В противном случае он всегда возвращает «False».

- `<=` (меньше или равно)
     - Возвращает, меньше ли x или равно y
     - `х = 3; у = 6; x <= y` возвращает `True`

- `>=` (больше или равно)
     - Возвращает, больше ли x или равно y
     - `х = 4; у = 3; x >= 3` возвращает `True`

- `==` (равно)
     - Сравнивает, равны ли объекты
     - `х = 2; у = 2; x == y` возвращает `True`
     - `х = 'ул'; у = 'стР'; x == y` возвращает `False`
     - `х = 'ул'; у = 'ул'; x == y` возвращает `True`

- `!=` (не равно)
     - Сравнивает, если объекты не равны
     - `х = 2; у = 3; x != y` возвращает `True`

- `не` (логическое НЕ)
     - Если x имеет значение «True», он возвращает «False». Если x имеет значение «False», он возвращает «True».
     - `х = Истина; not x` возвращает `False`.

- `и` (логическое И)
     - `x и y` возвращает `False`, если x имеет значение `False`, иначе возвращается оценка y.
     - `х = Ложь; у = Истина; x и y` возвращает `False`, поскольку x имеет значение False. В этом случае Python не будет вычислять y, поскольку он знает, что левая часть выражения «и» равна «False», что означает, что все выражение будет «False» независимо от других значений. Это называется оценкой короткого замыкания.

- `или` (логическое ИЛИ)
     - Если x равно True, возвращается True, в противном случае возвращается оценка y.
     - `х = Истина; у = Ложь; x или y` возвращает `True`. Здесь также применима оценка короткого замыкания.

## Ярлык для математических операций и присваиваний

Обычно выполняется математическая операция над переменной, а затем

```python
a = 2
a = a * 3
```

можно записать как:

```python
a = 2
a *= 3
```
запишите результат операции обратно в переменную, поэтому для таких выражений существует ярлык:

```python
а = 2
а = а * 3
```

можно записать как:

```python
а = 2
а *= 3
```

Обратите внимание, что `var = выражение операции var` становится `выражением операции var=`.

## Порядок оценки

Если у вас есть такое выражение, как «2 + 3 * 4», сначала выполняется сложение или умножение? Наша школьная математика говорит нам, что сначала нужно выполнить умножение. Это означает, что оператор умножения имеет более высокий приоритет, чем оператор сложения.

В следующей таблице представлена таблица приоритетов для Python: от наименьшего приоритета (наименьшее связывание) до самого высокого приоритета (наибольшее связывание). Это означает, что в данном выражении Python сначала вычисляет операторы и выражения, расположенные ниже в таблице, а затем те, которые перечислены в таблице выше.

Следующая таблица, взятая из [Справочного руководства по Python](http://docs.python.org/3/reference/expressions.html#operator-precedence), представлена для полноты картины. Гораздо лучше использовать круглые скобки для правильной группировки операторов и операндов и явного указания приоритета. Это делает программу более читабельной.

- `lambda`: лямбда-выражение
- `if - else`: условное выражение.
- `или`: логическое ИЛИ
- `и`: логическое И
- `не x`: логическое НЕ
- `in, not in, is, is not, <, <=, >, >=, !=, ==` : Сравнения, включая тесты на членство и тесты на идентичность.
- `|`: побитовое ИЛИ
- `^` : побитовое исключающее ИЛИ
- `&` : побитовое И
- `<<, >>` : сдвиги
- `+, -`: сложение и вычитание.
- `*, /, //, %`: умножение, деление, деление нижнего уровня и остаток.
- `+x, -x, ~x`: положительное, отрицательное, побитовое НЕ.
- `**` : Возведение в степень
- `x[index], x[index:index], x(arguments...), x.attribute`: подписка, нарезка, вызов, ссылка на атрибут.
- `(выражения...), [выражения...], {ключ: значение...}, {выражения...}` : отображение привязки или кортежа, отображение списка, отображение словаря, отображение набора

Операторы, с которыми мы еще не сталкивались, будут объяснены в последующих главах.

Операторы с _одним и тем же приоритетом_ перечислены в одной строке приведенной выше таблицы. Например, `+` и `-` имеют одинаковый приоритет.

## Изменение порядка оценки

Чтобы сделать выражения более читабельными, мы можем использовать круглые скобки. Например, `2 + (3 * 4)` определенно легче понять, чем `2 + 3 * 4`, для которого требуется знание приоритета операторов. Как и во всем остальном, круглые скобки следует использовать разумно (не переусердствовать) и не должны быть избыточными, как в `(2 + (3 * 4))`.

У использования круглых скобок есть дополнительное преимущество — они помогают нам изменить порядок вычислений. Например, если вы хотите, чтобы в выражении вычислялось сложение перед умножением, вы можете написать что-то вроде `(2 + 3) * 4`.

## Ассоциативность

Операторы обычно связаны слева направо. Это означает, что операторы с одинаковым приоритетом оцениваются слева направо. Например, `2 + 3 + 4` оценивается как `(2 + 3) + 4`.

## Выражения

Пример:

```python
lengthlength = 5
breadth = 2

area = length * breadth
print('Area is', area)
print('Perimeter is', 2 * (length + breadth))
```

Выход:

```
$ python expression.py
Area is 10
Perimeter is 14
```

**Как это работает**

Длина и ширина прямоугольника хранятся в одноименных переменных. Мы используем их для вычисления площади и периметра прямоугольника с помощью выражений. Мы сохраняем результат выражения `длина * ширина` в переменной `area`, а затем печатаем его с помощью функции `print`. Во втором случае мы напрямую используем значение выражения `2 * (длина + ширина)` в функции печати.

Также обратите внимание, как Python _красиво_ печатает_ выходные данные. Несмотря на то, что мы не указали пробел между «Area is» и переменной «area», Python помещает его за нас, чтобы мы получили чистый и приятный результат, и в этом случае программа стала гораздо более читабельной (поскольку мы не нужно беспокоиться о пробелах в строках, которые мы используем для вывода). Это пример того, как Python облегчает жизнь программисту.


# Поток управления
---

В программах, которые мы видели до сих пор, всегда присутствовал ряд операторов, добросовестно выполняемых Python в точном порядке сверху вниз. Что, если вы хотите изменить ход работы? Например, вы хотите, чтобы программа принимала некоторые решения и выполняла разные действия в зависимости от различных ситуаций, например, печатала «Доброе утро» или «Добрый вечер» в зависимости от времени суток?

Как вы уже могли догадаться, это достигается с помощью операторов потока управления. В Python есть три оператора потока управления — if, for и while.

## Оператор `if`

Оператор `if` используется для проверки условия: *если* условие истинно, мы запускаем блок операторов (называемый _if-block_), *иначе* мы обрабатываем другой блок операторов (называемый _else-block_) . Предложение *else* является необязательным.

Пример:

```python
number = 23
guess = int(input('Enter an integer : '))

if guess == number:
    # New block starts here
    print('Congratulations, you guessed it.')
    print('(but you do not win any prizes!)')
    # New block ends here
elif guess < number:
    # Another block
    print('No, it is a little higher than that')
    # You can do whatever you want in a block ...
else:
    print('No, it is a little lower than that')
    # you must have guessed > number to reach here

print('Done')
# This last statement is always executed,
# after the if statement is executed.
```

Выход:

```bash
$ python if.py
Enter an integer : 50
No, it is a little lower than that
Done

$ python if.py
Enter an integer : 22
No, it is a little higher than that
Done

$ python if.py
Enter an integer : 23
Congratulations, you guessed it.
(but you do not win any prizes!)
Done
```

**Как это работает**

В этой программе мы принимаем предположения пользователя и проверяем, соответствует ли это число тому, что у нас есть. Мы присваиваем переменной `number` любое целое число, которое нам нужно, например `23`. Затем мы принимаем предположение пользователя, используя функцию input(). Функции — это просто повторно используемые фрагменты программ.

Мы передаем строку встроенной функции input, которая выводит ее на экран и ждет ввода от пользователя. Как только мы вводим что-то и нажимаем клавишу kbd:[enter], функция input() возвращает то, что мы ввели, в виде строки. Затем мы преобразуем эту строку в целое число, используя int, а затем сохраняем ее в переменной Guess. На самом деле, `int` — это класс, но все, что вам нужно знать прямо сейчас, это то, что вы можете использовать его для преобразования строки в целое число (при условии, что строка содержит допустимое целое число в тексте).

Далее мы сравниваем предположение пользователя с выбранным нами числом. Если они равны, мы печатаем сообщение об успехе. Обратите внимание, что мы используем уровни отступов, чтобы сообщить Python, какие операторы к какому блоку относятся. Вот почему отступы так важны в Python. Надеюсь, вы придерживаетесь правила «последовательных отступов». Ты?

Обратите внимание, что оператор if содержит двоеточие в конце — мы указываем Python, что за ним следует блок операторов.

Затем мы проверяем, меньше ли предположение числа, и если да, то сообщаем пользователю, что он должен угадать немного больше этого числа. Здесь мы использовали предложение elif, которое фактически объединяет два связанных оператора if else-if else в один объединенный оператор if-elif-else. Это упрощает программу и уменьшает количество необходимых отступов.

Операторы `elif` и `else` также должны иметь двоеточие в конце логической строки, за которым следует соответствующий блок операторов (конечно, с правильными отступами).

Вы можете иметь еще один оператор if внутри блока if оператора if и т. д. — это называется вложенным оператором if.

Помните, что части elif и else не являются обязательными. Минимально допустимый оператор `if`:

```python
if True:
     print('Да, это правда')
```

После того, как Python завершил выполнение полного оператора if вместе со связанными с ним предложениями elif и else, он переходит к следующему оператору в блоке, содержащем оператор if. В данном случае это основной блок (с которого начинается выполнение программы), а следующим оператором является оператор print('Done')`. После этого Python видит конец программы и просто завершает ее.

Несмотря на то, что это очень простая программа, я указал на множество вещей, на которые вам следует обратить внимание. Все это довольно просто (и удивительно просто для тех из вас, кто имеет опыт работы с C/C++). Сначала вам нужно будет осознать все эти вещи, но после некоторой практики вы освоитесь с ними, и все это будет казаться вам «естественным».

> **Примечание для программистов C/C++**
>
> В Python нет оператора `switch`. Вы можете использовать оператор `if..elif..else`, чтобы сделать то же самое.

## Оператор while

Оператор while позволяет многократно выполнять блок операторов, пока условие истинно. Оператор while — это пример того, что называется оператором *цикла*. Оператор while может иметь необязательное предложение else.

Пример:

```python
number = 23
running = True

while running:
    guess = int(input('Enter an integer : '))

    if guess == number:
        print('Congratulations, you guessed it.')
        # this causes the while loop to stop
        running = False
    elif guess < number:
        print('No, it is a little higher than that.')
    else:
        print('No, it is a little lower than that.')
else:
    print('The while loop is over.')
    # Do anything else you want to do here

print('Done')
```

Выход:

```
$ python while.py
Enter an integer : 50
No, it is a little lower than that.
Enter an integer : 22
No, it is a little higher than that.
Enter an integer : 23
Congratulations, you guessed it.
The while loop is over.
Done
```

**Как это работает**

В этой программе мы по-прежнему играем в угадайку, но преимущество состоит в том, что пользователю разрешено продолжать гадать до тех пор, пока он не угадает правильно — нет необходимости повторно запускать программу для каждого предположения, как мы делали в предыдущем разделе. . Это подходит# Поток управления {#control-flow}

В программах, которые мы видели до сих пор, всегда присутствовал ряд операторов, добросовестно выполняемых Python в точном порядке сверху вниз. Что, если вы хотите изменить ход работы? Например, вы хотите, чтобы программа принимала некоторые решения и выполняла разные действия в зависимости от различных ситуаций, например, печатала «Доброе утро» или «Добрый вечер» в зависимости от времени суток?

Как вы уже могли догадаться, это достигается с помощью операторов потока управления. В Python есть три оператора потока управления — if, for и while.



## Цикл `for`

Оператор `for..in` — это еще один оператор цикла, который *перебирает* последовательность объектов, т. е. проходит через каждый элемент в последовательности. Что вам нужно знать прямо сейчас, так это то, что последовательность — это просто упорядоченный набор элементов.

Пример:

```python
for i in range(1, 5):
    print(i)
else:
    print('The for loop is over')
```

Выход:

```bash
$ python for.py
1
2
3
4
The for loop is over
```

**Как это работает**

В этой программе мы печатаем *последовательность* чисел. Мы генерируем эту последовательность чисел с помощью встроенной функции range.

Здесь мы указываем два числа, а `range` возвращает последовательность чисел, начиная с первого числа и заканчивая вторым числом. Например, диапазон (1,5) дает последовательность «[1, 2, 3, 4]». По умолчанию «диапазон» принимает количество шагов, равное 1. Если мы предоставим третье число для «диапазона», то оно станет счетчиком шагов. Например, `range(1,5,2)` дает `[1,3]`. Помните, что диапазон простирается *до* второго числа, т. е. он *не* включает второе число.

Обратите внимание, что `range()` генерирует только одно число за раз. Если вам нужен полный список чисел, вызовите `list()` в `range()`, например, `list(range(5))` приведет к `[0, 1, 2, 3, 4]`.

Затем цикл for проходит по этому диапазону: `for i in range(1,5)` эквивалентен циклу `for i in [1, 2, 3, 4]`, что похоже на присвоение каждого числа (или объекта) в последовательность для i, по одному, а затем выполнение блока операторов для каждого значения `i`. В этом случае мы просто печатаем значение в блоке операторов.

Помните, что часть else не является обязательной. Если он включен, он всегда выполняется один раз после завершения цикла for, если не встречается оператор `break`.

Помните, что цикл for..in работает для любой последовательности. Здесь у нас есть список чисел, сгенерированный встроенной функцией range, но в целом мы можем использовать любую последовательность любых объектов! Мы подробно рассмотрим эту идею в последующих главах.

> **Примечание для программистов C/C++/Java/C#**
>
> Цикл for Python радикально отличается от цикла for C/C++. Программисты C# заметят, что цикл for в Python аналогичен циклу foreach в C#. Java-программисты заметят, что это похоже на `for (int i : IntArray)` в Java 1.5.
>
> В C/C++, если вы хотите написать «for (int i = 0; i < 5; i++)», то в Python вы пишете просто «for i in range(0,5)». Как видите, цикл for в Python проще, выразительнее и менее подвержен ошибкам.

## Оператор прерывания

Оператор `break` используется для *выхода* из оператора цикла, т.е. остановки выполнения оператора цикла, даже если условие цикла не стало `False` или последовательность элементов не была полностью перебрана.

Важное замечание: если вы *выходите* из цикла for или while, любой соответствующий блок цикла else **не** выполняется.

Пример:

```python
while True:
    s = input('Enter something : ')
    if s == 'quit':
        break
    print('Length of the string is', len(s))
print('Done')
```

Выход:

```python
$ python break.py
Enter something : Programming is fun
Length of the string is 18
Enter something : When the work is done
Length of the string is 21
Enter something : if you wanna make your work also fun:
Length of the string is 37
Enter something : use Python!
Length of the string is 11
Enter something : quit
Done
```

**Как это работает**

В этой программе мы неоднократно берем вводимые пользователем данные и каждый раз печатаем длину каждого ввода.
время. Мы предоставляем специальное условие для остановки программы, проверяя, верен ли ввод пользователя.
Мы останавливаем программу, *выходя* из цикла и достигая конца программы.

Длину входной строки можно узнать с помощью встроенной функции len.

Помните, что оператор «break» также может использоваться с циклом «for».


## Оператор `continue`

Оператор `continue` используется, чтобы сообщить Python о необходимости пропустить остальные операторы в текущем блоке цикла и *продолжить* переход к следующей итерации цикла.

Пример:

```python
while True:
    s = input('Enter something : ')
    if s == 'quit':
        break
    if len(s) < 3:
        print('Too small')
        continue
    print('Input is of sufficient length')
    # Do other kinds of processing here...
```

Выход:

```bash
$ python continue.py
Enter something : a
Too small
Enter something : 12
Too small
Enter something : abc
Input is of sufficient length
Enter something : quit
```

**Как это работает**

В этой программе мы принимаем ввод от пользователя, но обрабатываем входную строку, только если она имеет длину не менее 3 символов. Итак, мы используем встроенную функцию `len` для получения длины, и если длина меньше 3, мы пропускаем остальные операторы в блоке, используя оператор continue. В противном случае выполняются остальные операторы цикла, выполняя любую обработку, которую мы хотим здесь выполнить.

Обратите внимание, что оператор `continue` работает и с циклом `for`.

# Взаимодействи с операционной системой


1.  В Python вы можете использовать модуль  `os`  для выполнения команд операционной системы. Этот модуль предоставляет множество функций для работы с файловой системой, процессами и другими аспектами операционной системы.
    
2.  Чтобы выполнить команду операционной системы, вы можете использовать функцию  `os.system(command)`. Эта функция принимает строку  `command`, которая представляет собой команду операционной системы, и выполняет эту команду в командной оболочке, возвращая код завершения команды.
    
    Например, чтобы выполнить команду  `ls`  в Unix-подобной системе, вы можете написать:
    
    ```python
    import os
    os.system("ls")  
    ```
    
    Это вызовет команду  `ls`  и отобразит список файлов и каталогов в текущем каталоге.
    
3.  Вы также можете использовать функцию  `os.popen(command)`  для выполнения команд операционной системы и получения вывода команды в виде потока данных. Эта функция возвращает объект, который можно использовать для чтения вывода команды.
    
    Например, чтобы выполнить команду  `ls`  и получить список файлов и каталогов в виде потока данных, вы можете написать:
    
    ```python
    import os
    output = os.popen("ls")
    print(output.read())
    ```
    
    Это выполнит команду  `ls`  и выведет ее вывод на экран.
    
4.  Кроме того, вы можете вызывать уже обработанные скрипты из Python. Если у вас есть скрипт на другом языке программирования (например, на Bash), вы можете вызывать его из Python, аналогично вызову команды операционной системы.
    
    Например, если у вас есть скрипт с именем  `script.sh`, записанный на Bash, и вы хотите его выполнить из Python, вы можете написать:
    
    ```python
    import os
    os.system("./script.sh")
    ```
    
    Здесь  `./script.sh`  - это команда для выполнения скрипта. Вы должны обратить внимание, что ваш скрипт должен быть исполняемым и иметь права исполнения.
    
5.  Кроме функций  `os.system`  и  `os.popen`, модуль  `os`  также предоставляет другие функции для работы с файловой системой, создания и удаления каталогов, изменения прав доступа к файлам и другим взаимодействием с операционной системой. Вы можете изучить документацию модуля  `os`  для получения дополнительной информации о доступных функциях.

 В Python, когда вы выполняете команды операционной системы с помощью функции  `os.system(command)`  или  `os.popen(command)`, вы можете получить вывод этой команды в виде строки.
    
Чтобы получить результат выполнения команды в виде строки, вы можете использовать следующие методы:
    
```python
    import os
    # Использование функции os.system()
    output = os.popen("command").read()
    # Использование функции os.popen()
    output = os.popen("command").read()
```
    
В обоих случаях,  `output`  будет содержать вывод команды в виде строки.
    
Если вы хотите разделить вывод команды на отдельные строки, вы можете использовать метод  `splitlines()`  на полученной строке:
    
```python
    lines = output.splitlines()
```
  
В результате  `lines`  будет содержать список строк, разделенных по строкам вывода команды.
    
Если вы хотите обработать каждую строку вывода по отдельности, вы можете использовать цикл  `for`:
    
```python
    for line in lines:
        # Обработка каждой строки
        print(line)
```
    
В этом примере, каждая строка вывода будет обрабатываться по очереди.
    
5.  Если вам нужно получить только определенные данные из вывода команды, вы можете использовать методы работы со строками, такие как  `split()`  или регулярные выражения.
    
    Например, если вывод команды является простым списком файлов и вы хотите получить только имена файлов, вы можете использовать следующий код:
    
    ```python
    import os
    output = os.popen("ls").read()
    lines = output.splitlines()
    for line in lines:
        filename = line.split()[-1]  # Получить последнее слово в строке (имя файла)
        print(filename)
    
    ```
    
    В этом примере, мы используем метод  `split()`  для разделения каждой строки на отдельные слова, а затем выбираем последнее слово в каждой строке.
---
Задания : [[computer science/chapter4/task]]
