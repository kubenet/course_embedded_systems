#computer_science #python #practice 
# Курс: Информатика
# Практическое занятие. "Основы информатики"

## 1. Векторы
Написать две функции, которые получают два списка длиной 3, представляющих трехмерные векторы $a$ и $b$, вычисляют скалярное произведение $a ∙ b$ и векторное произведение $a × b$.
Написать еще две функции, возвращающие скалярное смешанное произведение $a ∙ (b ∙ c)$ и векторное смешанное произведение $a × (b × c)$.

## 2. Кто держит зебру?
Без лишних слов перейдем к решению задачи. Вам даны 15 подсказок и два вопроса:
- Имеется пять домов.
- Англичанин живет в красном доме.
- Испанец владеет собакой.
- В зеленом доме пьют кофе.
- Украинец пьет чай.
- Зеленый дом находится сразу справа от дома из слоновой кости.
- Курильщик старого золота владеет улитками.
-  В желтом доме курят "Кулс".
- В среднем доме пьют молоко.
- Норвежец живет в первом доме.
- Человек, который курит Chesterfields, живет в доме рядом с человеком с лисой.
- В доме рядом с домом, где держат лошадь, курят "Кулс".
- Курильщик Lucky Strike пьет апельсиновый сок.
- Японец курит "Парламент".
- Норвежец живет рядом с синим домом.

**Кто пьет воду? Кому принадлежит зебра?**

## 3. Тетрация
Тетрация (tetration) определяется как следующий гипероператор (гипероператор-4) после возведения в степень. Таким образом, операцию $x × n$ можно записать в виде суммы $x + x + x + … + x$ с $n$ слагаемыми, операцию $xn$ – в виде произведения n сомножителей x + x + x + … + x, а выражение, записанное в форме nx, равнозначно повторяющемуся возведению в степень, включающему n вхождений $x$:
$${^{n}x}=x^{x^{.^{x}}}$$
Например, ${^{4}2}=2^{2^{2^{2}}}=2^{2^{4}}=2^{16}=65536$
Следует отметить, что степенная башня вычисляется сверху вниз. Написать рекурсивную функцию для вычисления nx и протестировать ее (для небольших положительных действительных значений x и неотрицательных целых $n$, потому что тетрация генерирует очень большие числа). Из скольких цифр состоят числа ${^{3}5}$ и ${^{5}2}$?

## 4. Резистор
5(резисторов) определяются по четырем цветовым полоскам: первые две обозначают первые две значимые цифры электрического сопротивления в омах, третья полоска обозначает десятичный множитель (число нулей), а четвертая – допустимое отклонение от номинала. Цвета и их значения для каждой полоски перечислены в таблице.

| Цвет      | Сокращенное обозначение | Значимые цифры | Множитель | Допустимое отклонение |
| --------- | ----------------------- | -------------- | --------- | --------------------- |
| Черный | bk                      | 0              | $1$    | -                     |
| Коричневый | br                      | 1              | $10$    | $\pm1$                     |
| Красный | rd                      | 2              | $10^2$    | $\pm2$                     |
| Оранжевый | or                      | 3              | $10^2$    | -                     |
| Желтый          | yl                         | 4                | $10^4$           | $\pm5$% |
| Зеленый          | gr                         | 5                | $10^5$           | $\pm0.5$% |
| Синий          | bl                         | 6                | $10^6$           | $\pm0.25$% |
| Фиолетовый          | vi                         | 7                | $10^7$           | $\pm0.1$% |
| Серый          | gy                         | 8                | $10^8$           | $\pm0.05$% |
| Белый          | wh                         | 9                | $10^9$           | - |
| Золотой          | au                         | -                |  -        | $\pm5$% |
| Серебряный          | ag                         | -                | -           | $\pm10$% |
| Нет          | -                         | -                |  -          | $\pm20$% |

Например, для резистора с полосками следующих цветов: фиолетовая, желтая, красная, зеленая – значение сопротивления равно $74 × 102 = 7400$ Ω, а допустимое отклонение от номинала составляет $±0.5$ %.
Написать программу, в которой определяется функция преобразования списка из четырех сокращенных обозначений цветов (полосок) в значение сопротивления и допустимое отклонение. Например:
```
# In
print(get_resistor_value(['br', 'bk', 'yl', 'ag']))
print(get_resistor_value(['yl', 'vi', 'rd', 'au']))
print(get_resistor_value(['vi', 'yl', 'rd', 'gr']))
print(get_resistor_value(['ws', 'yl', 'rd', 'rd']))
print(get_resistor_value(['vi', 'yl', 'rd']))
```
```
# Out
(100000, 10)
(4700, 5)
(7400, 0.5)
Unidentified or invalid band colour in bands: ['ws', 'yl', 'rd', 'rd']
(None, None)
Fewer than four colours provided in bands: ['vi', 'yl', 'rd']
(None, None)
```
## 5. Морзе
Использовать словарь кодов азбуки Морзе из `data/morse.py`, размещенного здесь: , чтобы написать программу преобразования текстового сообщения в код Морзе и обратно. Использовать пробелы для разделения отдельных «букв» кода Морзе, а символ слеш (/) – для разделения слов. Например, 'PYTHON 3' преобразовывается в ``'.-. -.- - .... - -. / ...-'.
## 6. Baby Shark
Файл data/shark-species.txt, содержит список существующих видов акул, организованный в иерархической форме: семейство, род и вид (вид представлен в форме «биологическое название: общее название»). Выполнить считывание содержимого этого файла в структуру данных, состоящую из вложенных словарей, доступ к которым можно осуществлять следующим образом:
```python
>>> sharks['Lamniformes']['Lamnidae']['Carcharodon']['C. carcharias']
Great white shark
```
## 7. Поиск степени делителя факториала

Даны два числа $n$ и $k$. Найдите наибольшую степень $x$ такого, что $n!$ делится на $k^x$.

### Простой $k$

Рассмотрим случай, когда $k$ является простым числом. Явное выражение для факториала:

$$n! = 1 \cdot 2 \cdot 3 \ldots (n-1) \cdot n$$

Обратите внимание, что каждый $k$-й элемент произведения делится на $k$, т.е. добавляет $+1$ к ответу; количество таких элементов равно $\Bigl\lfloor\dfrac{n}{k}\Bigr\rfloor$.

Далее, каждый $k^2$-й элемент делится на $k^2$, т.е. добавляет еще $+1$ к ответу (первая степень $k$ уже была учтена в предыдущем абзаце). Количество таких элементов равно $\Bigl\lfloor\dfrac{n}{k^2}\Bigr\rfloor$.

И так далее, для каждого $i$ каждый $k^i$-й элемент добавляет еще $+1$ к ответу, и таких элементов $\Bigl\lfloor\dfrac{n}{k^i}\Bigr\rfloor$.

Окончательный ответ:

$$\Bigl\lfloor\dfrac{n}{k}\Bigr\rfloor + \Bigl\lfloor\dfrac{n}{k^2}\Bigr\rfloor + \ldots + \Bigl\lfloor\dfrac{n}{k^i}\Bigr\rfloor + \ldots$$

Этот результат также известен как [Формула Лежандра](https://en.wikipedia.org/wiki/Legendre%27s_formula). Сумма, конечно, конечна, так как только примерно первые $\log_k n$ элементов не равны нулю. Таким образом, время работы этого алгоритма составляет $O(\log_k n)$.

### Пример
- $n = 10$: Мы ищем степень делителя факториала $10!$.
- $k = 2$: Мы ищем наибольшую степень $x$ такую, что $10!$ делится на $2^x$.

Наибольшая степень $x$, такая что $10!$ делится на $2^x$.

Для $n = 10$ и $k = 2$ мы вычисляем:

- $\left\lfloor \frac{10}{2} \right\rfloor = 5$
- $\left\lfloor \frac{10}{4} \right\rfloor = 2$
- $\left\lfloor \frac{10}{8} \right\rfloor = 1$

Суммируем все значения:

$$5 + 2 + 1 = 8$$

Таким образом, $10!$ делится на $2^8$.

## 8. Поиск наименьшего положительного целого числа

Даны два последовательных целых числа $k_1$ и $k_2$, где $k_2 = k_1 + 1$.

Необходимо вычислить наименьшее строго положительное целое число $n$, такое что значения $n \cdot k_1$ и $n \cdot k_2$ содержат одни и те же цифры, но в различном порядке.

### Примеры:

**Пример 1:**

- $k_1 = 100$
- $k_2 = 101$
- $n = 8919$

Поскольку:

- $8919 \cdot 100 = 891900$ 
- $8919 \cdot 101 = 900819$

**Пример 2:**

- $k_1 = 325$
- $k_2 = 326$
- $n = 477$

Поскольку:

- $477 \cdot 325 = 155025$
- $477 \cdot 326 = 155502$

### Задача

Ваша задача — подготовить функцию, которая будет принимать значение $k_1$ и выводить значение $n$.

Примеры использования функции:

```python
find_lowest_int(100)  # должно вернуть 8919
find_lowest_int(325)   # должно вернуть 477
```

## 9. IBAN

Файл `data/iban_lengths.txt`, содержит два столбца данных: двухбуквенный код страны и длину международного номера банковского счета IBAN (International Bank Account Number):
```
AL 28
AD 24
...
GB 22
```

Реализовать парсинг этого файла для преобразования его содержимого в словарь длин, а ключом является код страны.
- Использовать лямбда-функцию и генератор списка для получения того же
результата: 
	- в двух строках кода; 
	- в одной строке кода.

## 10. Разделение приза в игре

Пьер и Блез играют в игру, состоящую из нескольких раундов. Каждый из них вложил $100 в общий фонд, и тот, кто первым выиграет 3 раунда, забирает фонд. Победитель каждого раунда определяется случайным образом, и вероятность победы у обоих игроков равна. После 3 раундов Блез выиграл два раунда, а Пьер — один. Пьер собирается забрать свои $100, но Блез говорит: "Подожди! У меня лучше шансы на победу, поэтому я должен получить большую часть фонда. Возьми $50 и оставь остальное мне, и мы разойдемся."

Пьер начинает перечислять все возможные исходы игры и обнаруживает, что в 3 из 4 случаев победит Блез. В итоге он соглашается с Блезом и забирает свои $50.

### Задача

Предположим, что есть $n$ игроков, каждый из которых вложил одинаковую сумму в фонд. Первый, кто выиграет `rounds_to_win` раундов, забирает фонд. Прежде чем завершить игру, игроки решают остановиться и честно разделить фонд между собой. Количество выигранных раундов каждым игроком задано в списке `wins = [w_0, w_1, ...]`, длиной $n$, где `wins[i]` — количество раундов, выигранных игроком $i$.

Напишите функцию `divide_pot`, которая принимает `rounds_to_win` и `wins` в качестве аргументов и возвращает список целых чисел `f = [f_0, f_1, ...]`, такой что `Fraction(f[i], sum(f))` является точной долей фонда, которую игрок $i$ должен получить. Элементы списка `f` не должны иметь общего делителя, большего 1.

### Ограничения входных данных

- $2 \leq n \leq 10$
- $3 \leq rounds2win \leq 100$
- $0 \leq wins[i] < rounds2win$ для всех $0 \leq i < n$

### Пример использования функции

```python
divide_pot(3, [2, 1])  # должно вернуть [3, 2]
divide_pot(5, [1, 1, 2])  # должно вернуть [3, 3, 4]
```

## 11.Модификация массива по запросам

Дан массив, состоящий из $n$ целых чисел: $a[1], a[2], \ldots, a[n]$. Также заданы $m$ запросов, каждый из которых характеризуется тремя числами $l_i, r_i, k_i$. Запрос $l_i, r_i, k_i$ означает, что нужно добавить к каждому элементу $a[j]$, где $l_i \leq j \leq r_i$, число $C^{k_i}_{j - l_i + k_i}$, где $C^{x}_{y}$ — это биномиальный коэффициент, или количество сочетаний из $y$ элементов по $x$ элементам.

Ваша задача — последовательно выполнить все запросы и вывести, чему будут равны элементы массива в итоге после всех запросов.

### Входные данные

- В первой строке заданы целые числа $n, m$ ($1 \leq n, m \leq 10^5$).
- Во второй строке задано $n$ целых чисел $a[1], a[2], \ldots, a[n]$ ($0 \leq a[i] \leq 10^9$) — начальное состояние массива.
- В следующих $m$ строках заданы запросы в формате $l_i, r_i, k_i$ — прибавить всем элементам отрезка $l_i \ldots r_i$ число $C^{k_i}_{j - l_i + k_i}$ ($1 \leq l_i \leq r_i \leq n$; $0 \leq k_i \leq 100$).

### Выходные данные

Выведите $n$ целых чисел: $i$-е число — это значение элемента $a[i]$ после всех запросов. Так как значения могут быть достаточно большими, выводите их по модулю $1000000007$ ($10^9 + 7$).

### Примеры

#### In

```
5 1
0 0 0 0 0
1 5 0
```
#### Out

```
1 1 1 1 1
```

#### In
```
10 2
1 2 3 4 5 0 0 0 0 0
1 6 1
6 10 2
```

#### Out

```
2 4 6 8 10 7 3 6 10 15
```

## 12. Количество путей на координатной плоскости

Иван изучает комбинаторику в своем университете. Он находит очень интересным искать количество способов построить путь до точки $(c,d)$ от $(a,b)$ на координатной плоскости. Разрешено двигаться только горизонтально и вертикально, и нельзя посещать одну и ту же точку дважды. То есть необходимо достигнуть точки $(c, d)$ от $(a,b)$, используя только ходы длины $|a-c| + |b-d|$.

Даны два множества точек:

- Множество $A$ состоит из точек, которые имеют $X$-координату равную $0$ и $Y$-координату, меняющуюся от $1$ до $N$ (включительно).
- Множество $B$ состоит из точек, которые имеют $X$-координату равную $K$ и $Y$-координату, меняющуюся от $1$ до $N$ (включительно).

Количество точек в множествах $X$ и $Y$ равно $N$. Иван хочет найти сумму количеств способов пройти от каждой точки из множества $A$ до каждой точки из множества $B$. Так как ответ может быть очень большим, выводите его по модулю $7 + 10^9$.

#### Формат ввода

Первая строка содержит целое число $T$ – количество тестовых случаев. Далее следует описание тестов в следующем формате:

- Первая (и единственная) строка каждого теста содержит пару целых чисел $N$ и $K$.

#### Формат вывода

Для каждого тестового случая выведите в отдельную строке ответ на поставленную задачу.

#### Ограничения

- Подзадача 1 : $1 \leq T \leq 20$, $1 \leq N, K \leq 1000$
- Подзадача 2 : $1 \leq T \leq 20$, $1 \leq N, K \leq 10^6$
- Подзадача 3 : $1 \leq T \leq 10^4$, $1 \leq N, K \leq 10^6$

### Пример

#### In
```
2
2 2
4 5
```
### Out

```
8
236
```

### Пояснение 

Количество путей [(0,1)->(2,1)]= 1

Количество путей [(0,2)->(2,2)]= 1

Количество путей [(0,1)->(2,2)]= 3

Количество путей [(0,2)->(2,1)]= 3

