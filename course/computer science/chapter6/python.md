# Курс: Информатика

#computer_science #python #note
# Практическое занятие №5. "Основы информатики"

## Python

### Работа с модулями: создание, подключение инструкциями import и from
Модулем в Python называется любой файл с программой (да-да, все те программы, которые вы писали, можно назвать модулями). В этой статье мы поговорим о том, как создать модуль, и как подключить модуль, из [стандартной библиотеки](https://pythonworld.ru/moduli) или написанный вами.

Каждая программа может импортировать модуль и получить доступ к его классам, функциям и объектам. Нужно заметить, что модуль может быть написан не только на Python, а например, на C или C++.

#### Подключение модуля из стандартной библиотеки

Подключить модуль можно с помощью инструкции import. К примеру, подключим [модуль os](https://pythonworld.ru/moduli/modul-os.html) для получения текущей директории:

```python
import os
 os.getcwd()
'C:\\Python33'
```

После ключевого слова **import** указывается название модуля. Одной инструкцией можно подключить несколько модулей, хотя этого не рекомендуется делать, так как это снижает читаемость кода. Импортируем модули [time](https://pythonworld.ru/moduli/modul-time.html) и [random](https://pythonworld.ru/moduli/modul-random.html).
```python
import time, random
time.time()
1376047104.056417
random.random()
0.9874550833306869
```

После импортирования модуля его название становится переменной, через которую можно получить доступ к атрибутам модуля. Например, можно обратиться к константе e, расположенной в модуле [math](https://pythonworld.ru/moduli/modul-math.html):

```python
import math
math.e
2.718281828459045
```


Стоит отметить, что если указанный атрибут модуля не будет найден, возбудится [исключение](https://pythonworld.ru/tipy-dannyx-v-python/isklyucheniya-v-python-konstrukciya-try-except-dlya-obrabotki-isklyuchenij.html) AttributeError. А если не удастся найти модуль для импортирования, то ImportError.

```python
>>> import notexist
Traceback (most recent call last):
  File "", line 1, in
    import notexist
ImportError: No module named 'notexist'
>>> import math
>>> math.Ё
Traceback (most recent call last):
  File "", line 1, in
    math.Ё
AttributeError: 'module' object has no attribute 'Ё'
```

#### Использование псевдонимов

Если название модуля слишком длинное, или оно вам не нравится по каким-то другим причинам, то для него можно создать псевдоним, с помощью ключевого слова as.

```python>>> 
import math as m
>>> m.e
2.718281828459045
```
Теперь доступ ко всем атрибутам модуля math осуществляется только с помощью переменной m, а переменной math в этой программе уже не будет (если, конечно, вы после этого не напишете import math, тогда модуль будет доступен как под именем m, так и под именем math).

#### Инструкция from

Подключить определенные атрибуты модуля можно с помощью инструкции from. Она имеет несколько форматов:
```python
from <Название модуля> import <Атрибут 1> [ as <Псевдоним 1> ], [<Атрибут 2> [ as <Псевдоним 2> ] ...]
from <Название модуля> import *
```


Первый формат позволяет подключить из модуля только указанные вами атрибуты. Для длинных имен также можно назначить псевдоним, указав его после ключевого слова as.

```python
>>> from math import e, ceil as c
>>> e
2.718281828459045
>>> c(4.6)
5
```

Импортируемые атрибуты можно разместить на нескольких строках, если их много, для лучшей читаемости кода:

```python
>>> from math import (sin, cos,
...           tan, atan)
```

Второй формат инструкции from позволяет подключить все (точнее, почти все) переменные из модуля. Для примера импортируем все атрибуты из модуля [sys](https://pythonworld.ru/moduli/modul-sys.html):

```python
>>> from sys import *
>>> version
'3.3.2 (v3.3.2:d047928ae3f6, May 16 2013, 00:03:43) [MSC v.1600 32 bit (Intel)]'
>>> version_info
sys.version_info(major=3, minor=3, micro=2, releaselevel='final', serial=0)
```

Следует заметить, что не все атрибуты будут импортированы. Если в модуле определена переменная __all__ (список атрибутов, которые могут быть подключены), то будут подключены только атрибуты из этого списка. Если переменная __all__ не определена, то будут подключены все атрибуты, не начинающиеся с нижнего подчёркивания. Кроме того, необходимо учитывать, что импортирование всех атрибутов из модуля может нарушить пространство имен главной программы, так как переменные, имеющие одинаковые имена, будут перезаписаны.

#### Создание своего модуля на Python

Теперь пришло время создать свой модуль. Создадим файл mymodule.py, в которой определим какие-нибудь функции:
```python
def hello():
    print('Hello, world!')

def fib(n):
    a = b = 1
    for i in range(n - 2):
        a, b = b, a + b
    return b
```

```
# Pseudo FileSystem
--- mymodule.py
--- main.py
```

Теперь в этой же папке создадим другой файл, например, main.py:

```python
import mymodule

mymodule.hello()
print(mymodule.fib(10))
```

Выведет:
```python
Hello, world!
55
```

Поздравляю! Вы **сделали свой модуль**! Напоследок отвечу ещё на пару вопросов, связанных с созданием модулей:

### Как назвать модуль?

Помните, что вы (или другие люди) будут его импортировать и использовать в качестве переменной. Модуль нельзя именовать также, как и ключевое слово (их список можно посмотреть [тут](https://pythonworld.ru/osnovy/klyuchevye-slova-modul-keyword.html)). Также имена модулей нельзя начинать с цифры. И не стоит называть модуль также, как какую-либо из [встроенных функций](https://pythonworld.ru/osnovy/vstroennye-funkcii.html). То есть, конечно, можно, но это создаст большие неудобства при его последующем использовании.

### Куда поместить модуль?

Туда, где его потом можно будет найти. Пути поиска модулей указаны в переменной `sys.path`. В него включены текущая директория (то есть модуль можно оставить в папке с основной программой), а также директории, в которых установлен python. Кроме того, переменную `sys.path` можно изменять вручную, что позволяет положить модуль в любое удобное для вас место (главное, не забыть в главной программе модифицировать `sys.path`).

### Можно ли использовать модуль как самостоятельную программу?

Можно. Однако надо помнить, что при импортировании модуля его код выполняется полностью, то есть, если программа что-то печатает, то при её импортировании это будет напечатано. Этого можно избежать, если проверять, запущен ли скрипт как программа, или импортирован. Это можно сделать с помощью переменной `__name__`, которая определена в любой программе, и равна `__main__`, если скрипт запущен в качестве главной программы, и имя, если он импортирован. Например, mymodule.py может выглядеть вот так:
```python
def hello():
    print('Hello, world!')

def fib(n):
    a = b = 1
    for i in range(n - 2):
        a, b = b, a + b
    return b

if __name__ == "__main__":
    hello()
    for i in range(10):
        print(fib(i))
```
### Инструкция assert
Инструкции assert в Python — это булевы выражения, которые проверяют, является ли условие истинным (`True`). Они определяют факты (утверждения) в программе. Assertion — это проверка, которую можно включить, а затем выключить, завершив тестирование программы.

Возьмем простой пример функции деления. Можно быть уверенным в том, что делитель не должен быть нолем. Это и указывается при тестировании. Разберем этот пример позже.

#### Что такое Assertion (утверждение)

Assertions (утверждения) — это инструкции, которые «утверждают» определенный кейс в программе. В Python они выступают булевыми выражениями, которые проверяют, является ли условие истинным или ложным. Если оно истинно, то программа ничего не делает и переходит к выполнению следующей строчки кода.

Но если оно ложно, то программа останавливается и возвращает ошибку.

Следующий синтаксис — это базовая структура инструкций утверждения в Python.

```
assert condition
```

Если же нужно добавить сообщение для вывода при ложном условии, то синтаксис будет таким.

```
assert condition, message
```

Это сообщение позволит лучше понять, почему код не сработал.
```python
def avg(ranks):
    assert len(ranks) != 0
    return round(sum(ranks)/len(ranks), 2)

ranks = [62, 65, 75]
print("Среднее значение:", avg(ranks))
```
В этом примере нужно, чтобы пользователь не оставлял параметры пустыми. Если этого не сделать, вернется ошибка `Assertion Error`. Вот пример вывода:

```
Среднее значение: 67.33
```

В этом случае параметры были переданы, поэтому функция вернула нужный результат.

Теперь попробуем ничего не передавать.

```python

def avg(ranks):
    assert len(ranks) != 0
    return round(sum(ranks)/len(ranks), 2)

ranks = []
print("Среднее значение:", avg(ranks))
```

Длина массива `ranks` оказалась 0, и python вернул ошибку `Assertion Error`.

```
Traceback (most recent call last):
  File "C:/Users/asd/AppData/Local/Programs/Python/Python38/wb.py", line 6, in <module>
    print("Среднее значение:", avg(ranks))
  File "C:/Users/asd/AppData/Local/Programs/Python/Python38/wb.py", line 2, in avg
    assert len(ranks) != 0
AssertionError
```

Исключения `Assertion Error` можно перехватывать и обрабатывать как и любые другие исключения с помощью try-except. Но если их обработать неправильно, то программа остановится и вернет `traceback`.

Однако в примере выше она не возвращает ошибку с нужным сообщением. Ее можно написать самостоятельно. Вот как это делается.


```python

def avg(ranks):
    assert len(ranks) != 0, 'Список ranks не должен быть пустым'
    return round(sum(ranks)/len(ranks), 2)

ranks = []
print("Среднее значение:", avg(ranks))
```

Вторым аргументом к `assert` в примере выше было передано сообщение, которое позже появится в выводе.

```
Traceback (most recent call last):
  File "C:/Users/asd/AppData/Local/Programs/Python/Python38/wb.py", line 6, in <module>
    print("Среднее значение:", avg(ranks))
  File "C:/Users/asd/AppData/Local/Programs/Python/Python38/wb.py", line 2, in avg
    assert len(ranks) != 0, 'Список ranks не должен быть пустым'
AssertionError: Список ranks не должен быть пустым
```

#### Assert с сообщением об ошибки

Рассмотрим еще один пример с делением на 0.

```python

def divide(x, y):
    assert y != 0 , 'Нельзя делить на 0'
    return round(x/y, 2)

z = divide(21,3)
print(z)

a = divide(21,0)
print(a)
```

В этом примере, если делителем будет ноль, то `assert` вернет сообщение с ошибкой. Посмотрим на вывод.

```
7.0
Traceback (most recent call last):
  File "C:/Users/asd/AppData/Local/Programs/Python/Python38/wb.py", line 8, in <module>
    a = divide(21,0)
  File "C:/Users/asd/AppData/Local/Programs/Python/Python38/wb.py", line 2, in divide
    assert y != 0 , 'Нельзя делить на 0'
AssertionError: Нельзя делить на 0
```

На третьей сверху строчке написана сама инструкция `assert`. Именно здесь проверяется, не является ли переменная `y` равной 0. Если она больше 0, то условие истинно, и код возвращает требуемый результат.

Но если вызвать метод `division()` со вторым аргументом 0, то условие `assert` будет ложным.

По этой причине и возникает исключение `Assertion Error`. Именно оно возвращает ошибку с сообщением «Нельзя делить на 0».

#### Методы assert

| Метод                      | Проверка на         | Работает с |
| -------------------------- | ------------------- | ---------- |
| `assertEqual(x, y)`        | x == y              |            |
| `assertNotEqual(x, y)`     | x != y              |            |
| `assertTrue(x)`            | bool(x) равно True  |            |
| `assertFalse(x)`           | bool(x) равно False |            |
| `assertIs(x, y)`           | x это y             | 3.1        |
| `assertIsNot(x, y)`        | x это не y          | 3.1        |
| `assertIsNone(x)`          | x это None          | 3.1        |
| `assertIsNotNone(x)`       | x это не None       | 3.1        |
| `assertIn(x, y)`           | x в y               | 3.1        |
| `assertNotIn(x, y)`        | x не в y            | 3.1        |
| `assertIsInstance(x, y)`   | isinstance(x, y)    | 3.2        |
| `assertNotIsInstance(x,y)` | не isinstance(x, y) | 3.2        |

#### Как проверить, что функция возвращает исключение

Можно использовать `TestCase.assertRaises` (или `TestCase.failUnlessRaises`) из модуля `unittest`.

```python

import unittest

def broken_function():
    raise Exception('Это ошибка')

class MyTestCase(unittest.TestCase):
    def test(self):
        with self.assertRaises(Exception) as context:
            broken_function()

        self.assertTrue('Это ошибка' in str(context.exception))

if __name__ == '__main__':
    unittest.main()
```

Вывод:

```
.
----------------------------------------------------------------------
Ran 1 test in 0.051s

OK
```

#### Распространенные ошибки

Есть два важных момента касательно утверждений в Python, о которых нужно помнить.

1. Не стоит использовать assert для валидации данных, ведь это приводит к появлению проблем с безопасностью и багов.
2. Важно не писать такие утверждения, которые всегда будут истинными.

#### Ключевые моменты assert в Python

1. Утверждение (Assertion) — это условие или булево выражение, которое должно быть истинным.
2. Инструкция assert принимает выражение и необязательное сообщение.
3. Инструкция assert используется для проверки типов, значений аргументов и вывода функций.
4. Это также инструмент для отладки, ведь он останавливает программу при появлении ошибки.
5. В первую очередь утверждения используются для уведомления разработчиков о неотслеживаемых ошибках. Они не должны сообщать об условия ошибок, таких как «файл не был найден», где пользователь может попытаться исправиться и повторить действия.
6. Утверждения — это внутренняя проверка для программы. Они работают за счет объявления невозможных условий в коде. Если эти условия не проходят, значит имеется баг.