# Курс: Информатика
#computer_science #python #note #vcs
# Практическое занятие №7. "VCSs"
Системы контроля версий (**Version Control Systems**) - это инструменты для отслеживания изменений в исходном коде (или других файлов и папок). Как следует из названия, эти средства позволяют вести историю изменений, а также облегчают совместную работу. **VCS** отслеживают изменения в папке и ее содержимом в виде серии снимков, где каждый снимок отражает все состояние файлов/папок в каталоге верхнего уровня. **VCS** также хранят метаданные: кто создал каждый **снимок состояния проекта** , сообщения, связанные с каждым **снимок состояния проекта **, и т.д.

Чем полезен контроль версий? Даже если вы работаете в одиночку, он позволяет просматривать старые снимки проекта, вести журнал изменений, работать над параллельными ветвями разработки и многое другое. При совместной работе это неоценимый инструмент, позволяющий видеть, что изменили другие, а также разрешать конфликты при параллельной разработке.

Современные **VCS** также позволяют легко (и часто автоматически) отвечать на такие вопросы, как:

- Кто написал этот модуль?
- Когда была отредактирована эта конкретная строка этого конкретного файла? Кем? Почему она была отредактирована?
- За последние 1000 ревизий когда/почему перестал работать тот или иной юнит-тест?

Хотя существуют и другие **VCS**, **Git** является стандартом де-факто для контроля версий. В этом комиксе **XKCD** отражена репутация **Git**'а:
![[git.png]]

Поскольку интерфейс **Git**'а является негерметичной абстракцией, изучение **Git**'а "сверху вниз" (начиная с его интерфейса / интерфейса командной строки) может привести к большой путанице. Можно запомнить несколько команд и думать о них как о магических заклинаниях, а при возникновении проблем следовать подходу, описанному в комиксе выше.

Хотя **Git**, по общему признанию, имеет уродливый интерфейс, его базовый дизайн и идеи прекрасны. В то время как уродливый интерфейс нужно запоминать, красивый дизайн можно понять. По этой причине мы объясняем **Git** снизу вверх, начиная с модели данных и заканчивая интерфейсом командной строки. После того как модель данных будет понята, можно будет лучше понять команды с точки зрения того, как они манипулируют базовой моделью данных.

# Модель данных Git

Существует множество специальных подходов к управлению версиями. **Git** имеет хорошо продуманную модель, которая позволяет реализовать все основные возможности контроля версий, такие как ведение истории, поддержка ветвей и возможность совместной работы.

## Снимок состояния проекта 

Git представляет историю коллекции файлов и папок внутри некоторого каталога верхнего уровня в виде серии снимков. В терминологии Git файл называется "**блобом**" и представляет собой просто набор байтов. Каталог называется "**деревом**", и он отображает имена на **блобы** или **деревья** (поэтому каталоги могут содержать другие каталоги). **Снимок состояния проекта** - это **дерево верхнего уровня**, за которым ведется наблюдение. Например, у нас может быть следующее дерево:
```git
<root> (tree)
|
+- foo (tree)
|  |
|  + bar.txt (blob, contents = "hello world")
|
+- baz.txt (blob, contents = "git is wonderful")
```
Дерево верхнего уровня содержит два элемента - **дерево "foo"** (которое само содержит один элемент - **блоб "bar.txt"**) и **блоб "baz.txt"**.

# История изменения: взаимосвязь  снимков состояния

Как в системе управления версиями должны быть связаны  снимки состояния? Одной из простых моделей является линейная история. История представляет собой список снимков, расположенных в порядке убывания времени. По многим причинам **Git** не использует такую простую модель.

В **Git** история - это **направленный ациклический граф** (**DAG**) моментальных снимков. Это может показаться причудливым математическим словом, но не пугайтесь. Это означает, что каждый снимок в **Git** ссылается на набор **"родителей"** - снимков, которые ему предшествовали. Это именно набор родителей, а не один родитель (как в линейной истории), поскольку снимок может происходить от нескольких родителей, например, в результате **объединения (слияния)** двух параллельных ветвей разработки.

**Git** называет эти снимки **"коммитами"**. Визуализация истории **коммитов** может выглядеть следующим образом:
```
o <-- o <-- o <-- o
            ^
             \
              --- o <-- o
```

На приведенном ASCII-рисунке символы `o` соответствуют отдельным **коммитам** (снимкам). **Стрелки указывают на родителя каждого коммита (это отношение "приходит до", а не "приходит после").** После третьего коммита история разветвляется на две отдельные ветви. Это может соответствовать, например, параллельной разработке двух отдельных функций, независимых друг от друга. В будущем эти ветки могут быть объединены для создания нового снимка, включающего в себя обе функции, что приведет к появлению новой истории, которая будет выглядеть следующим образом, причем вновь созданная фиксация слияния будет выделена жирным шрифтом:

```

o <-- o <-- o <-- o <---- o
            ^            /
             \          v
              --- o <-- o
```

**Коммиты в Git'е неизменяемы**. Однако это не означает, что ошибки не могут быть исправлены; просто **"правки"** в истории **коммитов** на самом деле создают совершенно новые **коммиты**, и ссылки (см. ниже) обновляются, чтобы указывать на новые **коммиты**.

## Модель данных в виде псевдокода

Возможно, будет полезно увидеть модель данных Git'а, записанную в псевдокоде:
```
// файл представляет собой набор байтов
тип blob = array<byte>

// каталог содержит именованные файлы и каталоги
type tree = map<string, tree | blob>

// у коммита есть родители, метаданные и дерево верхнего уровня
type commit = struct {
    parents: array<commit>
    автор: string
    сообщение: строка
    снимок: дерево
}
```

Это чистая, простая модель истории проекта.

## Объекты и адресация содержимого

"**Объект**" - это блоб, дерево или коммит:

```
type object = blob | tree | commit
```

В хранилище данных **Git** все объекты имеют контент-адресацию по их [SHA-1-hash](https://en.wikipedia.org/wiki/SHA-1).

```
objects = map<string, object>

def store(object):
    id = sha1(object)
    objects[id] = object

def load(id):
    return objects[id]
```

**Блобы, деревья и коммиты** унифицированы таким образом: **все они являются объектами**. Когда они ссылаются на другие объекты, они на самом деле не _содержат_ их в своем дисковом представлении, но имеют на них **ссылку по хэшу**.

Например, дерево для примера структуры каталогов [выше](#Снимок состояния проекта) (визуализируется с помощью `git cat-file -p 698281bc680d1995c5f4caaf3359721a5a58d48d`), выглядит следующим образом:

```
100644 blob 4448adbf7ecd394f42ae135bbeed9676e894af85    baz.txt
040000 tree c68d233a33c5c06e0340e4c224f0afca87c8ce87    foo
```

Само дерево содержит указатели на свое содержимое, `baz.txt` (блоб) и `foo` (дерево). Если посмотреть содержимое, к которому обращается хэш, соответствующий baz.txt, с помощью команды `git cat-file -p 4448adbf7ecd394f42ae135bbeed9676e894af85`, то мы получим следующее:

```
git is wonderful
```

## Ссылки

Теперь все снимки можно идентифицировать по их **SHA-1-хэшам**. Это неудобно, поскольку люди не умеют запоминать строки из **40** шестнадцатеричных символов.

Решением этой проблемы в **Git'е** являются человеко понятные имена для **SHA-1-хэшей**, называемые "ссылками". Ссылки - это указатели на **коммиты**. В отличие от объектов, которые являются неизменяемыми, ссылки являются **изменяемыми** (могут быть обновлены и указывать на новый **коммит**). Например, ссылка `master` обычно указывает на последний коммит в основной ветке разработки.

```
references = map<string, string>

def update_reference(name, id):
    references[name] = id

def read_reference(name):
    return references[name]

def load_reference(name_or_id):
    if name_or_id in references:
        return load(references[name_or_id])
    else:
        return load(name_or_id)
```
Благодаря этому **Git** может использовать **человекочитаемые** имена типа "master" для ссылки на конкретный снимок в истории, а не длинную шестнадцатеричную строку.

Одна из деталей заключается в том, что нам часто требуется представление о том, "где мы сейчас находимся" в истории, чтобы при создании нового снимка мы знали, относительно чего он находится (как мы задаем поле parents в коммите). В Git'е таким "текущим местом" является специальная ссылка, называемая "HEAD".

## Репозитории
Наконец, мы можем определить, что (грубо) представляет собой хранилище **Git**: это объекты данных и ссылки на них.

На диске все хранилища **Git** - это объекты и ссылки: это все, что есть в модели данных **Git**. Все команды **git** связаны с некоторыми манипуляциями с **DAG** коммитов путём добавления объектов и добавления/обновления ссылок.

Набирая любую команду, думайте о том, какие манипуляции она производит с базовой структурой данных графа. И наоборот, если вы хотите внести в **DAG** фиксации определённые изменения, например, **"отбросить незафиксированные изменения и сделать так, чтобы ссылка 'master' указывала на фиксацию 5d83f9e"**, то для этого, скорее всего, найдётся соответствующая команда (например, в данном случае **git checkout master; git reset --hard 5d83f9e**).

## Область постановки
Это еще одно понятие, ортогональное к модели данных, но являющееся частью интерфейса для создания фиксаций.

Один из вариантов реализации, описанный выше, - это команда "**create snapshot**", которая создает новый снимок на основе текущего состояния рабочего каталога. Некоторые средства управления версиями работают подобным образом, но не **Git**. Нам нужны чистые снимки, и не всегда идеально создавать снимок из текущего состояния. Например, представьте себе сценарий, в котором вы реализовали две отдельные функции и хотите создать два отдельных коммита, в первом из которых будет представлена первая функция, а во втором - вторая. Или представьте себе сценарий, в котором по всему коду добавлены отладочные операторы печати, а также исправление ошибки; вы хотите зафиксировать исправление, отбросив все операторы печати.

**Git** учитывает такие сценарии, позволяя указать, какие модификации должны быть включены в следующий снимок, с помощью механизма, называемого "областью хранения".
## Интерфейс командной строки Git

Чтобы не дублировать информацию, мы не будем подробно описывать приведенные ниже команды. Для получения более подробной информации обратитесь к настоятельно рекомендуемому изданию [**Pro Git**](https://git-scm.com/book/en/v2) или посмотрите **видеолекцию**.

###  Основные команды 

`git help <команда>:` получение справки по команде git
`git init`: создает новое `git-репозиторий`, данные которого хранятся в каталоге `.git`
`git status`: сообщает, что происходит.
`git add <filename>`: добавляет файлы в область хранения
`git commit`: создает новый коммит
 - Пишите правильные [коммиты](https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html)!
 -  Ещё больше причин писать хорошие [коммиты](https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html)!
`git log`: показывает сплюснутый журнал истории
`git log --all --graph --decorate`: визуализация истории в виде `DAG`
`git diff <filename>`: показывает сделанные изменения относительно области хранения
`git diff <revision> <filename>`: показывает различия в файле между снимками
`git checkout <revision>`: обновляет `HEAD` и текущую ветку
### Взаимодействие с ветками

`git branch`: показывает ветви
`git branch <имя>`: создает ветку
`git checkout -b <имя>`: создает ветку и переключается на нее 
 - то же, что и `git branch <имя>`; `git checkout <имя>`
`git merge <ревизия>`: объединяет в текущую ветку
`git mergetool`: использование модного инструмента для разрешения конфликтов слияния
`git rebase`: переписать набор патчей на новую базу

### Remotes
`git remote`: список пультов
`git remote add <имя> <url>`: добавить удаленный объект
`git push <remote> <локальная ветка><удаленная ветка>`: отправка объектов на удаленную ветку и обновление ссылки на нее
`git branch --set-upstream-to=<remote>/<remote branch>`: установить соответствие между локальной и удаленной веткой
`git fetch`: получение объектов/ссылок с удаленной ветки
`git pull`: то же, что и git fetch; git merge
`git clone`: загрузка репозитория с удаленной ветки

### Отменить

`git commit --amend`: редактирование содержимого/сообщения коммита
`git reset HEAD <file>`: отменить коммит файла
`git checkout -- <file>`: отменить изменения

### Расширенные возможности Git

`git config`: Git очень хорошо настраивается
`git clone --depth=1`: неглубокий клон, без всей истории версий
`git add -p`: интерактивный стейджинг
`git rebase -i`: интерактивный ребазинг
`git blame`: показать, кто последний раз редактировал какую строку
`git stash`: временное удаление модификаций в рабочую директорию
`git bisect`: история бинарного поиска (например, для поиска регрессий)
`.gitignore`: указать намеренно неотслеживаемые файлы для игнорирования

### Разное

- **Графические интерфейсы**: существует множество [графических интерфейсов для Git](https://git-scm.com/downloads/guis). Лично мы их не используем и обходимся интерфейсом командной строки.
- **Интеграция с оболочкой**: очень удобно иметь статус Git как часть приглашения оболочки ([zsh](https://github.com/olivierverdier/zsh-git-prompt), [bash](https://github.com/magicmonty/bash-git-prompt)). Часто включается во фреймворки типа [Oh My Zsh](https://github.com/ohmyzsh/ohmyzsh).
- **Интеграция с редактором**: аналогично вышеописанному, удобные интеграции с множеством функций. [fugitive.vim](https://github.com/tpope/vim-fugitive) является стандартным для Vim.
- **Рабочие процессы**: мы научили вас модели данных, а также некоторым базовым командам; мы не рассказали вам, какой практики следует придерживаться при работе над большими проектами (а существует [множество](https://nvie.com/posts/a-successful-git-branching-model/) [различных](https://www.endoflineblog.com/gitflow-considered-harmful) [подходов](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow)).
- **GitHub**: Git - это не GitHub. На GitHub существует особый способ внесения кода в другие проекты, называемый [pull requests](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests).
- **Другие провайдеры Git**: GitHub не является чем-то особенным: существует множество хостов репозиториев Git, таких как [GitLab](https://about.gitlab.com/) и [BitBucket](https://bitbucket.org/).

### Ресурсы
Настоятельно **рекомендуется к прочтению книга** [Pro Git](https://git-scm.com/book/en/v2). Пройдя главы 1-5, вы узнаете большую часть того, что необходимо для квалифицированного использования **Git**'а, после того как поймете модель данных. В последующих главах содержится интересный, продвинутый материал.
[Oh Shit, Git!?!](https://ohshitgit.com/) - краткое руководство по восстановлению после некоторых распространенных ошибок Git.
[Git for Computer Scientists](https://eagain.net/articles/git-for-computer-scientists/) - краткое объяснение модели данных Git'а, содержащее меньше псевдокода и больше причудливых диаграмм, чем эти конспекты лекций.
[Git from the Bottom Up](https://jwiegley.github.io/git-from-the-bottom-up/) - подробное объяснение деталей реализации Git'а, выходящих за рамки модели данных, для любознательных.
[Как объяснить git простыми словами](https://smusamashah.github.io/blog/2017/10/14/explain-git-in-simple-words)
[Learn Git Branching](https://learngitbranching.js.org/) - браузерная игра, обучающая работе с Git.
### Упражнения
Если у вас нет опыта работы с **Git**, попробуйте прочитать первые пару глав книги [**Pro Git**](https://git-scm.com/book/en/v2) или изучите учебник типа [**Learn Git Branching**](https://learngitbranching.js.org/). В процессе работы над ним увязывайте команды Git с моделью данных.