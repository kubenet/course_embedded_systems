# Курс: Информатика
#computer_science #python #note #vcs
# Практическое занятие №7. "VCSs"
Системы контроля версий (**Version Control Systems**) - это инструменты для отслеживания изменений в исходном коде (или других файлов и папок). Как следует из названия, эти средства позволяют вести историю изменений, а также облегчают совместную работу. **VCS** отслеживают изменения в папке и ее содержимом в виде серии снимков, где каждый снимок отражает все состояние файлов/папок в каталоге верхнего уровня. **VCS** также хранят метаданные: кто создал каждый **снимок состояния проекта** , сообщения, связанные с каждым **снимок состояния проекта **, и т.д.

Чем полезен контроль версий? Даже если вы работаете в одиночку, он позволяет просматривать старые снимки проекта, вести журнал изменений, работать над параллельными ветвями разработки и многое другое. При совместной работе это неоценимый инструмент, позволяющий видеть, что изменили другие, а также разрешать конфликты при параллельной разработке.

Современные **VCS** также позволяют легко (и часто автоматически) отвечать на такие вопросы, как:

- Кто написал этот модуль?
- Когда была отредактирована эта конкретная строка этого конкретного файла? Кем? Почему она была отредактирована?
- За последние 1000 ревизий когда/почему перестал работать тот или иной юнит-тест?

Хотя существуют и другие **VCS**, **Git** является стандартом де-факто для контроля версий. В этом комиксе **XKCD** отражена репутация **Git**'а:
![[git.png]]

Поскольку интерфейс **Git**'а является негерметичной абстракцией, изучение **Git**'а "сверху вниз" (начиная с его интерфейса / интерфейса командной строки) может привести к большой путанице. Можно запомнить несколько команд и думать о них как о магических заклинаниях, а при возникновении проблем следовать подходу, описанному в комиксе выше.

Хотя **Git**, по общему признанию, имеет уродливый интерфейс, его базовый дизайн и идеи прекрасны. В то время как уродливый интерфейс нужно запоминать, красивый дизайн можно понять. По этой причине мы объясняем **Git** снизу вверх, начиная с модели данных и заканчивая интерфейсом командной строки. После того как модель данных будет понята, можно будет лучше понять команды с точки зрения того, как они манипулируют базовой моделью данных.

# Модель данных Git

Существует множество специальных подходов к управлению версиями. **Git** имеет хорошо продуманную модель, которая позволяет реализовать все основные возможности контроля версий, такие как ведение истории, поддержка ветвей и возможность совместной работы.

## Снимок состояния проекта 

Git представляет историю коллекции файлов и папок внутри некоторого каталога верхнего уровня в виде серии снимков. В терминологии Git файл называется "**блобом**" и представляет собой просто набор байтов. Каталог называется "**деревом**", и он отображает имена на **блобы** или **деревья** (поэтому каталоги могут содержать другие каталоги). **Снимок состояния проекта** - это **дерево верхнего уровня**, за которым ведется наблюдение. Например, у нас может быть следующее дерево:
```git
<root> (tree)
|
+- foo (tree)
|  |
|  + bar.txt (blob, contents = "hello world")
|
+- baz.txt (blob, contents = "git is wonderful")
```
Дерево верхнего уровня содержит два элемента - **дерево "foo"** (которое само содержит один элемент - **блоб "bar.txt"**) и **блоб "baz.txt"**.

# История изменения: взаимосвязь  снимков состояния

Как в системе управления версиями должны быть связаны  снимки состояния? Одной из простых моделей является линейная история. История представляет собой список снимков, расположенных в порядке убывания времени. По многим причинам **Git** не использует такую простую модель.

В **Git** история - это **направленный ациклический граф** (**DAG**) моментальных снимков. Это может показаться причудливым математическим словом, но не пугайтесь. Это означает, что каждый снимок в **Git** ссылается на набор **"родителей"** - снимков, которые ему предшествовали. Это именно набор родителей, а не один родитель (как в линейной истории), поскольку снимок может происходить от нескольких родителей, например, в результате **объединения (слияния)** двух параллельных ветвей разработки.

**Git** называет эти снимки **"коммитами"**. Визуализация истории **коммитов** может выглядеть следующим образом:
```
o <-- o <-- o <-- o
            ^
             \
              --- o <-- o
```

На приведенном ASCII-рисунке символы `o` соответствуют отдельным **коммитам** (снимкам). **Стрелки указывают на родителя каждого коммита (это отношение "приходит до", а не "приходит после").** После третьего коммита история разветвляется на две отдельные ветви. Это может соответствовать, например, параллельной разработке двух отдельных функций, независимых друг от друга. В будущем эти ветки могут быть объединены для создания нового снимка, включающего в себя обе функции, что приведет к появлению новой истории, которая будет выглядеть следующим образом, причем вновь созданная фиксация слияния будет выделена жирным шрифтом:

```

o <-- o <-- o <-- o <---- o
            ^            /
             \          v
              --- o <-- o
```

**Коммиты в Git'е неизменяемы**. Однако это не означает, что ошибки не могут быть исправлены; просто **"правки"** в истории **коммитов** на самом деле создают совершенно новые **коммиты**, и ссылки (см. ниже) обновляются, чтобы указывать на новые **коммиты**.

## Модель данных в виде псевдокода

Возможно, будет полезно увидеть модель данных Git'а, записанную в псевдокоде:
```
// файл представляет собой набор байтов
тип blob = array<byte>

// каталог содержит именованные файлы и каталоги
type tree = map<string, tree | blob>

// у коммита есть родители, метаданные и дерево верхнего уровня
type commit = struct {
    parents: array<commit>
    автор: string
    сообщение: строка
    снимок: дерево
}
```

Это чистая, простая модель истории проекта.

## Объекты и адресация содержимого

"**Объект**" - это блоб, дерево или коммит:

```
type object = blob | tree | commit
```

В хранилище данных **Git** все объекты имеют контент-адресацию по их [SHA-1-hash](https://en.wikipedia.org/wiki/SHA-1).

```
objects = map<string, object>

def store(object):
    id = sha1(object)
    objects[id] = object

def load(id):
    return objects[id]
```

**Блобы, деревья и коммиты** унифицированы таким образом: **все они являются объектами**. Когда они ссылаются на другие объекты, они на самом деле не _содержат_ их в своем дисковом представлении, но имеют на них **ссылку по хэшу**.

Например, дерево для примера структуры каталогов [выше](#Снимок состояния проекта) (визуализируется с помощью `git cat-file -p 698281bc680d1995c5f4caaf3359721a5a58d48d`), выглядит следующим образом:

```
100644 blob 4448adbf7ecd394f42ae135bbeed9676e894af85    baz.txt
040000 tree c68d233a33c5c06e0340e4c224f0afca87c8ce87    foo
```

Само дерево содержит указатели на свое содержимое, `baz.txt` (блоб) и `foo` (дерево). Если посмотреть содержимое, к которому обращается хэш, соответствующий baz.txt, с помощью команды `git cat-file -p 4448adbf7ecd394f42ae135bbeed9676e894af85`, то мы получим следующее:

```
git is wonderful
```

## Ссылки

Теперь все снимки можно идентифицировать по их **SHA-1-хэшам**. Это неудобно, поскольку люди не умеют запоминать строки из **40** шестнадцатеричных символов.

Решением этой проблемы в **Git'е** являются человеко понятные имена для **SHA-1-хэшей**, называемые "ссылками". Ссылки - это указатели на **коммиты**. В отличие от объектов, которые являются неизменяемыми, ссылки являются **изменяемыми** (могут быть обновлены и указывать на новый **коммит**). Например, ссылка `master` обычно указывает на последний коммит в основной ветке разработки.

```
references = map<string, string>

def update_reference(name, id):
    references[name] = id

def read_reference(name):
    return references[name]

def load_reference(name_or_id):
    if name_or_id in references:
        return load(references[name_or_id])
    else:
        return load(name_or_id)
```

# TO BE CONTINUED....