# Курс: Информатика
#computer_science #python #note #DataBase
# Практическое занятие №8 "Базы данных"

>[!tip] Хотя я известен прежде всего своими работами в области баз данных, мои фундаментальные умения лежат в области архитектуры: это анализ технических требований и построение простых, но изящных решений.											 <br>Чарльз Бэкмен<br>


# Базы данных 

Управление обширными объемами данных в компьютерных системах представляет собой значительную сложность, но зачастую является жизненно необходимым. Биологи хранят и анализируют последовательности ДНК и сопутствующие структуры белков. Социальная сеть Facebook обрабатывает контент, создаваемый миллиардами пользователей. Компания Amazon контролирует свои продажи, запасы товаров и логистику. Возникает вопрос: как эффективно хранить эти большие, постоянно изменяющиеся массивы данных на дисках? Как обеспечить возможность одновременного доступа, редактирования и добавления данных различными агентами? Вместо того чтобы самостоятельно решать эти задачи, мы обращаемся к системам управления базами данных (СУБД) — специализированным программным компонентам, предназначенным для управления данными. СУБД организует и хранит информацию, а также предоставляет возможность доступа к ней и ее изменения.

К основным функциям, которые обеспечивают современные СУБД, относятся:

- понимание реляционной модели, распространенной в большинстве баз данных;
- использование гибкости нереляционных баз данных;
- координация работы компьютеров и распределение данных между ними;
- интеграция информации с картографическими данными с помощью географических баз данных;
- обмен данными с различными системами посредством сериализации.

Хотя реляционные базы данных имеют более широкое распространение, нереляционные зачастую оказываются более простыми и эффективными. Базы данных характеризуются разнообразием, и выбор между ними может представлять собой сложную задачу. В данной главе представлен обзор различных типов современных СУБД. Упрощая доступ к данным с помощью СУБД, мы можем значительно повысить их полезность. Подобно тому, как шахтер извлекает ценные минералы и металлы из непримечательного каменистого участка земли, мы также можем выявить ценную информацию из существующих массивов данных. Этот процесс называется глубинным анализом данных. Например, крупная сеть продуктовых магазинов проанализировала свои данные о продажах и обнаружила, что её наиболее активные покупатели часто выбирают сорт сыра, продажи которого составляют менее 200 единиц. Обычно товары с такими низкими продажами снимаются с реализации. Однако анализ данных подтолкнул менеджеров не только сохранить этот сорт сыра, но и разместить его на видном месте, что привело к увеличению числа покупок со стороны лояльных клиентов. Для реализации подобного стратегического решения сети продуктовых магазинов потребовалась эффективная организация данных в рамках СУБД.
## Реляционная модель

Возникновение реляционной модели в конце 1960-х годов стало значительным прорывом в области управления информацией. Реляционные базы данных способствуют минимизации дублирования информации и предотвращению противоречий. В настоящее время большинство используемых систем управления базами данных (СУБД) основано на реляционной модели.

В данной модели данные организуются в виде таблиц, которые можно сравнить с матрицей или листом Excel. Каждая запись представлена в виде строки, а столбцы отображают различные свойства записей. Обычно столбцы определяют типы данных, которые в них хранятся, и могут содержать дополнительные ограничения, такие как обязательность наличия значения в данном столбце или уникальность значения среди всех строк таблицы. Столбцы обычно называют полями. Например, если столбец допускает только целые числа, он классифицируется как целочисленное поле. Разные таблицы могут использовать различные типы полей.

Организация таблицы базы данных определяется ее полями и ограничениями, которые на них накладываются. Совокупность полей и ограничений формирует схему таблицы. Все записи в таблице представлены строками, и СУБД не позволит добавить новую строку, если она нарушает установленную схему. Это является одним из основных недостатков реляционной модели: когда характеристики данных значительно варьируются, необходимость соответствия фиксированной схеме может создавать определенные трудности. Однако при работе с однородными данными фиксированная схема обеспечивает их допустимость.

### Отношения

Рассмотрим базу данных счетов-фактур, содержащую информацию в единственной таблице. Для каждого счета необходимо хранить данные о заказе и клиенте. При наличии нескольких счетов, относящихся к одному клиенту, возникает дублирование информации.

![images](table.png)

Повторяющаяся информация затрудняет управление и обновление данных. Чтобы избежать таких проблем, реляционная модель делит связанную информацию на разные таблицы. Например, можно разделить данные о счетах-фактурах на две таблицы: «Заказы» и «Клиенты», при этом каждая строка в первой таблице будет ссылаться на строку во второй.

![images](table_0.png)

Благодаря связыванию данных из различных таблиц один клиент может быть ассоциирован с несколькими заказами, что устраняет дублирование информации. Для поддержки таких связей каждая таблица включает специальное идентификационное поле, или ID. Эти значения используются для ссылки на конкретные строки в таблице и должны быть уникальными. Поле ID таблицы также называется первичным ключом, тогда как поле, содержащее ссылки на ID других строк, называется внешним ключом.

![images](table_1.png)

С помощью первичных и внешних ключей можно создавать сложные отношения между различными наборами данных.

Когда база данных организована таким образом, что не содержит повторяющейся информации, говорят о нормализации. Процесс преобразования базы данных с дубликатами в базу данных без таковых называется **нормализацией**.

## Миграция схемы

По мере роста приложения и добавления новых свойств его структура базы данных (схема таблиц) зачастую требует изменений. В таких случаях необходимо модифицировать структуру, для чего разрабатывается сценарий миграции схемы. Этот скрипт автоматически обновляет схему и преобразует существующие данные. Обычно такие сценарии также могут отменять произведенные изменения, что позволяет легко восстановить структуру базы данных, соответствующую предыдущей рабочей версии программы. В большинстве систем управления базами данных (СУБД) существуют встроенные инструменты, которые помогают создавать и применять сценарии миграции схемы, а также возвращать базу данных в прежнее состояние. В некоторых крупных системах может осуществляться сотни миграций в год, что подчеркивает важность этих инструментов. Если не применять миграцию схемы и вносить изменения вручную, восстановить базу данных к конкретной рабочей версии в дальнейшем будет затруднительно. Такой "ручной" подход не гарантирует совместимость между локальными базами данных различных разработчиков программного обеспечения, что может привести к проблемам, особенно в крупных программных проектах, где работа с базами данных не всегда принимается во внимание.

## SQL

Практически каждая реляционная СУБД поддерживает язык запросов SQL. Важно иметь хотя бы поверхностное понимание SQL, даже если вы не работаете с ним напрямую. SQL-запрос — это команда, указывающая, какие данные необходимо извлечь:

```SQL
SELECT <field name> [, <field name>, <field name>,…]
FROM <table name>
WHERE <condition>;
```

Элементы, следующие после `SELECT`, представляют собой поля, которые необходимо извлечь. Для получения всех полей из таблицы можно использовать: `SELECT *`. Поскольку в базе данных может быть несколько таблиц, оператор `FROM` уточняет, из какой таблицы следует извлекать данные. После команды `WHERE` устанавливаются критерии отбора строк. Для указания множества условий можно применять булеву логику. Следующий запрос извлекает все поля из таблицы customers (клиенты), фильтруя строки по полям name (имя) и age (возраст):

```SQL
SELECT * FROM customers 
WHERE age > 21 AND name = "John";
```

Вы можете выполнить запрос `SELECT * FROM customers` без оператора `WHERE`, и СУБД предоставит вам список всех клиентов. Также существуют другие операторы запросов, которые важно знать: оператор `ORDER BY` сортирует результаты по указанному полю (полям), а `GROUP BY` позволяет выполнять группировку и получать агрегированные результаты для групп. Например, имея таблицу customers с полями country (страна) и age (возраст), можно выполнить следующий запрос:

```SQL
SELECT country, AVG(age) 
FROM customers 
GROUP BY country 
ORDER BY country;
```

Этот запрос вернет отсортированный список стран, в которых проживают ваши клиенты, вместе со средним возрастом клиентов по каждой стране. SQL предлагает и другие агрегатные функции. Например, заменив `AVG(age)` на `MAX(age)`, вы получите возраст самого старого клиента в каждой стране.

Иногда возникает необходимость изучить информацию как из одной строки, так и из связанных с ней строк. Например, если у вас есть таблица с заказами и таблица с клиентами, где таблица orders содержит внешний ключ, ссылающийся на клиентов, для нахождения информации о клиентах, сделавших дорогие заказы, потребуется выбрать данные из обеих таблиц. Однако не обязательно запрашивать их по отдельности и сопоставлять записи вручную. Для этого в языке SQL предусмотрена специальная команда:

```SQL
SELECT DISTINCT customers.name, customers.phone 
FROM customers 
JOIN orders ON orders.customer = customers.id 
WHERE orders.amount > 100.00;
```

Этот запрос вернет имена и телефонные номера клиентов, сделавших заказы на сумму свыше 100 долларов. Команда `SELECT DISTINCT` гарантирует, что каждый клиент будет представлен в результате лишь один раз. Оператор `JOIN` позволяет выполнять гибкие запросы, но такая гибкость может обернуться высокой стоимостью. Базе данных необходимо рассмотреть все сочетания строк из объединяемых таблиц, что может стать непрактичным для очень больших таблиц. Оператор `JOIN` представляет собой мощный инструмент, однако одновременно является одной из основных слабостей реляционных баз данных.

### Индексация

Для того чтобы первичный ключ таблицы действительно был полезен, необходимо обеспечить возможность быстрого доступа к записи по ID. Для этой цели системы управления базами данных (СУБД) строят вспомогательный индекс, который содержит ID строк и соответствующие адреса в памяти. Индекс представляет собой сбалансированное двоичное дерево поиска, где каждая строка в таблице соответствует узлу в дереве.
![images](index.png)

Ключи узлов — это значения в индексируемом поле. Чтобы найти запись с заданным значением, мы ищем его в дереве. При нахождении узла мы получаем адрес, который он хранит, и используем его для извлечения записи. Поиск по двоичному дереву имеет временную сложность $O(\log n)$, что позволяет быстро находить записи в больших таблицах. Обычно СУБД создает индекс для каждого первичного ключа в базе данных. Однако если часто требуется осуществлять поиск по другим полям (например, по именам клиентов), можно назначить СУБД создание дополнительных индексов для этих полей.

**Ограничения уникальности.** Индексы часто создаются автоматически для полей, имеющих ограничение уникальности. При добавлении новой строки СУБД должна просмотреть всю таблицу, чтобы убедиться, что ни одно ограничение уникальности не нарушено. Без индекса такая проверка потребует сверки со всеми строками в таблице. С использованием индекса мы можем быстро выполнить поиск и, например, определить, присутствует ли значение, которое мы пытаемся вставить, уже в таблице. Индексация полей с ограничением уникальности необходима для быстрой вставки данных.

**Сортировка.** Индексы также упрощают выбор строк в порядке сортировки по индексируемым полям. Например, если имеется индекс для поля name (имя), мы можем получить строки, отсортированные по имени, без дополнительных вычислений. Если применить команду `ORDER BY` к полю без индекса, СУБД придется сортировать данные в памяти перед выполнением запроса. Некоторые СУБД могут даже отказаться выполнять запрос, требующий сортировки по неиндексированному полю, если это связано с большим объемом данных.

Когда необходимо отсортировать строки сначала по одной колонке, а затем по другой, наличие индекса в поле age (возраст) или country (страна) может оказаться недостаточным. Индекс в поле country позволит получить строки, отсортированные по стране, но затем потребуется вручную сортировать элементы, имеющие одинаковую страну, по возрасту. Для сортировки по нескольким полям используются комбинированные или составные индексы, которые индексируют несколько полей. Они не помогают искать элементы быстрее, но облегчают получение данных, отсортированных по нескольким критериям.

**Производительность.** Таким образом, индексы существенно ускоряют выполнение запросов и позволяют мгновенно получать доступ к отсортированным данным. Однако возникает вопрос: почему не создать индексы для всех полей в каждой таблице? Проблема заключается в том, что при добавлении или удалении записи необходимо обновлять все индексы, чтобы отразить эти изменения. Если индексов много, операции обновления, вставки или удаления могут стать вычислительно затратными (например, из-за необходимости балансировки дерева). Более того, индексы занимают дисковое пространство. Важно отслеживать, как ваше приложение взаимодействует с базой данных. СУБД обычно сопровождаются инструментами, которые помогают в этом. Они могут «объяснять» запросы, указывая, какие индексы использовались и сколько строк было необходимо просканировать для выполнения запроса. Если ваши запросы затрачивают слишком много времени на последовательное сканирование данных, имеет смысл добавить индекс для соответствующего поля и проверить, улучшится ли производительность. Например, если вы часто ищете людей определенного возраста, создание индекса для поля age позволит СУБД сразу извлекать строки, соответствующие этому возрасту, избегая последовательного просмотра всех данных.

Оптимизация базы данных для повышения производительности требует понимания, какие индексы стоит создавать, а какие — удалять. Если база данных используется в основном в режиме чтения и редко обновляется, может быть оправдано создание большего числа индексов. Плохая индексация является одной из основных причин замедления работы коммерческих систем. Небрежные системные администраторы часто не анализируют, как выполняются типичные запросы, и просто создают индексы для произвольных полей, полагая, что это улучшит производительность. Такого подхода следует избегать. Используйте «объясняющие» инструменты для анализа запросов и создавайте индексы только в тех случаях, когда это действительно необходимо.
## Транзакции

Рассмотрим ситуацию, когда швейцарский банк не ведет учета денежных переводов, а просто хранит баланс счетов. Допустим, клиент хочет перевести деньги со своего счета на счет друга в том же банке. В этом случае необходимо выполнить две операции в базе данных: вычесть определенную сумму из одного баланса и прибавить ее к другому. Сервер базы данных обычно позволяет множеству клиентов одновременно читать и записывать данные, что обеспечивает высокую скорость обработки запросов. Однако это создает риски. Например, если кто-то запросит общий баланс всех счетов после вычитания, но до добавления суммы, то получится, что часть средств будет отсутствовать. Более того, что произойдет, если система отключится между этими двумя операциями? При перезапуске сервера будет сложно выяснить причину расхождения в данных.

Чтобы избежать подобных проблем, системы управления базами данных (СУБД) поддерживают концепцию транзакций. Транзакция представляет собой набор операций, которые должны выполняться атомарно, то есть либо все изменения должны быть применены, либо ни одно из них не должно быть. Транзакции значительно упрощают задачу программиста, так как за обеспечение непротиворечивости данных отвечает сама СУБД. Программисту остается лишь обернуть зависимые операции в соответствующие команды:

```SQL
START TRANSACTION; 
UPDATE vault SET balance = balance + 50 WHERE id=2; 
UPDATE vault SET balance = balance - 50 WHERE id=1; 
COMMIT;
```

Важно запомнить, что выполнение многосоставных обновлений без использования транзакций может привести к возникновению непредсказуемых и трудно обнаружимых противоречий в данных.

## Нереляционная модель

Реляционные базы данных обладают множеством достоинств, однако у них имеются и определенные недостатки. С увеличением сложности приложения в реляционную базу данных необходимо добавлять всё больше таблиц, что приводит к снижению читаемости запросов. Кроме того, возникает необходимость частого использования соединений (JOIN), которые требуют значительных вычислительных ресурсов и могут создавать узкие места в системе.

![images](ne_real.png)

Нереляционная модель, напротив, не использует табличные связи и практически не требует объединения информации из нескольких записей. В связи с тем, что нереляционные системы управления базами данных (СУБД) применяют языки запросов, отличные от SQL, их часто называют базами данных NoSQL.

### Документные хранилища

Наиболее известным типом баз данных NoSQL являются документные хранилища. В этих системах записи сохраняются в том формате, который необходим приложению. На приведенном ниже рисунке сравниваются табличный и документный подходы к хранению постов в блоге.

![images](ne_real_1.png)

Обратите внимание, что вся информация о сообщении дублируется в соответствующей записи. Нереляционная модель допускает дублирование данных, когда это необходимо. Однако обновление дублированной информации может быть сложным и затруднять поддержание непротиворечивости данных. С другой стороны, сгруппировав соответствующую информацию, документное хранилище предоставляет большую гибкость:

- отсутствие необходимости в соединении строк;
- возможность обойтись без фиксированных схем;
- каждая запись может содержать уникальное сочетание полей.

В документных хранилищах отсутствуют таблицы и строки. Вместо этого используются записи, называемые документами, которые объединяются в коллекции. Каждый документ имеет поле первичного ключа, что позволяет устанавливать связи между ними. Тем не менее, операции JOIN в документных хранилищах обычно неэффективны, а в некоторых случаях даже невозможны, что требует от разработчиков ручного управления связями между документами. Это может приводить к дублированию данных, если документы содержат общую информацию.

Как и в реляционных базах данных, в NoSQL системах создаются индексы для полей с первичным ключом. Также возможно определять дополнительные индексы для полей, которые часто запрашиваются или сортируются.

## База данных «ключ — значение»

База данных «ключ — значение» представляет собой самую простую форму организованного хранения данных и в основном используется для кэширования. Например, когда пользователь запрашивает определённую веб-страницу на сервере, необходимо извлечь соответствующие данные из базы данных и использовать их для формирования HTML-разметки, которую увидит пользователь. В условиях высокой посещаемости сайта, когда происходит множество параллельных запросов, выполнение этой операции становится затруднительным.

Для решения этой проблемы применяется хранилище «ключ — значение» в качестве механизма кэширования. В данном случае ключом выступает URL-адрес, а значением — HTML-разметка соответствующей веб-страницы. При повторном запросе того же URL-адреса готовый код HTML извлекается из хранилища «ключ — значение» по ключу-адресу.

Если вам приходится неоднократно выполнять медленную операцию, приводящую к одному и тому же результату, стоит рассмотреть возможность её кэширования. Хотя для кэширования можно использовать и базы данных других типов, хранилища данных типа «ключ — значение» представляют собой наилучший вариант, особенно в случаях, когда кэш запрашивается очень часто.

## Графовые базы данных

В графовой базе данных записи хранятся в виде вершин, а связи — в виде рёбер. Вершины не привязаны к фиксированной схеме и могут содержать данные в различных форматах. Графовая структура обеспечивает эффективную работу с записями на основе их взаимосвязей. На рисунке ниже представлена информация, представленная в виде графа:

![images](graph_db.png)

Графовые базы данных являются наиболее гибким типом баз данных. Избавившись от таблиц и коллекций, вы можете хранить сетевые данные интуитивно понятным образом. Например, если бы вам нужно было изобразить станции метро и остановки наземного общественного транспорта, вы бы не стали делать это в табличной форме; вместо этого использовались бы круги, прямоугольники и стрелки. Графовые БД позволяют сохранять информацию именно так.

Если ваши данные имеют сетевой характер, стоит рассмотреть возможность использования графовой базы данных. Этот тип БД особенно полезен, когда между компонентами данных существует множество важных связей. Графовые базы данных также позволяют выполнять различные типы графориентированных запросов. Например, если вы храните данные об общественном транспорте в графе, можно прямо запросить оптимальный маршрут между двумя остановками, как в одну сторону, так и туда и обратно.

## Большие данные

Термин «большие данные» (big data), ставший популярным в последнее время, описывает ситуации обработки данных, которые отличаются высокой сложностью в аспектах объёма, скорости и разнообразия.

**Объём** больших данных может включать обработку тысяч терабайт информации, например, в случае Большого адронного коллайдера (БАК). **Скорость** подразумевает необходимость сохранять миллионы записей в секунду без задержек или быстро выполнять миллиарды запросов на чтение. **Разнообразие** указывает на отсутствие строгой структуры данных, что затрудняет их обработку с использованием традиционных реляционных баз данных.

Когда требуется нестандартный подход к управлению данными в связи с их объёмом, скоростью или разнообразием, можно утверждать, что вы имеете дело с большими данными. В современных научных экспериментах, таких как исследования, связанные с БАК или с радиоинтерферометром SKA, специалисты уже исследуют область мегаданных, предполагающую хранение и анализ миллионов терабайт информации.

Большие данные часто ассоциируются с нереляционными базами данных, благодаря их повышенной гибкости. Многие типы приложений, работающих с большими данными, практически невозможно реализовать с использованием реляционных баз данных.

## SQL vs NoSQL

Реляционные базы данных (РБД) ориентированы на данные, максимизируя их структурирование и минимизируя дублирование. Нереляционные базы данных (NoSQL), напротив, ориентированы на применение, упрощая доступ и использование данных в соответствии с потребностями разработчика. Базы данных NoSQL позволяют быстро и эффективно сохранять крупные, изменчивые и неструктурированные данные. Разработка становится быстрее, поскольку не нужно беспокоиться о фиксированных схемах и миграциях.

Однако стоит помнить, что ответственность за обновление дублированной информации в NoSQL системах лежит на разработчике. Поддержание согласованности данных — это ваша задача. Большая мощь этих БД сопровождается высокой ответственностью.
### Распределенная модель

В некоторых ситуациях поддержка базы данных требует работы нескольких компьютеров. Это может быть необходимо в следующих случаях:

- Базы данных объемом в несколько сотен терабайт, когда сложно найти единый компьютер с достаточным пространством.
- Системы, обрабатывающие тысячи одновременных запросов, которые превышают возможности одного компьютера.
- Жизненно важные базы данных, где полагаться на один компьютер слишком рискованно, например, при регистрации данных о полете самолета.

Для таких случаев существуют распределенные базы данных, работающие на нескольких координированных компьютерах. Рассмотрим основные способы их организации.

### Репликация с одним ведущим

В этой модели один компьютер (ведущий) получает все запросы к базе данных и подключен к нескольким ведомым компьютерам, которые содержат его реплики. Когда ведущий обрабатывает запросы на запись, он синхронизирует данные с ведомыми компьютерами. Это позволяет ведущему обслуживать больше запросов на чтение, делегируя их ведомым.

![images](pc_db.png)

Если ведущий компьютер выходит из строя, ведомые машины могут автоматически выбрать нового ведущего, что повышает надежность системы.

### Репликация с многочисленными ведущими

Для систем, которые должны обрабатывать большое количество одновременных записей, один ведущий может быть недостаточен. В этом случае все компьютеры становятся ведущими, и балансировщик нагрузки равномерно распределяет запросы на запись и чтение.

![images](pc_db_1.png)

Каждый компьютер имеет копию всей базы данных и может обрабатывать запросы одновременно.
### Фрагментирование

Если база данных получает много запросов на запись больших объемов данных, может быть сложно синхронизировать ее по всем компьютерам. Решением может стать фрагментирование — разделение базы данных на части, каждая из которых хранится на отдельном компьютере. Запросы направляются к соответствующим машинам.

Такое решение позволяет обрабатывать большое количество запросов, но есть риск, что при выходе одного компьютера из строя фрагмент данных станет недоступен. Чтобы снизить риски, фрагментирование может сочетаться с репликацией.

![images](pc_db_2.png)

![images](pc_db_3.png)

В этой конфигурации каждый фрагмент поддерживает кластер «ведущий — ведомый», что улучшает надежность и скорость обработки запросов.

### Непротиворечивость данных

В распределенных базах данных обновления, выполненные на одной машине, не сразу распространяются на все копии. Это может привести к нарушению согласованности данных. Например, если два пользователя одновременно покупают один и тот же билет на разных серверах, может возникнуть конфликт.

Чтобы избежать таких проблем, многие СУБД предлагают инструменты для обеспечения согласованности данных, но это может снизить производительность, особенно при транзакциях, требующих координации между всеми машинами.

Существует компромисс между согласованностью и производительностью. Если ваши запросы не требуют строгой согласованности, система может работать в режиме потенциальной непротиворечивости, где данные гарантированно станут согласованными в конечном итоге, хотя некоторые запросы могут возвращать устаревшую информацию. В большинстве случаев это приемлемо, например, если на странице продукта отображается незначительное количество отзывов, которое может быть устаревшим.
## Географическая модель

Географические базы данных хранят пространственную информацию, такую как расположение городов, границы государств, схемы автотрасс и железных дорог. Эти данные необходимы для различных приложений, например, для служб экстренной помощи, которые должны быстро находить ближайшие медицинские учреждения.

Для работы с такой информацией разработаны географические информационные системы (ГИС), которые включают специальные поля для хранения географических данных, такие как `PointField` (точка), `LineField` (линия), и `PolygonField` (многоугольник). ГИС могут выполнять пространственные запросы, например: «Найдите города в пределах 10 миль от реки Миссисипи, упорядоченные по численности населения». Эти системы используют пространственные индексы, что делает поиск по близости эффективным.

![images](mapa_1.png)

ГИС также позволяют устанавливать пространственные ограничения. Например, в таблице земельных участков можно задать правило, что участки не должны перекрываться, что значительно упрощает работу с кадастровыми данными. Многие общие СУБД предлагают расширения для ГИС, поэтому важно использовать базы данных с поддержкой географических функций для создания более сложных запросов. Примеры использования ГИС можно найти в GPS-навигаторах, таких как Google Maps или Waze.

## Форматы сериализации

Сериализация данных позволяет хранить их вне базы данных в формате, совместимом с различными системами. Это необходимо для дублирования данных или экспорта в другие системы. Рассмотрим несколько широко используемых форматов сериализации:

- **SQL**: Это самый распространенный формат для реляционных баз данных. С помощью SQL можно создавать дампы базы данных и восстанавливать их. Большинство реляционных СУБД поддерживают команды `DUMP` и `RESTORE`.
    
- **XML**: Формат XML подходит для представления структурированных данных и разработан для совместимости с различными вычислительными системами. Хотя он может быть сложен в использовании, XML описывает структуру данных, что делает его универсальным.
    
- **JSON**: Все более популярный формат среди разработчиков. JSON интуитивно понятен и может представлять как реляционные, так и нереляционные данные. Существуют расширения JSON, такие как BSON (двоичный JSON) для повышения эффективности и JSON-LD, который добавляет мощные возможности структуры, аналогичные XML.
    
- **CSV**: Формат CSV (значения, разделенные запятыми) — это простой способ обмена данными. Данные хранятся в текстовом виде, по одной записи на строку, а поля разделяются запятой или другим символом. Хотя CSV удобен для простых баз данных, он не подходит для сложных структур данных.
    
Эти форматы сериализации помогают обеспечить совместимость данных между различными системами и упрощают их обмен.

## Полезные материалы 

- [Введение в базы данных](https://habr.com/ru/articles/686816/)
- Краткий бесплатный онлайн курс — [Udacity — Intro to Relational Databases](https://www.udacity.com/course/intro-to-relational-databases--ud197)
- [Advanced SQLite Usage in Python](http://pythoncentral.io/advanced-sqlite-usage-in-python/)  
- [SQLite Python Tutorial на tutorialspoint.com](https://www.tutorialspoint.com/sqlite/sqlite_python.htm)  
- [A thorough guide to SQLite database operations in Python](http://sebastianraschka.com/Articles/2014_sqlite_in_python_tutorial.html)  
- [The Novice's Guide to the Python 3 DB-API](http://www.philvarner.com/test/ng-python3-db-api/) 
- Справочные руководства по SQLite онлайн:  
    - [www.tutorialspoint.com/sql/index.htm](https://www.tutorialspoint.com/sql/index.htm)
    - [www.tutorialspoint.com/sqlite](https://www.tutorialspoint.com/sqlite/)
    - [www.sqlitetutorial.net](http://www.sqlitetutorial.net/)