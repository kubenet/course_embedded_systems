# Курс: Информатика
## Практическое занятие №2. "Работа в bash"

Команды bash являются неотъемлемой частью разработки. Командная строка, не только bash, но и другие, дает бОльшие возможности по сравнению с любым графическим интерфейсом. Любой интерфейс полагается на эти команды и вызывает их с соответствующими параметрами. 

## Мотивация

1. Относитесь к `bash` как универсальному скриптовому языку, который покажет одинаковое поведение на разных системах Линукс. С помощью bash и различных утилит мы можем получать доступ к "железу" машины, на которой работаем, и настраивать автоматические сценарии. Это можно осуществить и с использованием языков программирования, но сделать это будет сложнее, и реализация будет зависеть от конкретного языка программирования. Но если мы напишем `bash`, то "дернуть" его из любого языка программирования не составит труда, так как большинство из них поддерживает системные вызовы. Если же вызов системных функций невозможен или неудобен, обмен информацией всегда доступен через файлы, куда можно записать информацию из `bash`-скрипта, а прочитать из `python`.


2. При работе на своей компьютере вы можете не оценить все достоинства командной строки, однако она точно понадобится, чтобы настроить работу вашего приложения на удаленном сервере, физическом или виртуальном, к которому вы будете подключаться по ssh и на котором может быть в принципе не установлен оконный интерфейс. 

Ниже будут описаны команды, которые помогут ходить по файловой системе, создавать, копировать и перемещать файлы, изменять разрешения для файлов, передавать владельца у файла, просматривать запущенные процессы и открытые порты.
Предположим, у нас есть пользователь с именем **artem**, на машине, которая называется **pc**. Тогда при запуске командной строки мы увидим предложение ввода команды:

```bash
artem@pc:/$ 
```

Мы видим, что здесь указаны имя пользователя и имя компьютера через символ `@`. Далее после двоеточия (`:`) указан текущий путь, сейчас мы находимся в корневой директории, далее символ `$` для отделения команды. Начнем изучение командной строки с команды, которая позволяет ходить по файловой системе. 

**Hint: при нажатии на стрелку вверх в командную строку будет подставлена предыдущая команда. Стрелку можно нажимать несколько раз**

**Hint: Дополнительные информацию и опции по каждой команде можно увидеть вызвав** `man command` **или** `command --help`, `man` **сокращенно от manual**

Мы надеемся, что это было достаточно убедительно, чтобы не пройти мимо темы `bash`. 

## cd - change directory

Команда для смены директории. При вызове происходит переход в директорию, которая указана после команды `cd /path/to/destination`. Предположим, у нас есть пользователь с именем artem. Следующие команды можно выполнить, чтобы перейти сначала в директорию `home`, а затем в домашнюю директорию пользователя `/home/artem`:
```bash
artem@pc:/$ cd /home
artem@pc:/home$ cd ./artem
artem@pc:~$
```
Заметьте, что во втором случае мы использовали `./` для перехода по относительному пути. Также видно, что меняется текущий путь, в котором мы находимся: в первой строке это была корневая директория (`/`), во второй — директория, в которой содержатся все домашние директории всех пользователей данной системы (`/home`). В третьей строке вместо пути мы видим символ `~`, который является сокращением для домашней папки конкретного пользователя. Две команды выше эквиваленты одной команде с указанием абсолютного пути:

```bash
artem@pc:/$ cd /home/artem
```

Команда `cd /artem` вызовет ошибку, так как будет происходить поиск в корневой директории, а в ней **НЕ** содержится директории `artem`. 
При использовании `cd` можно использовать сокращения, которые позволяют переходить по определенным путям, не прописывая полный путь (в примерах ниже `#` означает начало комментария): 

```bash
    cd ~        # переход в домашнюю папку
    cd ../      # переход на один уровень выше
    cd ../../   # переход на два уровня выше, чтобы уйти еще выше, можно добавлять ../
    cd -        # возврат в предыдущую директорию
    cd .        # текущий каталог
```

При использовании команды `cd` необязательно помнить полное наименование директории. Можно начать писать путь и затем нажать на TAB для автодополнения. 

```bash
artem@pc:/$ cd /usr/loc     # нажимаем TAB
artem@pc:/$ cd /usr/local/
```
Если написанного пользователем будет недостаточно для того, чтобы однозначно определить путь, командная строка выдаст все возможные варианты:
```bash
user#pc: cd /usr/l     # нажимаем TAB
lib/    libexec/    local/
user#pc: cd /usr/l
```

Вопросы для проверки: 

*Что можно указать после команды cd?*  

* Абсолютный путь (верно) 
* Относительный путь (верно)
* Адрес веб-сайта (НЕверно)
* Один из специальных наборов символов, например, `../` (верно)

## ls - list 

Для просмотра содержимого директории можно использовать **ls**. При вызове без параметров будет показано содержимое *текущей директории*. Также можно указать путь `ls /path/to/dir`, в этом случае будет показано содержимое *указанной директории*.
```terminal
root@de30378728be:/# ls
bin   etc   lib32   media  proc  sbin  tmp
boot  home  lib64   mnt    root  srv   usr
dev   lib   libx32  opt    run   sys   var
```

Мы видим, что разные имена подкрашены по-разному, на картинке выше три вида разметки. В вашей командой строке цвета могут отличаться. На картинке синий обозначает директорию, черный — обычный файл и зеленый — исполняемый файл. Но как понять это без цветовой индикации? Для этого вызовите `ls -l`:
```bash
root@de30378728be:/# ls -la
total 56
drwxr-xr-x   1 root root 4096 Sep 22 07:33 .
drwxr-xr-x   1 root root 4096 Sep 22 07:33 ..
-rwxr-xr-x   1 root root    0 Sep 22 07:33 .dockerenv
lrwxrwxrwx   1 root root    7 Aug 16 02:02 bin -> usr/bin
drwxr-xr-x   2 root root 4096 Apr 18  2022 boot
drwxr-xr-x   5 root root  360 Sep 22 07:33 dev
drwxr-xr-x   1 root root 4096 Sep 22 07:33 etc
drwxr-xr-x   2 root root 4096 Apr 18  2022 home
lrwxrwxrwx   1 root root    7 Aug 16 02:02 lib -> usr/lib
lrwxrwxrwx   1 root root    9 Aug 16 02:02 lib32 -> usr/lib32
lrwxrwxrwx   1 root root    9 Aug 16 02:02 lib64 -> usr/lib64
lrwxrwxrwx   1 root root   10 Aug 16 02:02 libx32 -> usr/libx32
drwxr-xr-x   2 root root 4096 Aug 16 02:03 media
drwxr-xr-x   2 root root 4096 Aug 16 02:03 mnt
drwxr-xr-x   2 root root 4096 Aug 16 02:03 opt
dr-xr-xr-x 604 root root    0 Sep 22 07:33 proc
drwx------   2 root root 4096 Aug 16 02:06 root
drwxr-xr-x   5 root root 4096 Aug 16 02:06 run
lrwxrwxrwx   1 root root    8 Aug 16 02:02 sbin -> usr/sbin
drwxr-xr-x   2 root root 4096 Aug 16 02:03 srv
dr-xr-xr-x  13 root root    0 Sep 22 07:33 sys
drwxrwxrwt   2 root root 4096 Aug 16 02:06 tmp
drwxr-xr-x  14 root root 4096 Aug 16 02:03 usr
drwxr-xr-x  11 root root 4096 Aug 16 02:06 var
```

Теперь мы видим больше информации по каждому файлу и директории в `/`. Среди этой информации: разрешение, владелец, группа, размер, дата последнего изменения, имя файла. Как видите, директория имеет букву `d` в разрешениях, а исполняемый файл, в отличие от неисполняемого, имеет атрибут `x`. 

Для просмотра скрытых файлов нужно указать параметр `a`. К скрытым файлам относятся директории, которые создаются при инициализации репозитория git.

```bash
root@de30378728be:/# ls -a
.           boot  lib     media  root  sys
..          dev   lib32   mnt    run   tmp
.dockerenv  etc   lib64   opt    sbin  usr
bin         home  libx32  proc   srv   var
```

## clear 

Командой **clear** можно очистить терминал от вывода. При этом история команд останется, и их по-прежнему можно доставать, нажимая на стрелку вверх. 

```bash
root@de30378728be:/# ls -a
.           boot  lib     media  root  sys
..          dev   lib32   mnt    run   tmp
.dockerenv  etc   lib64   opt    sbin  usr
bin         home  libx32  proc   srv   var
root@de30378728be:/# clear
```

При использовании clear мы увидим пустой терминал:
```bash
root@de30378728be:/#




```

## mkdir - make directory

Для создания директорий мы используем команду **mkdir**. Так же, как в случае с **cd** и **ls**, мы можем использовать относительный путь. Если директория уже существует, будет выдано сообщение об ошибке.
```bash
root@de30378728be:/# mkdir test
root@de30378728be:/# ls
bin   home   libx32  proc  srv   usr
boot  lib    media   root  sys   var
dev   lib32  mnt     run   test
etc   lib64  opt     sbin  tmp
root@de30378728be:/# cd test/
root@de30378728be:/test# ls -a
.  ..
root@de30378728be:/test#
```

## touch

Представьте ситуацию: нужно узнать время, когда последний раз запускалось то или иное приложение, которое запускается в фоне. Существует множество способов это сделать: запись в базе данных, анализ логов и так далее. Самой простой способ для bash-скрипта — изменение времени последнего изменения какого-либо файла. Это можно сделать, записав что-то в файл. Если такой вариант не подходит, воспользуйтесь командой `touch`, которая как раз предназначена для изменения времени обращения к файлу на текущее, при этом открытие файла не происходит. 

```bash
root@de30378728be:/test# touch .req.txt
root@de30378728be:/test# ls -l
total 0
root@de30378728be:/test# ls -l .req.txt
-rw-r--r-- 1 root root 0 Sep 22 07:54 .req.txt
root@de30378728be:/test# touch .req.txt
root@de30378728be:/test# ls -l .req.txt
-rw-r--r-- 1 root root 0 Sep 22 07:55 .req.txt
```

Если файл не существует, он будет создан пустым, если не указан аргумент `-с`.
```bash
root@de30378728be:/test# touch .req.txt
root@de30378728be:/test# ls -l
total 0
root@de30378728be:/test# ls -l .req.txt
-rw-r--r-- 1 root root 0 Sep 22 07:54 .req.txt
root@de30378728be:/test# touch .req.txt
root@de30378728be:/test# ls -l .req.txt
-rw-r--r-- 1 root root 0 Sep 22 07:55 .req.txt
root@de30378728be:/test# touch -c text.txt
root@de30378728be:/test# ls
root@de30378728be:/test# ls -a
.  ..  .req.txt
root@de30378728be:/test#
```

## cat - concatenate

Читает содержимое файлов и выводит его. Добавим в project директорию `data` и два файла `items_part1.txt` и `items_part2.txt`.

```bash
root@de30378728be:/test# echo "Hello" > text.txt
root@de30378728be:/test# echo "World" > text1.txt
root@de30378728be:/test# ls -la
total 16
drwxr-xr-x 2 root root 4096 Sep 22 07:56 .
drwxr-xr-x 1 root root 4096 Sep 22 07:53 ..
-rw-r--r-- 1 root root    6 Sep 22 07:56 text.txt
-rw-r--r-- 1 root root    6 Sep 22 07:56 text1.txt
root@de30378728be:/test# cat .
./  ../
root@de30378728be:/test# cat text
text.txt   text1.txt
root@de30378728be:/test# cat text.txt
Hello
root@de30378728be:/test# cat text1.txt
World
```

Можно использовать `cat` для склеивания содержимого нескольких файлов: укажите несколько файлов после cat, затем `>>` и имя файла, в который нужно слить данные. Символы `>>` означают перенаправление потока, т.е. мы делаем вывод не в стандартный поток, а, например, в файл.
```bash
root@de30378728be:/test# cat text.txt text1.txt >> text2.txt
root@de30378728be:/test# cat text2.txt
Hello
World
```

С помощью cat можно пронумеровать строки в файлах сквозной нумерацией.
```bash
root@de30378728be:/test# cat -n text.txt text1.txt
     1	Hello
     2	World
```

**Hint: посмотрите также команды `head` и `tail`, они выводят начало и конец файлов. `tail` будет удобен для просмотра журнала логов.**

**Hint: `>>` и `>` перенаправляют поток и создают файл, если его нет. Отличие состоит в том, что `>>` добавляет новое содержимое в конец файла, а `>` перезаписывает файл, удаляя предыдущее содержимое этого файла.**

## echo

Обычно используется в скриптах для вывода информации (как `print` в `python`). Также с помощью **echo** можно записать строку в файл, если файла не было, он будет создан.

```bash
root@de30378728be:/test# echo "Hello world" >> text2.txt
root@de30378728be:/test# cat text2.txt
Hello
World
Hello world
root@de30378728be:/test#
```

## export

Используется для установки переменных среды. Команда `export` отмечает переменную окружения для экспорта с любым новым дочерним процессом, и это позволяет дочернему процессу наследовать все отмеченные переменные. Они нам понадобятся для того, чтобы использовать ту информацию, которую мы не хотим прописывать в коде приложения, например, параметры доступа. Хардкодить такие значения неудобно, так как можно случайно закоммитить их, и придется все менять. Например, так сделано в проекте по созданию [чат-бота](https://github.com/gcatanese/SampleTelegramQuiz), посмотрите секцию **Setup** в README. Ниже приведен пример использования `export`.

```bash
root@de30378728be:/test# echo $INFO

root@de30378728be:/test# export INFO=42
root@de30378728be:/test# echo INFO
INFO
root@de30378728be:/test# echo $INFO
42
```
Подробнее с вариантами использования `export` можно ознакомиться [здесь](https://www.digitalocean.com/community/tutorials/export-command-linux). 

## $ 

Есть несколько конструкций, в которые входит `$`. Это может путать, но если относиться к этим конструкциям, как к обособленными элементам `bash`, так их легче воспринимать.

Символ `$` ставится перед переменной для того, чтобы получить ее значение. По умолчанию любое имя считается строкой.
```bash
root@de30378728be:/test# name=Jonh
root@de30378728be:/test# echo name
name
root@de30378728be:/test# echo $name
Jonh
root@de30378728be:/test# echo "Hello, $name"
Hello, Jonh
root@de30378728be:/test# echo "Hello, name"
Hello, name
```

При этом использование `$` внутри двойных кавычек и без них может вызвать разное поведение, если в значении переменной содержатся специальные символы. Если `$` используется в двойных кавычках, то значение переменной будет выдено как есть. Если `$` используется без кавычек, то `bash` проведет интерпретацию специальных символов, например, как ниже с `*`, которую мы использовали для поиска файлов по шаблону.

Другое использование `$` — запись вывода команды в переменную. В этом случае `$` используется совместно со скобками.
```
root@de30378728be:/test# echo "some text" > text.txt
root@de30378728be:/test# content=$(cat text.txt)root@de30378728be:/test# echo $content
some text
root@de30378728be:/test#
```

В `bash` нельзя просто так взять и выполнить математическую операцию. Для этого используется `$` совместно с двойными скобками.

```bash
root@de30378728be:/test# result=1+2
root@de30378728be:/test# echo $result
1+2
root@de30378728be:/test# result=$(1+2)
bash: 1+2: command not found
root@de30378728be:/test# result=$((1+2))
root@de30378728be:/test# echo $result
3
root@de30378728be:/test#
```

Также `$` используется для получения значений аргументов, переданных в скрипт. Можно считать, что сама оболочка присваивает номера переменным вместо того, чтобы именовать их. Это похоже на то, как мы используем `sys.argv[N]` в `python`, когда хотим получить то, что передано при вызове нашей программы. 
```bash
root@de30378728be:/test# echo "echo \"First is \$1 and second is \$2\"" > script.bash

root@de30378728be:/test# cat script.bash
echo "First is $1 and second is $2"
root@de30378728be:/test# chmod +x script.bash
root@de30378728be:/test# ./script.bash John Doel
First is John and second is Doel
root@de30378728be:/test#
```

Первая команда на скриншоте выше используется для того, чтобы создать код скрипта. Вы также можете взять код из двойных кавычек `echo "First is $1 and second is $2"` и сохранить его в файл `script.bash`, используя любой текстовый редактор. Описание `chmod` смотрите ниже.

Есть еще один вариант использования `$`, но на этот раз с фигурными скобками. Это назвается parameter expansion и позволяет произвести операции над значениями переменной и передать результат дальше. Ниже пример со строкой `name=ArtemVesnin` и срезами, а также со списком `name=(Artem Vesnin)` и обращением к элементам списка.
```bash
root@de30378728be:/test# name=(Artem Doel)
root@de30378728be:/test# echo ${name[1]}
Doel
root@de30378728be:/test# echo ${name[0]}
Artem
```
Также существует специальная переменная `$?`, куда записывается статус выполнения последней команды.

```bash
ls non_existent_file.txt
if test $? -ne 0 ; then
  echo "Error: File not found or other issue occurred."
fi
```
```bash
root@de30378728be:/test# ls non_ext_file.txt
ls: cannot access 'non_ext_file.txt': No such file or directory
root@de30378728be:/test# test $? -eq 0 && echo "File ext"
root@de30378728be:/test# touch file_ext.txt
root@de30378728be:/test# ls file_ext.txt
file_ext.txt
root@de30378728be:/test# test $? -eq 0 && echo "File ext"
File ext
root@de30378728be:/test#
```
![command_output_status](/graphics/command_output_status.png)

Здесь мы использовали `test` для проведения операций сравнения. `-eq` сокращенно от equal. 

## rm — remove

Для удаления файлов используется команда **rm**. Удалить можно один файл, указав путь до него, или несколько, указав ту часть пути, которая может меняться через `*`, т.е. задав шаблон, в который должны вписаться пути.
```bash
root@de30378728be:/test# ls
file_ext.txt  text.txt   text2.txt
script.bash   text1.txt
root@de30378728be:/test# rm script.bash
root@de30378728be:/test# ls
file_ext.txt  text.txt  text1.txt  text2.txt
root@de30378728be:/test# rm text*
root@de30378728be:/test# ls
file_ext.txt
root@de30378728be:/test#
```

Удаление каталогов требует дополнительных опций, так как удаляются не отдельные файлы, а все содержимое каталога, поэтому нужно делать это рекурсивно, заходя во все вложенные каталоги.
```bash
root@de30378728be:/test# mkdir dir
root@de30378728be:/test# ls
dir  file_ext.txt
root@de30378728be:/test# rm dir/
rm: cannot remove 'dir/': Is a directory
root@de30378728be:/test# rm -r dir/
root@de30378728be:/test# ls
file_ext.txt
root@de30378728be:/test#
```

## rmdir — remove directory

Удаление пустых директорий или группы вложенных пустых директорий. 
```bash
root@de30378728be:/test# ls
file_ext.txt
root@de30378728be:/test# mkdir a
root@de30378728be:/test# mkdir -p a/{a..z}
root@de30378728be:/test# tree a/
a/
|-- a
|-- b
|-- c
|-- d
|-- e
|-- f
|-- g
|-- h
|-- i
|-- j
|-- k
|-- l
|-- m
|-- n
|-- o
|-- p
|-- q
|-- r
|-- s
|-- t
|-- u
|-- v
|-- w
|-- x
|-- y
`-- z

26 directories, 0 files
root@de30378728be:/test# rmdir a/
a/ c/ e/ g/ i/ k/ m/ o/ q/ s/ u/ w/ y/
b/ d/ f/ h/ j/ l/ n/ p/ r/ t/ v/ x/ z/
root@de30378728be:/test# rmdir a/a/
root@de30378728be:/test# tree a/
a/
|-- b
|-- c
|-- d
|-- e
|-- f
|-- g
|-- h
|-- i
|-- j
|-- k
|-- l
|-- m
|-- n
|-- o
|-- p
|-- q
|-- r
|-- s
|-- t
|-- u
|-- v
|-- w
|-- x
|-- y
`-- z

25 directories, 0 files
root@de30378728be:/test# rmdir -rf a/
rmdir: invalid option -- 'r'
Try 'rmdir --help' for more information.
root@de30378728be:/test# rmdir -p a/
rmdir: failed to remove 'a/': Directory not empty
root@de30378728be:/test# rm -rf a/
b/ d/ f/ h/ j/ l/ n/ p/ r/ t/ v/ x/ z/
c/ e/ g/ i/ k/ m/ o/ q/ s/ u/ w/ y/
root@de30378728be:/test# rm -rf a/
root@de30378728be:/test# tree a
a  [error opening dir]

0 directories, 0 files
root@de30378728be:/test#
```

Обратите внимание на сообщение об ошибке (вообще всегда смотрите на результат ваших действий, чтобы понимать, выполнилась ли команда). Часть работы была сделана: удалены директории `./a/b` и `./a`. А самый верхний уровень этого пути (`.`) — это, как мы помним, текущая директория, т.е. `~/project/data`, и rmdir сам не дает пользователю удалить директорию, в которой он находится. Правильным будет `mkdir -p a/b`, хотя в большинстве случаев ./a/b и a/b равнозначны.

## cp — copy

Копирует один или несколько файлов из одного места в другое. Так же, как и в случае с `rm`, можно указывать шаблон, которому должны соответствовать пути. 
```bash
root@de30378728be:/test# mkdir a
root@de30378728be:/test# mkdir b
root@de30378728be:/test# touch a/a.txt a/b.txt a/c.txt
root@de30378728be:/test# ls a
a.txt  b.txt  c.txt
root@de30378728be:/test# cp a/*.txt b/
root@de30378728be:/test# ls a
a.txt  b.txt  c.txt
root@de30378728be:/test# ls b
a.txt  b.txt  c.txt
root@de30378728be:/test#
```

## mv — move

Перемещает один или несколько файлов из одного места в другое. Так же, как и в случае с `rm`, можно указывать шаблон, которому должны соответствовать пути. 

```bash
root@de30378728be:/test# ls a/
a.txt  b.txt  c.txt
root@de30378728be:/test# mkdir c
root@de30378728be:/test# mv a/*.txt c
root@de30378728be:/test# ls a
root@de30378728be:/test# ls c
a.txt  b.txt  c.txt
```

`mv` можно использовать для переименования файлов.

```bash
root@de30378728be:/test# ls
a  b  c  file_ext.txt
root@de30378728be:/test# mv file_ext.txt file_change.txt
root@de30378728be:/test# ls
a  b  c  file_change.txt
root@de30378728be:/test#
```
## chmod — change mode

Изменяет разрешения файлов и директорий. Помните, на рисунке, который уже был выше, `script.bash` подсвечивался зеленым? Это означало, что у него есть разрешение на исполнение. Давайте удалим его. Создадим скрипт заново и запишем туда строку `ls -l` с помощью `echo`, попробуем выполнить, получим ошибку, потом попробуем дать разрешение на исполнение и выполним еще раз.
```bash
root@de30378728be:/test# touch script.sh
root@de30378728be:/test# echo "ls -a" >> script.sh
root@de30378728be:/test# ./scrpit.sh
bash: ./scrpit.sh: No such file or directory
root@de30378728be:/test# ls
script.bash  script.sh  typescript
root@de30378728be:/test# ./script.sh
bash: ./script.sh: Permission denied
root@de30378728be:/test# ls -l script.sh
-rw-r--r-- 1 root root 6 Sep 22 08:18 script.sh
root@de30378728be:/test# chmod +x script.sh
root@de30378728be:/test# ./script.sh
.  ..  script.bash  script.sh  typescript
root@de30378728be:/test# ls -l script.sh
-rwxr-xr-x 1 root root 6 Sep 22 08:18 script.sh
```

Разрешения делятся на три категории:
- **`r`** *(read)* — чтение; 
- **`w`** *(write)* — запись; 
- **`x`** *(execute)* — исполнение. 

А также на три уровня: 
1. Владелец файла или директории.
2. Группа пользователей, к которой принадлежит владелец.
3. Все остальные. 

К примеру, права доступа `[drwxrwxrwx]` дают полный доступ на чтение, редактирование и запуск абсолютно всем пользователям. Рассмотрим этот случай подробнее. Ключи доступа из примера можно поделить на 4 секции: 1 — `[d]`, 2 — `[rwx]`, 3 — `[rwx]`, 4 — `[rwx]`.

1 секция может быть либо «d» — директория, либо «-» — файл.
2 секция показывает права доступа владельца файла или директории (r — чтение, w — запись, x — выполнение).
3 секция показывает права доступа группы, в которой находится владелец, rwx — аналогично.
4 секция показывает права доступа всех остальных пользователей системы.

Например, `-rwxr-xr--` означает, что владелец может читать, писать и исполнять файл, пользователи из группы — только читать и исполнять, все остальные — только читать. Можно вообще не давать разрешений, например, `-rwxr-x---` запретит доступ к файлу всем пользователям, кроме его владельца (того, кто создал этот файл) и участникам группы, к которой он относится.

> Все группы, созданные в системе, находятся в файле /etc/group. Посмотрев содержимое этого файла, вы увидите список групп linux, которые уже есть в вашей системе. Этот список может быть большим и малоинформативным для рядового пользователя. Чтобы вывести список всех групп, членом которых является текущий пользователь, можно использовать команду `groups`.


## sudo — superuser do

В большинстве случае для выполнения команд описанных, выше достаточно обычных прав, которые имеются у пользователя. Но в ряде случаев, при использовании системных утилит или смене владельца у файла (см. `chown` ниже), необходимо использовать права суперпользователя. Первый способ — авторизоваться, используя аккаунт суперпользователя в системе. Но такой сценарий не является предпочтительным, так может привести к случайному выполнению команды, которая может нанести вред системе. Более широкое применение получил способ, при котором для выполнения команды с правами суперпользователя перед командой добавляется **`sudo`**. Ниже представлен пример передачи владения скрипта пользователю root, после этого мы сможем выполнять скрипт только от имени нового владельца, т.е. `root` (для текущих разрешений скрипта `-rwxrwxr--`).

## chown — change owner

Изменяет владельца файла или директории. При этом, если вы хотите сделать это рекурсивно, для всех файлов внутри директории, нужно указать специальный флаг `-R` для рекурсивной работы. При использовании мы указываем имя пользователя и группу через двоеточие `username:group`. Каждый пользователь может состоять в одной или нескольких группах. Можно менять владельца и не менять группу. В примере ниже мы вернули владение группе `artem`, и теперь можем запускать файл от обычного пользователя (для текущих разрешений скрипта `-rwxrwxr--`).

## history 

Выводит историю выполненных команд.

```bash
  136  ./script.sh
  137  ls -a script.sh
  138  ls -l script.sh
  139  chmod +x script.sh
  140  ./script.sh
  141  ls -l script.sh
  142  sudo chown root:user script.sh
  143  chown root:user script.sh
  144  history
root@de30378728be:/test#
```

## grep — global regular expression print

Производит поиск в тексте строки, содержащей определенную подстроку. При этом текст можно получить прямо из стандартного вывода или из файла. Бывает полезным, чтобы вспомнить, как выполнялась та или иная команда в `bash`. 
```bash
root@de30378728be:/test# history | grep "ls"
    1  ls
    2  ls -la
    4  ls -a
    6  ls -a
    9  ls
   11  ls -a
   14  ls -la .req.txt
   16  ls -la
   18  ls -la
   20  ls -l
   21  ls -l .req.txt
   23  ls -l .req.txt
   25  ls
   26  ls -a
   30  ls -la
   71  ls non_ext_file.txt
   74  ls file_ext.txt
   76  ls
   78  ls
   80  ls
   82  ls
   85  ls
   99  ls
  100  ls -la
  101  ls
  114  ls a
  116  ls a
  117  ls b
  118  ls a/
  121  ls a
  122  ls c
  123  ls
  125  ls
  129  echo "ls -a" >> script.bash
  130  ls
  133  echo "ls -a" >> script.sh
  135  ls
  137  ls -a script.sh
  138  ls -l script.sh
  141  ls -l script.sh
```


Также можно облегчить себе поиск документации по `man`, если примерно помнить термин.

```bash
man ls | grep -
 ls - list directory contents
       entries  alphabetically if none of -cf‐
       tuvSUX nor --sort is specified.
       -a, --all
       -A, --almost-all
       --author
              with -l,  print  the  author  of
       -b, --escape
              print  C-style  escapes for non‐
       --block-size=SIZE
              with -l,  scale  sizes  by  SIZE
              '--block-size=M'; see SIZE  for‐
```

Или найти что-нибудь в документе, который вы читаете:


**Hint: `|` перенаправляет выходной поток от одной команды к входу другой. Можно использовать, чтобы миновать запись в файл на диске.**

## top — table of process

Выводит активные процессы, а также информацию по загрузке процессора и памяти. Информация будет обновляться в терминале. Чтобы выйти из этого режима, нажмите `Ctrl-C`. 
```
top - 08:25:04 up  2:48,  0 users,  load average
Tasks:   2 total,   1 running,   1 sleeping,   0
%Cpu(s):  0.9 us,  2.3 sy,  0.0 ni, 96.7 id,  0.
MiB Mem : 128642.9 total, 119383.9 free,   4106.
MiB Swap:   2048.0 total,   2048.0 free,      0.

    PID USER      PR  NI    VIRT    RES    SHR
      1 root      20   0    4624   3584   3072
    465 root      20   0    7332   3328   2816
```


**Hint: `htop` дополняет функциональность `top`. Поставьте `htop` через менеджер пакетов, который используется в вашем дистрибутиве (`sudo apt install htop` в Ubuntu).**

## 
## Работа в оболочке

Запустите команду несколько раз:

```bash
for i in $(seq 1 5); do echo hello; done
```


Есть что распаковать:

  - `for` x в списке; делать ТЕЛО; готово
    - `;` завершает команду – эквивалент новой строки
    - разделить `list`, присвоить каждому `x` и запустить тело
    - разделение — это «разделение пробелов», к которому мы еще вернемся.
    - в оболочке нет фигурных скобок, поэтому `do` + `done`
  - `$(seq 1 5)`
    - запустить программу `seq` с аргументами `1` и `5`
    - заменить всю `$()` выводом этой программы
    - эквивалентно
     ```bash
     for i in 1 2 3 4 5
     ```
- `echo hello `
    - все в сценарии оболочки является командой
    — в этом случае запустите команду `echo`, которая выведет свои аргументы
      с аргументом «hello».
    - все команды ищутся в `$PATH` (через двоеточие)

У нас есть переменные:
```bash
for f in $(ls); do echo $f; done
```

Будет печатать каждое имя файла в текущем каталоге.
Также можно устанавливать переменные, используя `=` (без пробела!):

```bash
foo=bar
echo $foo
```

Также есть несколько «специальных» переменных:

 - `$1` to `$9`: arguments to the script
 - `$0` name of the script itself
 - `$#` number of arguments
 - `$$` process ID of current shell

Чтобы печатать только каталоги

```bash
for f in $(ls); do if test -d $f; then echo dir $f; fi; done
```

  - `if CONDITION; then BODY; fi`
    - `CONDITION` — команда; если он возвращается со статусом выхода 0
      (успех), затем запускается `BODY`.
    - также можно подключить `else` или `elif`.
    - опять же, никаких фигурных скобок, поэтому `then` + `fi`
  - `test` — еще одна программа, обеспечивающая различные проверки и
    сравнения и завершаются с 0, если они истинны (`$?`)
    - `man COMMAND` ваш друг: `man test`
    - также можно вызвать с помощью `[` + `]`: `[ -d $f ]`
      - взгляните на `man test` и `который "["`


Но подождите! Это не верно! Что делать, если файл называется «My Documents»?

  - `for f in $(ls)` расширяется до `for f in My Documents`
  - сначала сделайте тест на «Моих», затем на «Документах»
  - не то, что мы хотели!
  - самый большой источник ошибок в сценариях оболочки

## Разделение аргументов

Bash разделяет аргументы по пробелам;не всегда то, что вы хотите!

  - необходимо использовать кавычки для обработки пробелов в аргументах
    `for f в "Моих документах"` будет работать правильно
    `test -d $f`: если `$f` содержит пробелы, `test` выдаст ошибку!
  - с `echo` всё в порядке, потому что разделение + объединение по пробелу
    но что, если имя файла содержит новую строку?! превращается в космос!
  - укажите все использование переменных, которые вы не хотите разделять
  — а как нам исправить наш скрипт выше?
    как вы думаете, что означает `for f в "$(ls)"`?

Глоббинг – вот ответ!

  — bash умеет искать файлы по шаблонам:
    - `*` любая строка символов
    - `?` любой одиночный символ
    - `{a,b,c}` любой из этих символов
  - `for f in *`: все файлы в этом каталоге
  - при подстановке каждый соответствующий файл становится отдельным аргументом
    - все равно нужно обязательно ставить кавычки при использовании_: `test -d "$f"`
  - можно создавать сложные выкройки:
    - `for f in a*`: все файлы, начинающиеся с `a`, в текущем каталоге.
    - `for f in foo/*.txt`: все файлы `.txt` в `foo`
    - `для f в foo/*/p??.txt`
      все трехбуквенные текстовые файлы, начинающиеся с p в подкаталогах `foo`

Проблемы с пробелами на этом не заканчиваются:

  - `if [ $foo = "бар"]; then` -- видите проблему?
  — что, если `$foo` пуст? аргументами `[` являются `=` и `bar`...
  - _можно_ обойти это с помощью `[ x$foo = "xbar" ]`, но блин
  - вместо этого используйте `[[`: встроенный компаратор bash, который имеет специальный синтаксический анализ
    - также позволяет использовать `&&` вместо `-a`, `||` поверх `-o` и т. д.

 <!-- TODO: arrays? $@. ${array[@]} vs "${array[@]}". -->

## Возможность компоновки
Shell является мощным инструментом отчасти благодаря возможности компоновки. Можно объединить несколько
программы вместе, а не иметь одну программу, которая делает все.

Ключевой символ — `|` (вертикальная черта).

  - `а | b` означает запуск как `a`, так и `b`
    отправить весь вывод `a` в качестве входных данных `b`
    распечатать вывод `b`

Все запускаемые вами программы («процессы») имеют три «потока»:

  - `STDIN`: когда программа читает ввод, он поступает отсюда.
  - `STDOUT`: когда программа что-то печатает, это отправляется сюда.
  - `STDERR`: второй выход, который программа может использовать.
  - по умолчанию `STDIN` – это ваша клавиатура, `STDOUT` и `STDERR` — оба
    ваш терминал. но ты можешь это изменить!
    - `а | b` создает `STDOUT` из `a` `STDIN` из `b`.
    - Также есть:
      - `a > foo` (`STDOUT` `a` переходит в файл `foo`)
      - `a 2> foo` (`STDERR` `a` переходит в файл `foo`)
      - `a < foo` (`STDIN` `a` считывается из файла `foo`)
      - подсказка: `tail -f` будет печатать файл по мере его записи
  - почему это полезно? позволяет вам манипулировать выводом программы!
    - `ls | grep foo`: все файлы, содержащие слово `foo`
    - `ps | grep foo`: все процессы, содержащие слово `foo`
    - `journalctl | grep -i intel | хвост -n5`:
      последние 5 сообщений системного журнала со словом Intel (без учета регистра)
    - `who | sendmail -t me@example.com`
      отправьте список вошедших пользователей на адрес `me@example.com`
    - формирует основу для большого количества споров с данными, о чем мы поговорим позже

Bash также предоставляет ряд других способов создания программ.

Вы можете группировать команды с помощью `(a; b) | tac`: запустите `a`, затем `b` и отправьте
весь их вывод в `tac`, который печатает входные данные в обратном порядке.

Менее известный, но очень полезный вариант — «подмена процесса».
`b <(a)` запустит `a`, сгенерирует временное имя файла для вывода
поток и передайте это имя файла в `b`. Например:

```bash
diff <(journalctl -b -1 | head -n20) <(journalctl -b -2 | head -n20)
```
покажет вам разницу между первыми 20 строками последней загрузки
log и тот, что был до этого.

<!-- TODO: exit codes? -->

## Контроль работ и процессов


Что, если вы хотите запускать долгосрочные задачи в фоновом режиме?

  - суффикс `&` запускает программу "в фоновом режиме"
    - он немедленно вернет вам подсказку
    - удобно, если вы хотите запустить две программы одновременно
      как сервер и клиент: `сервер и клиент`
    - обратите внимание, что запущенная программа по-прежнему использует ваш терминал как STDOUT!
      попробуйте: `server > server.log & client`
  - увидеть все такие процессы с помощью `заданий`
    - обратите внимание, что он показывает «Бег»
  - выведите его на передний план с помощью `fg %JOB` (ни один аргумент не является последним)
  - если вы хотите сделать фоном текущую программу: `^Z` + `bg` (здесь `^Z` означает нажатие `Ctrl+Z`)
    - `^Z` останавливает текущий процесс и превращает его в "задание"
    - `bg` запускает последнее задание в фоновом режиме (как если бы вы выполнили `&`)
  - фоновые задания по-прежнему привязаны к текущему сеансу и завершаются, если
    вы выходите из системы. `disown` позволяет разорвать это соединение. или используйте nohup.
  - `$!` — это pid последнего фонового процесса

<!-- TODO: управление выводом процесса (^S и ^Q)? -->

А как насчет других вещей, работающих на вашем компьютере?

  - `ps` ваш друг: список запущенных процессов
    - `ps -A`: печатать процессы от всех пользователей (также `ps ax`)
    - `ps` имеет *много* аргументов: см. `man ps`
  - `pgrep`: найти процессы с помощью поиска (например, `ps -A | grep`)
    - `pgrep -af`: поиск и отображение с аргументами
  - `kill`: отправить _сигнал_ процессу по идентификатору (`pkill` по поиску + `-f`)
    - сигналы говорят процессу «что-то сделать»
    - наиболее распространенный: `SIGKILL` (`-9` или `-KILL`): прикажите ему выйти *сейчас*
      эквивалент `^\`
    - также `SIGTERM` (`-15` или `-TERM`): сообщите ему о корректном выходе
      эквивалент `^C`


## Флаги

Большинство утилит командной строки принимают параметры с помощью **флагов**. Флаги обычно имеют короткую (`-h`) и длинную форму (`--help`). Обычно запуск `CMD -h` или `man CMD` дает вам список флагов, которые принимает программа.
Короткие флаги обычно можно комбинировать, запуск `rm -r -f` эквивалентен запуску `rm -rf` или `rm -fr`.
Некоторые общие флаги являются стандартом де-факто, и вы увидите их во многих приложениях:

* `-a` обычно относится ко всем файлам (т. е. включая те, которые начинаются с точки)
* `-f` обычно относится к принудительному выполнению чего-либо, например `rm -f`
* `-h` отображает справку по большинству команд
* `-v` обычно включает подробный вывод
* `-V` обычно печатает версию команды

Кроме того, двойное тире `--` используется во встроенных командах и многих других командах для обозначения конца опций команды, после чего принимаются только позиционные параметры. Итак, если у вас есть файл с именем «-v» (что вы можете) и вы хотите его выполнить с помощью grep, «шаблон grep ---v» будет работать, а шаблон «grep -v» — нет. Фактически, один из способов создать такой файл — это выполнить `touch -- -v`.

## Практические примеры

Ниже мы рассмотрим несколько примеров использования `bash` и еще раз повторим написанное в мотивации к этому уроку: рассматривайте `bash` как дополнительный инструмент, который может облегчить решение некоторых задач. Ради тренировки можно написать, например, калькулятор, но его легко сделать на вашем любимом языке программирования гораздо быстрее, поэтому ниже мы рассмотрим примеры, которые используют доступ к системным утилитам и позволяют нам получить информацию о подключенных устройствах и их состоянии.

### Мониторинг подключения usb-устройств

Ниже приведены примеры скрипта, отслеживающего подключение и отключение usb-устройства

```bash
#!/bin/bash

# Define the log file path
LOG_FILE="./usb-monitor.log"

# Get the initial list of connected USB devices
initial_devices=$(lsusb)

# Function to log the events
log_event() {
    local event_time="$(date +'%Y-%m-%d %H:%M:%S')"
    local event_type="$1"
    local device_id="$2"

    echo "$event_time | $event_type | $device_id" >> "$LOG_FILE"
}

# Function to check for new devices
check_devices() {
    while true 
    do
        current_devices=$(lsusb)
        echo "$initial_devices" | sort > "./idev.txt"
        echo "$current_devices" | sort > "./cdev.txt"
        new_devices=$(comm -13 "./idev.txt" "./cdev.txt")
        removed_devices=$(comm -13 "./cdev.txt" "./idev.txt")
        if test "$new_devices" != ""
        then
            for device in "$new_devices"; do
                log_event "connected" "$device"
            done
        fi
        if test "$removed_devices" != ""
        then
            for device in "$removed_devices"; do
                log_event "disconnected" "$device"
            done
        fi
        initial_devices=$current_devices
        sleep 1  # Adjust the update interval as needed
    done
}

# Start monitoring, just call check_devices()
check_devices
```


Мы видим ряд конструкций, которые доступны в обычном языке программирования, например, условные операторы, циклы, функции. Реализация их в `bash` имеет свои особенности, но понять их синтаксис несложно, если вы знаете хотя бы один язык программирования. Вызов функции также имеет особенности, например, мы передаем аргументы не в скобках, а после вызова функции. Особенности использования `$` мы рассмотрели выше. 

В скрипте мы используем новую команду `comm`, которая сравнивает два файла и выводит результат в три колонки, вторая из которых — строки, уникальные для второго файла (что находится в других колонках, можно посмотреть в документации `man comm`). Аргументы `-13` удаляют колонки 1 и 3, оставляя только вторую. Поэтому мы меняем файлы местами, чтобы определить `new_devices` и `removed_devices`. Функция `log_event()` записывает информацию о новых или отключенных устройствах в файл. Обратите внимание на вызов `check_devices` в конце скрипта. 

Мы проверяем устройства каждую секунду `sleep 1`, поэтому при быстром подключении и отключении можем потерять информацию о событии. Далее мы рассмотрим пример того, как этого избежать.

Также мы использовали команду `test`, которая производит сравнение аргументов с использовании логических операторов. Вы можете встреть `["$new_devices" != ""]` вместо `test "$new_devices" != ""`, это одно и то же. 

### Мониторинг подключения устройств с помощью dmesg

Выше мы рассмотрели скрипт для мониторинга usb-устройств с помощью `lsusb`. В Линукс есть команда для мониторинга всех сообщений, которые появляются в системе. Мы можем настроить шаблоны, которые позволят нам отфильтровать нужные нам сообщения. Ниже приведен пример, которые позволит отловить все сообщения, где встречается подстрока "usb". При этом, в отличие от скрипта с `lsusb`, мы лучше защищены от потери события, так как dmesg выводит сообщения из буфера, который хранит не только последнее сообщение, но и историю сообщений

```bash
#!/bin/bash
prev_records=$(dmesg | tail -20)
 
monitor_devices_records() {

    while true
    do
        curr_records=$(dmesg | tail -20)
        new_records=$(comm -13 <(echo "$prev_records") <(echo "$curr_records"))
        usb_records=$(echo "$new_records" | grep usb)
        if test "$usb_records" != ""
        then
            echo "$usb_records"
        fi
        prev_records=$curr_records
    done
}
# Start monitoring
monitor_devices_records
```

### Мониторинг оставшегося места на диске

Скрипт, приведенный ниже мониторит доступное на диске место и предупреждает, когда процент занятого места превышен. Конструкцию `${}` мы описывали выше. Из нового мы видим конструкцию `($df_record)`, которая позволяет создать список из значения переменной `df_record`, например, "one two three" → ("one", "two", "three")


```bash
#!/bin/bash
monitor_device=$1  #device to monitor eg. /dev/sdc1
alert_level=$2     #available percentage to alert eg. 1
 
monitor_space_usage() {

    while true
    do
        df_record=$(df | grep "$monitor_device")
        df_record_array=($df_record)
        avail=${df_record_array[3]}
        total=${df_record_array[1]}
        if test $(( 100 * $avail / $total)) -le $alert_level
        then
            echo "Alert disk is almost full"
        fi
        sleep 1
    done
}
monitor_space_usage
```
----

