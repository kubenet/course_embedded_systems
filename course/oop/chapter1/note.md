# Курс: ООП
#computer_science #bash #note

# Практическое занятие №1. "Класс"

# Введение

**Класс** - это тип, определяемый пользователем. **Класс** вводится с помощью ключевого слова `class`, `struct` или `union`.
**Класс** - это набор членов класса, которые могут быть:
- переменные (также называемые «ﬁelds»),
- функции (также называемые «методами»),
- типы или типизации (например, «вложенные классы»),
- шаблоны (любого типа: переменная, функция, класс или шаблон псевдонима).

Ключевые слова `class` и `struct`, называемые ключами класса, в основном взаимозаменяемы, за исключением того, что доступ по умолчанию для членов и баз по умолчанию является `private` для класса, объявленного с ключом `class`, и `public` для класса, объявленного с ключом `struct` или `union`.

Например, следующие фрагменты кода идентичны:

```c++
struct Vector
{
	int x;
	int y;
	int z;
};
// are equivalent to
class Vector
{
	public:
		int x;
		int y;
		int z;
};
```

При объявлении **класса** в вашу программу добавляется новый тип, и можно инстанцировать объекты этого класса с помощью
```c++
Vector my_vector;
my_vector.x = 10;
my_vector.y = my_vector.x + 1; // my_vector.y = 11;
my_vector.z = my_vector.y - 4; // my:vector.z = 7;
```


| Keyword     | Описание                                                   |
| ----------- | ---------------------------------------------------------- |
| `public`    | Все имеют доступ                                           |
| `protected` | Доступ имеют только сам класс, производные классы и друзья |
| `private`   | Только сам класс и друзья имеют доступ                     |

Если тип определяется с помощью ключевого слова `class`, то по умолчанию спецификатором доступа является `private`, а если тип определяется с помощью ключевого слова `struct`, то по умолчанию спецификатором доступа является `public` с помощью ключевого слова `struct`, спецификатором доступа по умолчанию является `public`:

```c++
struct MyStruct { int x; };
class MyClass { int x; };
MyStruct s;
s.x = 9; // well formed, because x is public
MyClass c;
c.x = 9; // ill-formed, because x is private
```

Спецификаторы доступа в основном используются для ограничения доступа к внутренним полям и методам и заставляют программиста использовать
конкретный интерфейс, например, чтобы заставить использовать **геттеры** (`getter`) и **сеттеры** (`setters`) вместо прямой ссылки на переменную:

```c++
class MyClass {

public: /* Methods: */
	int x() const noexcept { return m_x; }
	void setX(int const x) noexcept { m_x = x; }
	
private: /* Fields: */
	int m_x;
};
```

Предположим, нам нужно хранить координаты точек на оси X. Понятно, что при большом количестве точек для этого нецелесообразно использовать отдельные переменные, а лучше хранить точки в массиве:
```c++
int x [10];
```
Если вдруг нам понадобится хранить координаты не одномерных, а двумерных точек, то возможным решением будет добавление ещё одного массива:
```c++
int x [10];
int y [10];
```
В чём недостаток такого решения? Мы уже здесь видим, что координаты какой-то конкретной точки хранятся в двух разных массивах, которые потенциально имеют разную длину: если нам понадобится увеличить количество точек с `10` до `11`, нам придётся менять два массива. Если нам понадобится функция, которая, например, сдвигает какую-то точку по обеим координатам, то в такую функцию нам придётся передать и оба массива, и индекс:
```c++
int x [10] ;
int y [10] ;
void shift ( int x_to_shift [ ] , int y_to_shift [ ] , int idx )
{
	...
}
```
Если вдруг понадобится увеличить длину массива, нам придётся сделать это в двух разных местах и это может стать причиной ошибки. **Но первопричиной проблемы станет то, что информация, относящаяся к одному конкретному объекту (какой-то из наших `10`
точек) «размазана» по разным местам программного кода, а именно двум разным массивам**.
```c++
int z [10] ;
```
Где-то появилась третья строка с `z` - что это? Может это ещё один массив одномерных точек? Или это мы вместо двумерных точек решили сделать трёхмерные? **Структуры данных, их логика и код размазываются тонким слоем по всему коду, тогда как здравый смысл, наоборот, диктует нам универсальное правило - взаимосвязанные и взаимовлияющие данные и код должны быть описаны как можно ближе друг к другу**. Это правило
универсальное: оно вообще не имеет отношения к **ООП!** В книге [тык](https://habr.com/ru/companies/piter/articles/567302/), например, показывается, как можно реализовать ООП в процедурном, а не объектно-ориентированном языке, что очень поучительно, а в [тык](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md) самым первым примером в секции про классы говорят, по
сути, о том же самом, – хотя и не произносят слова **инкапсуляция**.
```c++
// BAD: unnecessary implicit relationships
void draw (int x , int y , int x2 , int y2);
// better
void draw (Point from , Point to);
```

Слово **инкапсуляция** - довольно многозначное, имеющее несколько смыслов. Принципом **инкапсуляция** мы назовём описанное выше правило: всё относящееся к описанию чего-то одного и того же целостного, должно храниться вместе. **Все данные** (в широком смысле), **описывающие один и тот же объект** (в широком смысле)** должны храниться в одной структуре**. Очевидно, что именно для этого и придумали такие составные структуры данных, как **массивы** и **структуры**, а в нашем случае - **классы**:
```c++
class Point {
	public:
		int x;
		int y;
};
```
Этот код определяет новый класс, задавая его как набор свойств и их типов. Значений, как мы помним, у свойств класса нет – они появляются только при создании объектов этого класса.
**Если в реальной жизни объекты уже существовали и про свои классы ничего не знали, пока наш разум не занялся их классификацией, то в той версии ООП, которую мы будем рассматривать (классовое ООП, в противовес бесклассовому, прототипно-ориентированному ООП), всё наоборот: сначала создаются классы, а потом уже создаются объекты-экземпляры этих классов.** Создание объектов и работа с ними напрямую или через указатели большей частью совершенно повторяет работу с обычными переменными. Это, кстати, даёт нам возможность говорить, что значения обычных типов, например, целые числа – это тоже объекты такого упрощённого класса `int` - аналогия позволяет нам так думать (хотя компилятор часто и считает иначе). Некоторые языки идут ещё дальше, и в явном виде постулируют, что всё, в том числе и значения примитивных типов, например, **числа** – **есть объект**.

| Действие                 | Простые занчения                            | Объекты                                              |
| ------------------------ | ------------------------------------------- | ---------------------------------------------------- |
| Создание                 | `int a;`<br>`int b;`                        | `Point a;`<br>`Point b;`                             |
| Создание через указатель | `int *pa = new int;`<br>`int *pb = new int` | `Point *pa = new Point;`<br>`Point *pb = new Point;` |
| Копирование объектов     | `b = a;`<br>`*pb = pa;`                     | `b = a`<br>`*pb = *pa`                               |
| Копирование указателей   | `pb = pa;`                                  | `pb = pa;`                                           |
| Удаление через указатель | `delete pa;`<br>`delete pb;`                | `delete pa;`<br>`delete pb;`                         |
# Доступ к объекту
Для доступа к **полям** и **методам** объекта класса используется оператор `.`

```c++
struct SomeStruct {
	int a;
	int b;
	void foo() {}
};

SomeStruct var;
// Accessing member variable a in var.
std::cout << var.a << std::endl;
// Assigning member variable b in var.
var.b = 1;
// Calling a member function.
var.foo();
```

При обращении к членам класса через указатель обычно используется оператор `->`. В качестве альтернативы экземпляр может быть разыменован и использован оператор `.`, хотя это встречается реже [тык](https://godbolt.org/z/cer36sqM3):
```c++
#include <iostream> 
struct SomeStruct {
	int a;
	int b;
	void foo() {}
};

int main() {
	SomeStruct var;
	SomeStruct *p = &var;
	 
	// Accessing member variable a in var via pointer.
	std::cout << p->a << std::endl;
	std::cout << (*p).a << std::endl; 
	
	// Assigning member variable b in var via pointer.
	
	p->b = 1;
	(*p).b = 1;
	
	// Calling a member function via a pointer.
	p->foo();
	(*p).foo();
	
	return 0;
}
```

При обращении к **статическим** (`static`) членам класса используется оператор `::`, но на имени класса, а не на экземпляре этого класса. В качестве альтернативы, к статическому члену можно обратиться из экземпляра или указателя на экземпляр, используя оператор `.` или `->`
соответственно, с тем же синтаксисом, что и при обращении к нестатическим членам. [тык](https://godbolt.org/z/WoehP697T)
```c++
#include <iostream>

struct SomeStruct {
	int a;
	int b;
	void foo() {}
	static int c; // Declaration of the static member variable
	static void bar() {} // Declaration of the static member function
};

// Definition of the static member variable outside the struct
int SomeStruct::c = 0;

int main() {
	// The following line was incorrect; it attempted to declare a new variable of type `int` with the same name as the static member variable.
	// The corrected code omits this line.
	SomeStruct var;
	SomeStruct* p = &var;
	// Assigning a value to the static member variable c in struct SomeStruct.
	SomeStruct::c = 5;
	// Accessing static member variable c in struct SomeStruct, through var and p.
	// Note: Static members are accessed through the class name, not through an instance.
	var.a = SomeStruct::c; // Corrected to access `c` via class name
	var.b = p->c; // This works but accessing static members through instance is not recommended.
	// Calling a static member function.
	SomeStruct::bar(); // Correct way to call static member function.
	// Note: Static member functions should be accessed through the class name.
	// The following lines are incorrect because `bar()` is a static function and should not be called on instances.
	// var.bar(); // Incorrect
	// p->bar(); // Incorrect
	return 0;
}
```
> Оператор `->` необходим, потому что оператор доступа к члену `.` имеет приоритет перед оператором разыменования `*`. Можно было бы ожидать, что `*p.a` разыменует `p` (в результате чего получается ссылка на объект, на который указывает `p`), а затем доступ к полю `a`. Но на самом деле он пытается получить доступ к полю `a` объекта `p`, а затем разыменовать его. То есть `*p.a` эквивалентно `*(p.a)`. В приведенном выше примере это привело бы к ошибке компилятора из-за двух фактов: Во-первых, `p` - это **указатель**
> Во-вторых, `a` - целое число и, следовательно, не может быть разыменовано.
   Редко используемым решением этой проблемы было бы явное управление старшинством: `(*p).a`. Вместо этого почти всегда используется оператор `->`. **Это сокращение для того, чтобы сначала разыменовать указатель, а затем доступа к нему**. То есть `(*p).a` - это точно то же самое, что `p->a`.
   Оператор `::` - это оператор области видимости, который используется так же, как доступ к члену пространства имен. Это происходит потому что статический член класса считается находящимся в области видимости этого класса, но не считается членом экземпляров этого класса. Использование обычных `.` и `->` также разрешено для статических членов, несмотря на то, что они не являются членами экземпляра по историческим причинам; это полезно для написания общего кода в шаблонах, так как вызывающему не нужно быть поскольку вызывающей стороне не нужно знать, является ли данный **метод** статической или нестатической.

## Конструкторы и деструкторы, жизненный цикл объектов
### Конструктор

```c++
class Point {
	private :
		int x ;
		int y ;
	public :
		void set ( int x , int y ) {
			if ( ( x > 0 ) && ( x <= 1920 ) )
				this −>x = x;
			if ( ( y > 0 ) && ( y <= 1080 ) )
				this −>y = y;
	}
};
```
Что мы делаем первым делом, после того, как создаём новый объект? Похоже, всякий раз нам приходится начинать с того, чтобы вызывать у него функцию `set` для установки начальных значений свойств:

```c++
Point a;
a.set(0, 0);
```

До вызова функции `set` значения свойств `x` и `y` неопределены и содержат всякий разный мусор! Да, возможно, компилятор за вас постарается и занулит их значения. Попробуйте сделать вот так и убедитесь, что у `pb`, в отличие от `pa` и `a`, значения свойств занулены – но будет ли это так в другом вашем любимом языке и другом компиляторе?
```c++
Point a;
Point *pa = new Point;
Point *pb = new Point();
```
Кстати, такой же трюк с объектом `a` – не пройдёт (попробуйте!): компилятор будет `Point a();` воспринимать как объявление функции, а не объект.

**Конструктор** – это специфический метод, который вызывается **автоматически при создании объекта и предназначен для инициализации начальных значений всех его свойств,
выделения нужных ресурсов, а также выполнения всех прочих действий, которые должны быть выполнены при создании объекта**. В разных языках конструкторы описываются по-разному, но, как и для всех остальных приёмов ООП, главное – это идеи, и идея **конструктора** одна и та же везде. В **С++** **конструкторы**, в отличие от обычных методов, имеют **имя**, **совпадающее с именем класса, и не имеют возвращаемого значения**:
```c++
class Point {
	private :
		int x ;
		int y ;
	public :
		Point ( ) {
			x = 0;
			y = 0;
		}
		Point ( int x , int y ) {
			this −>x = x ;
			this −>y = y ;
		}
			Point ( const Point &t ) {
			x = t.x;
			y = t.y;
		}
};
```

Ух ты, да тут не один конструктор, а сразу три! Зачем нам может понадобиться три разных конструктора? Да потому что нам может понадобиться много разных удобных способов создавать объекты какого-то класса. Поэтому – больше конструкторов, хороших и разных, но вот эти три особенно важны.

**Первый** из них называется **конструктором по умолчанию**. Он будет использоваться, когда нам нужно просто создать объект, значения свойств которого мы пока заполнять не знаем как, но мусора там допускать не хотим (например, потому, что мусор может сразу нарушать наши бизнес правила для объекта).
**Второй** конструктор называется **конструктором с параметрами**. Он не такой особенный, но мы будем такие конструкторы использовать, когда хотим создать объект, полностью задавая у него сразу все значения свойств. 
**Третий** конструктор, как и первый, тоже имеет для компилятора особенное значение. Он называется **конструктором копирования** и предназначен для такого создания **объекта**, при котором значения всех его свойств должны быть взяты из **объекта-прототипа**, который передаётся как раз для этого в качестве параметра. Обратите внимание, что **объект-прототип** обязательно передаётся по ссылке, а не по значению или указателю. В других, более высокоуровневых языках, где нет ни указателей, ни ссылок, ни объектных значений (а точнее всё есть ссылка), конструктор копирования тоже будет, просто оформляться будет по-другому. Если вы знаете, чего вы хотите, вы всегда загуглите, как. Когда будут вызываться эти конструкторы? [тык](https://godbolt.org/z/fobn884br)
```c++
Point a ;
Point b(5, 6);
Point c(a);
Point d = a;
```
Для динамически создаваемых объектов всё очень похоже [тык](https://godbolt.org/z/5WPWhYnhs):
```c++
Point *pa = new Point;
Point *pb = new Point();
Point *pc = new Point(5, 6);
Point *pd = new Point(*pa);
Point *pe = new Point(pa);
```

Надо понимать, что **вызов конструктора** - это часть процесса **создания объекта** и вызывается он уже после того, как память под сам объект (под все его свойства) уже была выделена, поэтому внутри конструктора мы можем так смело обращаться к свойствам объекта, хотя инициализация объекта ещё не завершена. Кроме этого, раз конструктор не возвращает значения, то показать вызывающему коду, что в конструкторе произошёл какой-то косяк и объект не должен был создаться, можно **только подняв исключение**. В этом случае, и в случае, если исключение (ошибка) произошло по независящим от нас причинам внутри конструктора, создание объекта будет отменено и вся память освобождена (про освобождение памяти ещё будет дальше).

### Деструктор
Как понять, был объект уничтожен, или нет? Можно ли привязать какие-то действия к тому моменту, когда уничтожается объект? Можно, для этого и существуют другие специальные методы у классов, называемые **деструкторами**. **Деструктор** - это специфический метод без параметров, который вызывается автоматически при уничтожении объекта и предназначен для освобождения ресурсов, если таковые были выделены в конструкторе, а также выполнения всех прочих действий, которые должны быть выполнены при **уничтожении объекта**. В разных языках **деструкторы** описываются по-разному, но, как и для всех остальных приёмов ООП, главное – это идеи, и идея деструктора одна и та же везде. В С++ **деструкторы**, в отличие от обычных методов, имеют имя, совпадающее с именем класса, перед которым поставили тильду `~` и не имеют возвращаемого значения [тык](https://godbolt.org/z/E853jvab7):
```c++
class Point {
	private:
		int x;
		int y;
	public:
		Point () {
			x = 0;
			y = 0;
		}
		~Point (){
		}
};
```