# Курс: ООП
#oop #note

# Практическое занятие №4. "Перегрузка операторов"

Перегрузка операторов (**operator overloading**) представляет собой механизм, позволяющий применять встроенные операторы языка к различным типам данных, включая пользовательские. Эта концепция имеет долгую историю; в ранних языках программирования символы арифметических операций, такие как `+` и `-`, использовались для выполнения операций над целыми и вещественными числами, несмотря на различия в их размерах и внутреннем представлении, что требовало разнообразной реализации этих операций. С развитием объектно-ориентированных языков программирования данная идея получила дальнейшее развитие. Если операции над пользовательскими типами имеют аналогичную семантику с операциями над встроенными типами, то применение синтаксиса встроенных операторов может существенно повысить читаемость кода, сделать его более лаконичным и выразительным, а также упростить написание обобщённого кода. В языке **`C++`** перегрузка операторов поддерживается на высоком уровне и активно используется в стандартной библиотеке.

В широком смысле **перегрузка** (**overloading**) обозначает возможность одновременного использования нескольких функций с одинаковым именем. Компилятор различает эти функции на основании различных наборов параметров. При вызове функции компилятор анализирует типы аргументов и определяет, какая конкретно функция должна быть выполнена. В русскоязычной литературе иногда используется термин **совместное использование**, однако он не получил широкого распространения.

## Перегрузка функций 

Функции (включая шаблоны функций) считаются **перегруженными** (**overloaded**), если они объявлены в одной области видимости (**scope**) и имеют одно и то же имя. Перегруженные функции не могут отличаться только по типу возвращаемого значения, спецификатору исключений или спецификатору удаления функции (**=delete**) при идентичных параметрах.

```c++
void Foo();
char Foo(); // ошибка
void Foo(int x);
void Foo(int x) noexcept;  // ошибка
void Foo(double x);
void Foo(double) = delete; // ошибка
```

Тем не менее, допускаются несколько идентичных объявлений; компилятор просто игнорирует дубликаты.

Важно отметить, что компилятор выполняет стандартные преобразования типов параметров функций. Например, для массива происходит его преобразование (decay) в указатель, поэтому следующие объявления не являются перегруженными:

```c++
void Foo(int x[4]);
void Foo(int x[]);
void Foo(int *x);
```

Параметры типа «функция» также преобразуются в указатель на функцию.

Для параметров, передаваемых по значению, квалификаторы `const` и `volatile` удаляются, поэтому следующие объявления также не являются перегруженными:

```c++
void Foo(int x);
void Foo(const int x);
```

### Поиск нужной функции

Алгоритм поиска функции можно описать в общих чертах следующим образом. На первом этапе компилятор выполняет поиск перегруженных функций, допустимых для данного вызова (candidate functions). В случае работы с шаблонами дополнительно выполняется вывод аргументов шаблона (template argument deduction). Количество параметров должно соответствовать количеству аргументов, а типы аргументов должны соответствовать типам параметров (или должно существовать неявное преобразование типов). Если такие функции не обнаружены, процесс поиска завершается ошибкой. Если найдена только одна функция, процесс завершается успешно. В случае обнаружения нескольких подходящих функций начинается следующий этап — компилятор пытается выбрать наиболее подходящую для данных аргументов (match the arguments most closely). Этот этап называется разрешением перегрузки (overload resolution). Если такая функция найдена, разрешение завершается успешно; в противном случае возникает ошибка (ambiguous call to overloaded function). Рассмотрим следующий пример:

```c++
void Foo(float x);
void Foo(double x);
```

Для вызова `Foo("meow")` не обнаруживается ни одной подходящей функции; для вызова `Foo(42)` подходят обе функции, и компилятор не может сделать выбор. Однако вызовы `Foo(3.14f)` и `Foo(3.14)` разрешаются успешно.

Правила выбора наиболее подходящей функции (overload resolution rules) могут оказаться достаточно сложными и запутанными, и лишь разработчики компиляторов обладают полным пониманием всех аспектов. Тем не менее, во многих практических ситуациях эти правила интуитивно понятны и не вызывают трудностей у программистов. Некоторые из них будут рассмотрены ниже.

Термин **разрешение перегрузки** обычно охватывает обе фазы: поиск функций-кандидатов и выбор наиболее подходящей функции. В дальнейшем мы будем придерживаться этого определения.

Однако успешное разрешение перегрузки не является конечным этапом. После этого производится проверка доступности выбранной функции в точке вызова (то есть, не является ли она `private` или `protected`). В случае успешного прохождения этой проверки также осуществляется проверка на удаленность (то есть, не объявлена ли функция как `=delete`). Если какие-либо из этих проверок не проходят, компиляция завершается с ошибкой. Следует отметить, что указанные проверки не влияют на процесс разрешения перегрузки и всегда выполняются после него.

```c++
#include <iostream>
#include <string>

class Example {
public:
    // Overloaded functions
    void show(int a) {
        std::cout << "Integer: " << a << std::endl;
    }

    void show(double a) {
        std::cout << "Double: " << a << std::endl;
    }

    void show(const std::string& a) {
        std::cout << "String: " << a << std::endl;
    }

    // A function that takes a pointer
    void show(int* ptr) {
        if (ptr) {
            std::cout << "Pointer to Integer: " << *ptr << std::endl;
        } else {
            std::cout << "Null Pointer" << std::endl;
        }
    }
};

int main() {
    Example ex;

    int intValue = 42;
    double doubleValue = 3.14;
    std::string stringValue = "Hello, World!";
    int* intPtr = &intValue;

    // Calling overloaded functions
    ex.show(intValue);        // Calls show(int)
    ex.show(doubleValue);     // Calls show(double)
    ex.show(stringValue);     // Calls show(const std::string&)
    ex.show(intPtr);          // Calls show(int*)
    
    return 0;
}

```

### Область видимости

Перегруженные функции по своей природе находятся в одной области видимости. Области видимости могут быть вложенными, как в случае пространств имен, где каждое пространство имен включается в глобальное пространство имен. Область видимости производного класса включает области видимости его базовых классов, которые, в свою очередь, находятся в пространстве имен. Локальные области видимости (например, блоки кода) также могут быть вложены в более высокие области видимости, такие как классы или пространства имен.

При разрешении перегрузки компилятор сначала определяет текущую область видимости. Если в ней отсутствуют функции с искомым именем, происходит переход к объемлющей области видимости. Однако, если в текущей области найдена хотя бы одна подходящая функция, поиск в объемлющих областях не выполняется, и функции из текущей области скрывают одноименные функции из более высоких областей.

### Выбор области видимости

Текущая область видимости определяется контекстом вызова функции. Рассмотрим примеры:

```c++
class X {
public:
    void Foo() { /* ... */ }
};

// Вызовы:
X x;
x.Foo();        // Текущая область: X
X::Foo(42);    // Текущая область: X
```

В этом случае объемлющие области — это базовые классы `X`.

```c++
namespace N {
    void Foo() { /* ... */ }
}

// Вызов:
N::Foo();      // Текущая область: N, объемлющих областей нет
```
```c++
// Глобальный вызов:
::Foo();      // Текущая область: глобальное пространство, объемлющих областей нет
```

Теперь рассмотрим вызовы функций без квалификаторов.

Если вызов находится в пространстве имен, это пространство будет текущей областью, а объемлющими — вышестоящие пространства имен.
```c++
namespace N {
    void Foo() { /* ... */ }
    
    void bar() {
        Foo();  // Текущая область: N, объемлющие области: глобальное пространство
    }
}
```

Если вызов производится в пространстве имен класса (например, при инициализации статического члена), текущей областью будет соответствующий класс:

```c++
class A {
public:
    static void Foo() { /* ... */ }
    
    void method() {
        Foo();  // Текущая область: A, объемлющие области: базовые классы
    }
};
```

При вызове функции внутри блока кода:
```c++
{
    Foo();  // Текущая область: локальный блок, объемлющие области: классы и пространства имен
}
```

Следует отметить, что в каждом из этих случаев объемлющие области зависят от контекста, в котором происходит вызов, и их структура может существенно влиять на разрешение перегрузки функций.

### Расширение области видимости 

Область видимости для разрешения перегрузки может быть расширена с использованием `using`-объявлений и `using`-директив. В некоторых случаях компилятор также автоматически расширяет область видимости.

Важно отметить, что расширение области видимости может вызвать конфликты, если в ней присутствуют функции с идентичными наборами параметров.

`using`-объявление позволяет производным классам наследовать перегруженные функции:

```c++
class B {
public:
    void Foo(int x);
};

class D : public B {
public:
    using B::Foo;
    void Foo(double x);
};

D d;
d.Foo(42); // Вызывает B::Foo(int)
```

`Using`-объявление можно использовать локально, но оно может скрыть имена из родительской области видимости:

```c++
#include <iostream>

namespace N {
    void Foo(int x) {
        std::cout << "Called N::Foo with int: " << x << std::endl;
    }
}

// Global function
void Foo(const char* x) {
    std::cout << "Called Foo with const char*: " << x << std::endl;
}

void Test() {
    using N::Foo; // Hides Foo(const char*)

    // This call is valid and resolves to N::Foo(int)
    Foo(42);      // OK, calls N::Foo(int)

    // This call will result in an error since Foo(const char*) is hidden
    Foo("meow");  // Error: no matching function for call to 'Foo(const char*)'
}

int main() {
    Test();
    return 0;
}

```

Чтобы обе версии `Foo` участвовали в разрешении перегрузки, объявление следует разместить так:

```c++
#include <iostream>

namespace N {
    void Foo(int x) {
        std::cout << "Called N::Foo with int: " << x << std::endl;
    }
}

// Global function
void Foo(const char* x) {
    std::cout << "Called Foo with const char*: " << x << std::endl;
}

// Bringing N::Foo into scope
using N::Foo;

void Test() {
    Foo(42);      // OK, calls N::Foo(int)
    Foo("meow");  // OK, calls Foo(const char*)
}

int main() {
    Test();
    return 0;
}

```

Директива `using namespace N;` позволяет использовать имена из пространства имен без квалификатора:

```c++
#include <iostream>

namespace N {
    void Foo(int x) {
        std::cout << "Called N::Foo with int: " << x << std::endl;
    }
}

// A function in an unnamed (anonymous) namespace
namespace {
    void Foo(int x) {
        std::cout << "Called anonymous Foo with int: " << x << std::endl;
    }
}

// Global function
void Foo(const char* x) {
    std::cout << "Called Foo with const char*: " << x << std::endl;
}

// Bring everything from namespace N into the current scope
using namespace N;

void Test() {
    Foo(42);     // OK, calls the anonymous namespace Foo(int)
    Foo("meow"); // OK, calls Foo(const char*)
}

int main() {
    Test();
    return 0;
}

```

##  Что же такое перегрузка функций ?

Перегрузка функций заключается в наличии нескольких функций с одинаковым именем, определенных в одной области видимости (scope), которые различаются только по сигнатуре — набору принимаемых ими аргументов.

Рассмотрим пример функции для обобщенного вывода строк с использованием `std::string`:

```c++
void print(const std::string &str) {
    std::cout << "Это строка: " << str << std::endl;
}
```

Эта функция работает корректно, но если вы хотите также принимать целочисленные значения, можно определить другую функцию:
```c++
void print_int(int num) {
    std::cout << "Это целое число: " << num << std::endl;
}
```

Однако, поскольку обе функции принимают разные параметры, более удобно перегрузить одну и ту же функцию:

```c++
void print(int num) {
    std::cout << "Это целое число: " << num << std::endl;
}
```

Теперь у вас есть две функции с именем `print`, но с различными сигнатурами: одна принимает `std::string`, другая — `int`. Вы можете вызывать их без необходимости использовать разные имена:

```c++
print("Привет, мир!"); // выводит "Это строка: Привет, мир!"
print(1337);           // выводит "Это целое число: 1337"
```

Таким образом, вы избегаете необходимости писать:
```c++
print("Привет, мир!");
print_int(1337);
```

Когда вы используете перегруженные функции, компилятор определяет, какую из функций вызывать, основываясь на предоставленных параметрах. Однако следует проявлять осторожность при написании перегрузок. Например, это может быть проблематично в случае неявных преобразований типов:

```c++
void print(int num) {
    std::cout << "Это целое число: " << num << std::endl;
}

void print(double num) {
    std::cout << "Это дробное число: " << num << std::endl;
}
```

Теперь неясно, какая перегруженная версия `print` будет вызвана при написании:
```c++
print(5); // Неясно, вызывается ли print(int) или print(double)
```

Вам может понадобиться дать компилятору подсказки, например:

```c++
print(static_cast<double>(5)); // Вызовет print(double)
print(static_cast<int>(5));    // Вызовет print(int)
print(5.0);                    // Вызовет print(double)
```

## Возвращаемый тип в перегрузке функций

Обратите внимание, что перегрузка функций по возвращаемому типу невозможна. Рассмотрим пример:

```c++
// Неверный код
std::string getValue() {
    return "hello";
}

int getValue() {
    return 0;
}

int x = getValue(); // Ошибка компиляции
```

В данном случае возникнет ошибка компиляции, так как компилятор не сможет определить, какую версию `getValue` вызывать, даже если возвращаемый тип присваивается переменной типа `int`.

## Перегрузка функций-членов с учетом квалификаторов `cv`

Функции внутри класса могут быть перегружены в зависимости от того, как они вызываются через ссылки с квалификаторами cv (const и volatile). Это чаще всего используется для перегрузки с учетом `const`, но также может применяться и для `volatile` и `const volatile`. Это связано с тем, что все нестатические члены класса принимают `this` как скрытый параметр, к которому применяются квалификаторы.

Это необходимо, поскольку член функции может быть вызван только в том случае, если он имеет как минимум такие же квалификаторы cv, как и экземпляр, на котором он вызывается. Нестатический экземпляр может вызывать как константные, так и неконстантные методы, тогда как константный экземпляр может вызывать только константные методы. Это позволяет функции иметь разное поведение в зависимости от квалификаторов cv экземпляра.

Пример класса с перегруженным методом `print`:

```c++
#include <iostream>

class Integer {
public:
    Integer(int i_) : i{i_} {}

    void print() {
        std::cout << "int: " << i << std::endl;
    }

    void print() const {
        std::cout << "const int: " << i << std::endl;
    }

protected:
    int i;
};

int main() {
    Integer i{5};
    const Integer &ic = i;
    
    i.print();  // выводит "int: 5"
    ic.print(); // выводит "const int: 5"
}
```

Это ключевой аспект правильного использования `const`: помечая методы-члены как `const`, их можно вызывать на константных экземплярах, что позволяет передавать экземпляры как константные указатели или ссылки, если их не нужно изменять. Это делает код более безопасным и читаемым.
Пример класса с хорошей практикой использования `const`:

```c++
class ConstCorrect {
public:
    void good_func() const {
        std::cout << "Мне не важно, является ли экземпляр константным." << std::endl;
    }

    void bad_func() {
        std::cout << "Я могу быть вызван только на неконстантных экземплярах." << std::endl;
    }
};

void i_change_no_state(const ConstCorrect& cc) {
    std::cout << "Я могу принимать как константные, так и неконстантные экземпляры." << std::endl;
    cc.good_func(); // Правильно. Можно вызывать как из константного, так и из неконстантного экземпляра.
    cc.bad_func();  // Ошибка. Можно вызывать только из неконстантного экземпляра.
}

void const_incorrect_func(ConstCorrect& cc) {
    cc.good_func(); // Правильно. Можно вызывать как из константного, так и из неконстантного экземпляра.
    cc.bad_func();  // Ошибка. Можно вызывать только из неконстантного экземпляра.
}
```

Чтобы привыкнуть к этому приему, мы вернемся к нашему старому компаньону `smallest_element()`. Хотя текущая версия уже довольно хороша, нас может заинтересовать похожая, но не идентичная функция для строк: найти наименьший символ. Чтобы это было несколько интереснее, мы определим, что строчные буквы всегда меньше прописных, а символы, которые появляются раньше в алфавите, меньше тех, которые появляются позже.

Чтобы справиться с этой задачей, мы ограничимся символами английского алфавита и проигнорируем все остальные. Давайте взглянем на код:

```c++
#include <iostream>
#include <string>
#include <vector>
#include <locale> // required for isupper and islower
 
// the old version for vectors of ints
int smallest_element(const [std::vector](http://en.cppreference.com/w/cpp/container/vector)<int>& vec)
{
    auto smallest_value = vec[0];
    for (auto x: vec) {
        if (x<smallest_value) {
            smallest_value = x;
        }
    }
    return smallest_value;
}
 
// the new version for strings
// return 0 if no character is found
char smallest_element(const [std::string](http://en.cppreference.com/w/cpp/string/basic_string)& str)
{
    [std::locale](http://en.cppreference.com/w/cpp/locale/locale) l{}; // required for isupper and islower
    char smallest_char = 0;
    bool result_is_lowercase = false;
    for (char c: str) {
        if ([std::islower](http://en.cppreference.com/w/cpp/string/byte/islower)(c, l)) {
            if(smallest_char == 0 || !result_is_lowercase || c < smallest_char) {
                smallest_char = c;
                result_is_lowercase = true;
            }
        }
        else if (!result_is_lowercase && [std::isupper](http://en.cppreference.com/w/cpp/string/byte/isupper)(c, l)) {
            if(smallest_char == 0 or c < smallest_char) {
                smallest_char = c;
            }
        }
    }
    return smallest_char;
}
 
int main()
{
    [std::cout](http://en.cppreference.com/w/cpp/io/basic_ostream) << "the smallest character of 'Foobar' is '" 
        << smallest_element("Foobar") << "'\n";
    [std::cout](http://en.cppreference.com/w/cpp/io/basic_ostream) << "the smallest number of 1, 3, 6, -3, 4 and 2 is: "
        << smallest_element([std::vector](http://en.cppreference.com/w/cpp/container/vector)<int>{1, 3, 6, -3, 4, 2}) << "\n";
}
```

```output
the smallest character of 'Foobar' is 'a'
the smallest number of 1, 3, 6, -3, 4 and 2 is: -3
```

## Перегрузка операторов

В C++ можно перегружать операторы, такие как `+` и `->`, для пользовательских типов. Например, заголовок `<string>` определяет оператор `+` для конкатенации строк. Это достигается путем определения функции оператора с помощью ключевого слова `operator`.

Вы можете перегружать все основные арифметические операторы:

- `+` и `+=`
- `-` и `-=`
- `*` и `*=`
- `/` и `/=`
- `&` и `&=`
- `|` и `|=`
- `^` и `^=`
- `>>` и `>>=`
- `<<` и `<<=`

```c++
T operator+(T lhs, const T& rhs) {
    lhs += rhs; // Используем оператор += для выполнения сложения
    return lhs; // Возвращаем результат
}

T& operator+=(T& lhs, const T& rhs) {
    // Выполняем сложение
    return lhs; // Возвращаем ссылку на lhs для цепочки вызовов
}
```

```c++
T operator+(const T& rhs) {
    *this += rhs; // Используем оператор += для выполнения сложения
    return *this; // Возвращаем текущий объект
}

T& operator+=(const T& rhs) {
    // Выполняем сложение
    return *this; // Возвращаем ссылку на текущий объект
}
```

Оператор `operator+` должен возвращать значение, а не ссылку, так как возврат ссылки не имеет смысла (он возвращает новый объект), а возврат значения `const` не рекомендуется (в общем случае не следует возвращать `const`). Первый аргумент передается по значению. Почему? Потому что:

1. Нельзя модифицировать оригинальный объект (например, `Object foobar = foo + bar;` не должна изменять `foo`, так как это не имеет смысла).
2. Нельзя сделать объект `const`, поскольку его необходимо будет модифицировать (так как `operator+` реализован с использованием `operator+=`, который изменяет объект).

Передача по `const&` является вариантом, но в этом случае необходимо создать временную копию переданного объекта. Передавая по значению, компилятор делает это за вас.

Оператор `operator+=` возвращает ссылку на сам объект, что позволяет осуществлять цепочку вызовов (однако не следует использовать одну и ту же переменную, так как это приведет к неопределенному поведению из-за точек последовательности).

Первый аргумент передается по ссылке (так как мы хотим его изменить), но не как `const`, иначе мы не сможем его модифицировать. Второй аргумент не должен изменяться, поэтому для повышения производительности он передается по `const&`.

Когда оператор появляется в выражении, и по крайней мере один из его операндов имеет тип класса или перечислимый тип, используется разрешение перегрузки для определения пользовательской функции, которая будет вызвана среди всех функций с соответствующими сигнатурами:

| Выражение | As member function     | As non-member function   | Пример                                                                 |
| --------- | ---------------------- | ------------------------ | ---------------------------------------------------------------------- |
| `@a`      | `(a).operator@()`      | `operator@(a)`           | `!std::cin` вызывает `std::cin.operator!()`                            |
| `a@b`     | `(a).operator@(b)`     | `operator@(a, b)`        | `std::cout << 42` вызывает `std::cout.operator<<(42)`                  |
| `a=b`     | `(a).operator=(b)`     | **cannot be non-member** | Для `std::string s;`, `s = "abc";` вызывает `s.operator=("abc")`       |
| `a(b...)` | `(a).operator()(b...)` | **cannot be non-member** | Для `std::random_device r;`, `auto n = r();` вызывает `r.operator()()` |
| `a->`     | `(a).operator->()`     | **cannot be non-member** | Для `std::unique_ptr<S> p;`, `p->bar()` вызывает `p.operator->()`      |
| `a@`      | `(a).operator@(0)`     | `operator@(a, 0)`        | Для `std::vector<int>::iterator i;`, `i++` вызывает `i.operator++(0)`  |

### Операторы, не рекомендуемые для перегрузки

Не рекомендуется перегружать следующие три бинарных оператора: `,` (запятая), `&&`, `||`. Дело в том, что для них стандарт предусматривает порядок вычисления операндов (слева направо), а для последних двух еще и так называемую семантику быстрых вычислений (short-circuit evaluation), но для перегруженных операторов это уже не гарантируется или просто бессмысленно, что может оказаться весьма неприятной неожиданностью для программиста. (Семантика быстрых вычислений, называемая еще закорачиванием, заключается в том, для оператора `&&` второй операнд не вычисляется, если первый равен `false`, а для оператора `||` второй операнд не вычисляется, если первый равен `true`.)   

Также не рекомендуется перегружать унарный оператор `&` (взятие адреса). Тип с перегруженным оператором `&` опасно использовать с шаблонами, так как они могут использовать стандартную семантику этого оператора. Правда в С++11 появилась стандартная функция (точнее шаблон функции) `std::addressof()`, которая умеет получать адрес без оператора `&` и правильно написанные шаблоны должны использовать именно эту функцию вместо встроенного оператора.

## Классический реализации 

Помимо вышеуказанных ограничений, язык не накладывает дополнительных ограничений на функциональность перегруженных операторов или на тип возвращаемого значения (он не участвует в разрешении перегрузки). В общем, перегруженные операторы ожидаются вести себя как можно более похоже на встроенные операторы: оператор `operator+` должен складывать, а не умножать свои аргументы, оператор `operator=` должен присваивать и т.д. Связанные операторы должны иметь схожее поведение (например, `operator+` и `operator+=` выполняют аналогичные операции сложения). Типы возвращаемых значений ограничиваются выражениями, в которых ожидается использование оператора; например, операторы присваивания возвращают по ссылке, чтобы была возможность записать `a = b = c = d`, как это допускают встроенные операторы.

Общие перегруженные операторы имеют следующие типичные канонические формы:

### Оператор присваивания

Оператор присваивания (`operator=`) имеет особые свойства; подробности см. в разделах о копирующем и перемещающем присваивании.

Канонический оператор копирующего присваивания должен быть безопасен при самоприсваивании и возвращать левый операнд по ссылке:

```c++
// копирующее присваивание
T& operator=(const T& other)
{
    // Защита от самоприсваивания
    if (this == &other)
        return *this;

    // предполагаем, что *this управляет ресурсом, например, буфером mArray в куче
    if (size != other.size)           // ресурс в *this не может быть повторно использован
    {
        temp = new int[other.size];   // выделяем ресурс, если возникнет исключение, ничего не делаем
        delete[] mArray;              // освобождаем ресурс в *this
        mArray = temp;
        size = other.size;
    }

    std::copy(other.mArray, other.mArray + other.size, mArray);
    return *this;
}
```

Каноническое присваивание перемещения предполагает, что объект, из которого происходит перемещение, остается в допустимом состоянии (то есть состоянии с неизменными классными инвариантами). Также предполагается, что при самоприсвоении оно либо не выполняет никаких действий, либо оставляет объект в допустимом состоянии, а возвращаемое значение должно быть ссылкой на неконстантный объект. Кроме того, данная операция должна быть обозначена как noexcept:

```c++
// оператор присваивания перемещения
T& operator=(T&& other) noexcept
{
    // Защита от самоприсвоения
    if (this == &other)
        return *this; // delete[]/size=0 также будет допустимо

    delete[] mArray;                               // освобождение ресурса в *this
    mArray = std::exchange(other.mArray, nullptr); // оставляем other в допустимом состоянии
    size = std::exchange(other.size, 0);
    return *this;
}
(начиная с C++11)
```

В тех ситуациях, когда присваивание копированием не может использовать преимущества повторного использования ресурсов (например, если объект не управляет массивом, выделенным в куче, и не содержит (возможно, транзитивного) члена, который управляет таковым, как, например, std::vector или std::string), существует удобный сокращенный синтаксис: оператор присваивания копирования и обмена, который принимает параметр по значению (что позволяет ему работать как с присваиванием копирования, так и с присваиванием перемещения в зависимости от категории значения аргумента), осуществляет обмен с параметром и позволяет деструктору освободить ресурсы.
```cpp
// оператор присваивания копированием (идиома копирования и обмена)
T& T::operator=(T other) noexcept // вызывается конструктор копирования или перемещения для создания other
{
    std::swap(size, other.size); // обмен ресурсов между *this и other
    std::swap(mArray, other.mArray);
    return *this;
} // деструктор other вызывается для освобождения ресурсов, ранее управляемых *this
```

```c++
#include <iostream>
#include <iomanip>  // Для std::setw и std::setfill

class Clock {
public:
    Clock(int hours = 0, int minutes = 0, int seconds = 0)
        : hours(hours), minutes(minutes), seconds(seconds) {}

    // Оператор присваивания копированием
    Clock& operator=(const Clock& other) {
        if (this != &other) {  // Защита от самоприсвоения
            hours = other.hours;
            minutes = other.minutes;
            seconds = other.seconds;
        }
        return *this;
    }

    // Оператор присваивания перемещением
    Clock& operator=(Clock&& other) noexcept {
        if (this != &other) {  // Защита от самоприсвоения
            hours = other.hours;
            minutes = other.minutes;
            seconds = other.seconds;

            // Обнуление перемещаемого объекта
            other.hours = 0;
            other.minutes = 0;
            other.seconds = 0;
        }
        return *this;
    }

    // Метод для отображения времени
    void display() const {
        std::cout << std::setfill('0') << std::setw(2) << hours << ":"
                  << std::setfill('0') << std::setw(2) << minutes << ":"
                  << std::setfill('0') << std::setw(2) << seconds << std::endl;
    }

private:
    int hours;
    int minutes;
    int seconds;
};

int main() {
    Clock clock1(9, 5, 30); // Создаем первый объект
    Clock clock2;           // Создаем второй объект по умолчанию

    clock2 = clock1;       // Присваивание копированием
    std::cout << "Clock2 после копирования: ";
    clock2.display();

    Clock clock3(1, 2, 3);  // Создаем третий объект
    clock3 = std::move(clock2); // Присваивание перемещением
    std::cout << "Clock3 после перемещения: ";
    clock3.display();

    return 0;
}
```
### Оператор `<<`

Перегрузки операторов `>>` и `<<`, принимающие `std::istream&` или `std::ostream&` в качестве левого аргумента, известны как операторы вставки и извлечения. Поскольку они принимают пользовательский тип в качестве правого аргумента (b в выражении a @ b), их необходимо реализовать как функции вне класса.

```c++
std::ostream& operator<<(std::ostream& os, const T& obj)
{
    // Запись obj в поток
    return os;
}

std::istream& operator>>(std::istream& is, T& obj)
{
    // Чтение obj из потока
    if (/* не удалось сконструировать T */)
        is.setstate(std::ios::failbit);
    return is;
}

```

```c++
#include <iostream>
#include <iomanip> // Для std::setw и std::setfill

class Clock {
public:
    Clock(int hours, int minutes, int seconds)
        : hours(hours), minutes(minutes), seconds(seconds) {}

    // Перегрузка оператора << для вывода информации о часах
    friend std::ostream& operator<<(std::ostream& os, const Clock& clock) {
        os << std::setfill('0') << std::setw(2) << clock.hours << ":"
           << std::setfill('0') << std::setw(2) << clock.minutes << ":"
           << std::setfill('0') << std::setw(2) << clock.seconds;
        return os;
    }

private:
    int hours;
    int minutes;
    int seconds;
};

int main() {
    Clock clock(9, 5, 30); // Создаем объект часов
    std::cout << "Текущее время: " << clock << std::endl; // Используем перегруженный оператор
    return 0;
}
```

### Оператор вызова функции ()

Когда пользовательский класс перегружает оператор вызова функции `operator()`, он становится типом `FunctionObject`.

Объект такого типа может быть использован в выражении вызова функции:


```c++
// Объект этого типа представляет линейную функцию одной переменной a * x + b.
struct Linear
{
    double a, b;

    double operator()(double x) const
    {
        return a * x + b;
    }
};

int main()
{
    Linear f{2, 1};  // Представляет функцию 2x + 1.
    Linear g{-1, 0}; // Представляет функцию -x.
    // f и g — объекты, которые могут использоваться как функции.

    double f_0 = f(0);
    double f_1 = f(1);

    double g_0 = g(0);
}
```

Многие стандартные алгоритмы, начиная от `std::sort` до `std::accumulate`, принимают `FunctionObjects` для настройки поведения. Хотя не существует каких-либо особенно значимых канонических форм для `operator()`, можно проиллюстрировать его использование:

```c++
#include <iostream>
#include <iomanip>  // Для std::setw и std::setfill
#include <string>

class Clock {
public:
    Clock(int hours, int minutes, int seconds)
        : hours(hours), minutes(minutes), seconds(seconds) {}

    // Перегрузка оператора вызова функции для получения времени в строковом формате
    std::string operator()() const {
        std::ostringstream oss;
        oss << std::setfill('0') << std::setw(2) << hours << ":"
            << std::setfill('0') << std::setw(2) << minutes << ":"
            << std::setfill('0') << std::setw(2) << seconds;
        return oss.str();
    }

private:
    int hours;
    int minutes;
    int seconds;
};

int main() {
    Clock clock(9, 5, 30); // Создаем объект часов

    // Используем перегруженный оператор вызова функции
    std::cout << "Текущее время: " << clock() << std::endl;

    return 0;
}
```

### Инкремент и декремент
При появлении постфиксного оператора инкремента или декремента в выражении вызывается соответствующая пользовательская функция (`operator++` или `operator--`), принимающая в качестве аргумента целое число 0. Обычно это реализуется в виде `T operator++(int)` или `T operator--(int)`, где аргумент игнорируется. Постфиксные операторы инкремента и декремента, как правило, реализуются на основе префиксных версий:

```c++
struct X
{
    // префиксный инкремент
    X& operator++()
    {
        // фактический инкремент выполняется здесь
        return *this; // возвращает новое значение по ссылке
    }
 
    // постфиксный инкремент
    X operator++(int)
    {
        X old = *this; // копирование старого значения
        operator++();  // префиксный инкремент
        return old;    // возвращает старое значение
    }
 
    // префиксный декремент
    X& operator--()
    {
        // фактический декремент выполняется здесь
        return *this; // возвращает новое значение по ссылке
    }
 
    // постфиксный декремент
    X operator--(int)
    {
        X old = *this; // копирование старого значения
        operator--();  // префиксный декремент
        return old;    // возвращает старое значение
    }
};
```

Хотя канонические реализации префиксных операторов инкремента и декремента возвращают ссылку, как и любой перегруженный оператор, тип возвращаемого значения является пользовательским; например, перегрузки этих операторов для` std::atomic` возвращают по значению.

```c++
#include <iostream>
#include <iomanip>  // Для std::setw и std::setfill

class Clock {
public:
    Clock(int hours = 0, int minutes = 0, int seconds = 0)
        : hours(hours), minutes(minutes), seconds(seconds) {}

    // Перегрузка префиксного оператора инкремента
    Clock& operator++() {
        increment();  // Увеличиваем время на 1 секунду
        return *this;
    }

    // Перегрузка постфиксного оператора инкремента
    Clock operator++(int) {
        Clock temp = *this; // Сохраняем текущее время
        increment();        // Увеличиваем время на 1 секунду
        return temp;       // Возвращаем старое значение
    }

    // Перегрузка префиксного оператора декремента
    Clock& operator--() {
        decrement();  // Уменьшаем время на 1 секунду
        return *this;
    }

    // Перегрузка постфиксного оператора декремента
    Clock operator--(int) {
        Clock temp = *this; // Сохраняем текущее время
        decrement();        // Уменьшаем время на 1 секунду
        return temp;       // Возвращаем старое значение
    }

    // Метод для отображения времени
    void display() const {
        std::cout << std::setfill('0') << std::setw(2) << hours << ":"
                  << std::setfill('0') << std::setw(2) << minutes << ":"
                  << std::setfill('0') << std::setw(2) << seconds << std::endl;
    }

private:
    int hours;
    int minutes;
    int seconds;

    void increment() {
        seconds++;
        if (seconds >= 60) {
            seconds = 0;
            minutes++;
            if (minutes >= 60) {
                minutes = 0;
                hours++;
                if (hours >= 24) {
                    hours = 0; // Сброс до 0 после 23:59:59
                }
            }
        }
    }

    void decrement() {
        if (seconds == 0) {
            if (minutes == 0) {
                if (hours == 0) {
                    hours = 23; // Сброс до 23:59:59
                } else {
                    hours--;
                }
                minutes = 59;
                seconds = 59;
            } else {
                minutes--;
                seconds = 59;
            }
        } else {
            seconds--;
        }
    }
};

int main() {
    Clock clock(23, 59, 58); // Создаем объект часов

    std::cout << "Текущее время: ";
    clock.display();

    // Инкремент
    ++clock;  // Префиксный инкремент
    std::cout << "После префиксного инкремента: ";
    clock.display();

    clock++;  // Постфиксный инкремент
    std::cout << "После постфиксного инкремента: ";
    clock.display();

    // Декремент
    --clock;  // Префиксный декремент
    std::cout << "После префиксного декремента: ";
    clock.display();

    clock--;  // Постфиксный декремент
    std::cout << "После постфиксного декремента: ";
    clock.display();

    return 0;
}
```


### Двоичные арифметические операторы  
Двоичные операторы обычно реализуются как не-члены для сохранения симметрии (например, при сложении комплексного числа и целого числа, если оператор+ является членом функции комплексного типа, то будет компилироваться только сложение комплексного с целым, а не наоборот). Поскольку для каждого двоичного арифметического оператора существует соответствующий оператор составного присваивания, канонические формы двоичных операторов реализуются в терминах их составных присваиваний:

```c++
class X
{
public:
    X& operator+=(const X& rhs) // составное присваивание (не обязательно быть членом,
    {                            // но часто является, чтобы модифицировать закрытые члены)
        /* сложение rhs и *this выполняется здесь */
        return *this; // возвращает результат по ссылке
    }
 
    // дружественные функции, определенные внутри тела класса, являются инлайн и скрыты от поиска вне ADL
    friend X operator+(X lhs,        // передача lhs по значению помогает оптимизировать цепочки a+b+c
                       const X& rhs) // иначе оба параметра могут быть константными ссылками
    {
        lhs += rhs; // повторное использование составного присваивания
        return lhs; // возвращает результат по значению (использует конструктор перемещения)
    }
};

```
Пример
```c++
#include <iostream>

class Clock { 
private:
    int hours;   // Часы
    int minutes; // Минуты

public:
    Clock(int h = 0, int m = 0) : hours(h), minutes(m) {
        // Нормализация времени
        normalize();
    }

    // Составное присваивание
    Clock& operator+=(const Clock& rhs) {
        hours += rhs.hours;
        minutes += rhs.minutes;
        normalize();
        return *this; // Возвращаем текущий объект
    }

    // Дружественная функция для перегрузки оператора сложения
    friend Clock operator+(Clock lhs, const Clock& rhs) {
        lhs += rhs; // Используем оператор +=
        return lhs; // Возвращаем результат
    }

    // Метод для вывода времени
    void print() const {
        std::cout << hours << " ч " << minutes << " мин" << std::endl; // Вывод часов и минут
    }

private:
    void normalize() {
        if (minutes >= 60) {
            hours += minutes / 60;
            minutes %= 60;
        }
        if (hours < 0) {
            hours = 0; // Убедимся, что часы не отрицательные
            minutes = 0; // И минуты тоже
        }
    }
};

int main() {
    Clock time1(1, 30); // 1 час 30 минут
    Clock time2(2, 45); // 2 часа 45 минут

    Clock time3 = time1 + time2; // Используем перегруженный оператор +
    time3.print(); // Ожидаем 4 ч 15 мин

    time1 += time2; // Используем составное присваивание
    time1.print(); // Ожидаем 4 ч 15 мин

    return 0;
}
```

### Операторы сравнения  
Стандартные алгоритмы, такие как `std::sort`, и контейнеры, такие как `std::set`, ожидают, что оператор`<` будет определен по умолчанию для пользовательских типов и будет реализовывать строгий слабый порядок (тем самым удовлетворяя требованиям сравнения). Идиоматическим способом реализации строгого слабого порядка для структуры является использование лексикографического сравнения, предоставляемого `std::tie`:
```c++
struct Record
{
    std::string name;
    unsigned int floor;
    double weight;
 
    friend bool operator<(const Record& l, const Record& r)
    {
        return std::tie(l.name, l.floor, l.weight)
             < std::tie(r.name, r.floor, r.weight); // поддерживает тот же порядок
    }
};
```

Как правило, после предоставления оператора< остальные операторы отношения реализуются на основе оператора`<`:

```c++
inline bool operator< (const X& lhs, const X& rhs) { /* выполняем фактическое сравнение */ }
inline bool operator> (const X& lhs, const X& rhs) { return rhs < lhs; }
inline bool operator<=(const X& lhs, const X& rhs) { return !(lhs > rhs); }
inline bool operator>=(const X& lhs, const X& rhs) { return !(lhs < rhs); }
```

Аналогично, оператор неравенства обычно реализуется через оператор равенства:

```c++
inline bool operator==(const X& lhs, const X& rhs) { /* выполняем фактическое сравнение */ }
inline bool operator!=(const X& lhs, const X& rhs) { return !(lhs == rhs); }
```

Когда предоставляется трёхстороннее сравнение (например, `std::memcmp` или `std::string::compare`), все шесть двусторонних операторов сравнения могут быть выражены через него:

```c++
inline bool operator==(const X& lhs, const X& rhs) { return cmp(lhs, rhs) == 0; }
inline bool operator!=(const X& lhs, const X& rhs) { return cmp(lhs, rhs) != 0; }
inline bool operator< (const X& lhs, const X& rhs) { return cmp(lhs, rhs) <  0; }
inline bool operator> (const X& lhs, const X& rhs) { return cmp(lhs, rhs) >  0; }
inline bool operator<=(const X& lhs, const X& rhs) { return cmp(lhs, rhs) <= 0; }
inline bool operator>=(const X& lhs, const X& rhs) { return cmp(lhs, rhs) >= 0; }
```

Оператор неравенства автоматически генерируется компилятором, если оператор равенства `operator==` определён. Аналогичным образом, четыре оператора сравнения автоматически генерируются компилятором, если определён трёхсторонний оператор сравнения `operator<=>`. Операторы `operator==` и `operator!=`, в свою очередь, генерируются компилятором, если оператор `operator<=>` определён как стандартный:

```c++
struct Record
{
    std::string name;
    unsigned int floor;
    double weight;
 
    auto operator<=>(const Record&) const = default;
};
// теперь записи можно сравнивать с помощью ==, !=, <, <=, > и >=
```

```c++
#include <iostream>
#include <iomanip>
#include <sstream>
#include <tuple>

class Clock {
public:
    Clock(int hours, int minutes, int seconds)
        : hours(hours), minutes(minutes), seconds(seconds) {}

    // Overloading the function call operator to get time in string format
    std::string operator()() const {
        std::ostringstream oss;
        oss << std::setfill('0') << std::setw(2) << hours << ":"
            << std::setfill('0') << std::setw(2) << minutes << ":"
            << std::setfill('0') << std::setw(2) << seconds;
        return oss.str();
    }

    // Friend functions for comparison operators
    friend bool operator<(const Clock& lhs, const Clock& rhs) {
        return std::tie(lhs.hours, lhs.minutes, lhs.seconds) < 
               std::tie(rhs.hours, rhs.minutes, rhs.seconds);
    }

    friend bool operator>(const Clock& lhs, const Clock& rhs) {
        return rhs < lhs; // Reverse comparison
    }

    friend bool operator<=(const Clock& lhs, const Clock& rhs) {
        return !(rhs < lhs); // Not greater than
    }

    friend bool operator>=(const Clock& lhs, const Clock& rhs) {
        return !(lhs < rhs); // Not less than
    }

    friend bool operator==(const Clock& lhs, const Clock& rhs) {
        return std::tie(lhs.hours, lhs.minutes, lhs.seconds) == 
               std::tie(rhs.hours, rhs.minutes, rhs.seconds);
    }

    friend bool operator!=(const Clock& lhs, const Clock& rhs) {
        return !(lhs == rhs); // Not equal
    }

private:
    int hours;
    int minutes;
    int seconds;
};

int main() {
    Clock clock1(12, 30, 45);
    Clock clock2(14, 15, 30);

    std::cout << "Clock 1: " << clock1() << std::endl; // 12:30:45
    std::cout << "Clock 2: " << clock2() << std::endl; // 14:15:30

    // Comparison examples
    if (clock1 < clock2) {
        std::cout << "Clock 1 is earlier than Clock 2." << std::endl;
    }
    if (clock1 != clock2) {
        std::cout << "Clock 1 is not equal to Clock 2." << std::endl;
    }

    return 0;
}
```

### `friend`

В C++ объявление перегрузки операторов в качестве дружественных функций позволяет им напрямую обращаться к закрытым членам класса. Вот почему это может быть полезно: 
- **Доступ к закрытым элементам**: 
	- Cделав операторов сравнения друзьями, они могут напрямую обращаться к закрытым элементам данных класса `Clock` (таким как часы, минуты и секунды), не прибегая к общедоступным `getters`. Это упрощает интерфейс и обеспечивает более эффективный код. 
- **Функции, не являющиеся методами класса**: 
	- Операторы сравнения обычно реализуются как функции, не являющиеся членами, для симметрии. Например, если вы хотите сравнить два объекта `Clock`, имеет смысл определить операторы вне класса. Добавление их в `friend` позволяет этим функциям напрямую обращаться к внутренним компонентам класса. 
- **Согласованность**: 
	- когда такие операторы, как `==`, `<` или `>,` определены как **дружественные функции**, это соответствует идиоматическому способу обработки перегрузки операторов в C++. Это облегчает пользователям интуитивное понимание и использование класса. 
- **Гибкость**: 
	- Если вы позже решите изменить реализацию класса, вы можете сделать это без изменения функций **operator**, поскольку они по-прежнему имеют прямой доступ к внутреннему состоянию объекта.

```c++
// Without friend, you would need public getters
bool operator<(const Clock& lhs, const Clock& rhs) {
    return std::tie(lhs.getHours(), lhs.getMinutes(), lhs.getSeconds()) < 
           std::tie(rhs.getHours(), rhs.getMinutes(), rhs.getSeconds());
}
```

Такой подход менее эффективен и делает интерфейс класса более громоздким. Таким образом, использование дружественных функций является обычной практикой для достижения лучшей инкапсуляции и удобства использования в C++.