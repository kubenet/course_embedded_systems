# Курс: ООП
#oop #note

# Контрольная точка. "Интерфейсы С++"


## Интерфейсные классы

Интерфейсным классом называется абстрактный класс, не имеющий данных и состоящий в основном из чисто виртуальных функций. Такой класс может иметь обычные виртуальные функции (не чисто виртуальные), например деструктор. Также могут быть статические функции-члены, например функции-фабрики.

### Реализация интерфейсных классов

Реализацией интерфейсного класса считается производный класс, в котором переопределены чисто виртуальные функции. Существует два основных подхода к реализации интерфейсов:

1. **Горизонтальная**: несколько классов наследуют один и тот же интерфейсный класс.
2. **Вертикальная**: интерфейсный класс является корнем полиморфной иерархии.

Ключевой момент заключается в отделении интерфейса от реализации, что позволяет клиенту работать только с интерфейсным классом.

### Создание объектов

Создание объектов интерфейсного класса может вызывать трудности, так как клиент должен получить указатель на реализацию через функцию-фабрику. Эта функция создаёт объект с помощью оператора `new` и возвращает указатель на интерфейсный класс. Функция-фабрика может быть статическим членом интерфейсного класса или отдельной функцией.

### Удаление объектов

Удаление объектов в C++ требует осторожности. Возможны следующие подходы:

1. **Использование оператора `delete`**: требует открытого виртуального деструктора.
2. **Специальная виртуальная функция для удаления**: функция, которая вызывает `delete this`.
3. **Использование внешней функции**: не рекомендуется, так как не имеет преимуществ.
4. **Автоматическое удаление с помощью интеллектуального указателя**: предпочтительный вариант, так как он минимизирует ошибки.

### Управление временем жизни объектов

Клиент может получать указатель на интерфейсный класс, не владея им. Это часто происходит с синглтонами или объектами, управление временем жизни которых осуществляется реализацией.

### Семантика копирования

Копирование объектов интерфейсного класса невозможно с использованием копирующего конструктора. Вместо этого рекомендуется использовать виртуальную функцию, создающую копию объекта и возвращающую указатель на интерфейсный класс.

### Конструктор интерфейсного класса

Часто конструктор интерфейсного класса не объявляется, но если он требуется, рекомендуется сделать его защищённым и с определением по умолчанию.

## Пример

Интерфейсный класс — это абстрактный класс, который содержит только чисто виртуальные функции. В C++ для этого используется ключевое слово `virtual` с `= 0`. Например:
```c++
class IShape {
public:
    virtual void draw() = 0; // Чисто виртуальная функция
    virtual ~IShape() = default; // Виртуальный деструктор
};
```

Реализация интерфейса подразумевает создание класса, который наследует интерфейсный класс и переопределяет его методы.

```c++
class Circle : public IShape {
public:
    void draw() override {
        std::cout << "Drawing a Circle\n";
    }
};

class Square : public IShape {
public:
    void draw() override {
        std::cout << "Drawing a Square\n";
    }
};
```

Теперь давайте создадим объекты, используя интерфейсные классы и реализацию.

```c++
#include <iostream>
#include <memory>

class IShape {
public:
    virtual void draw() = 0; // Чисто виртуальная функция
    virtual ~IShape() = default; // Виртуальный деструктор
};

class Circle : public IShape {
public:
    void draw() override {
        std::cout << "Drawing a Circle\n";
    }
};

class Square : public IShape {
public:
    void draw() override {
        std::cout << "Drawing a Square\n";
    }
};

void drawShape(IShape& shape) {
    shape.draw(); // Вызываем метод draw у переданного объекта
}

int main() {
    Circle circle;
    Square square;

    drawShape(circle); // Рисуем круг
    drawShape(square); // Рисуем квадрат

    // Использование умных указателей для управления памятью
    std::unique_ptr<IShape> shape1 = std::make_unique<Circle>();
    std::unique_ptr<IShape> shape2 = std::make_unique<Square>();

    shape1->draw(); // Рисуем круг через умный указатель
    shape2->draw(); // Рисуем квадрат через умный указатель

    return 0; // Умные указатели автоматически очищают память
}
```