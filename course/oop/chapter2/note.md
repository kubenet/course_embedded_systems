# Курс: ООП
#computer_science #bash #note

# Практическое занятие №2. "Наследование"

## Наследование

На прошлом [занятии](course/oop/chapter1/note) мы рассмотрели основные инструменты создания объектов с использованием языка С++ и разобрались, что же такое [констуркторы](https://en.cppreference.com/w/cpp/language/constructor) и [деструкторы](https://en.cppreference.com/w/cpp/language/destructor).  На данном практическом занятии мы рассмотрим ....

Класс А представляет собой подкласс класса Б в том случае, если каждый объект, относящийся к классу А, также обязательно принадлежит классу Б. В этой ситуации класс А называется дочерним, а класс Б – родительским; класс А выступает как потомок, а класс Б – как предок. Класс Б можно охарактеризовать как более абстрактный (например, «птицы»), в то время как класс А является более конкретным (например, «вороны»).

Если класс А является подклассом класса Б, то он наследует все свойства класса-предка Б и может обладать дополнительными свойствами. Для минимизации описания классов А и Б целесообразно сначала изложить свойства класса Б, а затем, не повторяя все эти свойства в классе А, указать, что А является потомком Б, добавив лишь новые свойства, не переписывая уже существующие.

Круг и прямоугольник имеют различные наборы свойств, поскольку представляют собой разные классы. Тем не менее, можно выделить свойства, общие для обоих классов, такие как координаты центра, цвет, толщина линии, но не радиус или длина-ширина. Вопрос заключается в том, можем ли мы рассматривать круг как подкласс прямоугольника, или наоборот, прямоугольник как подкласс круга? Ответ отрицательный в обоих случаях, поскольку свойства одного набора будут подмножеством свойств другого, и это не соответствует нашему описанию реальности.

Однако решение проблемы существует. В объектно-ориентированном подходе и круг, и прямоугольник имеют общий набор свойств не из-за того, что один является подтипом другого, а потому, что оба являются подтипами третьего класса, который охватывает все их общие свойства. Этот третий класс можно обозначить как «фигура», поскольку он представляет собой общее множество свойств, принадлежащее как кругу, так и прямоугольнику.

Что касается кода, любой класс может быть объявлен как подкласс другого класса и таким образом унаследует от предка все его свойства и методы.

```c++
class Point {
public:
    int x;
    int y;

    // Default constructor initializes point to (0, 0)
    Point() : x(0), y(0) {}

    // Parameterized constructor initializes point to (x, y)
    Point(int x, int y) : x(x), y(y) {}

    // Method to compute the squared distance to another point
    int distanceTo(const Point& p2) const {
        return (x - p2.x) * (x - p2.x) + (y - p2.y) * (y - p2.y);
    }
};

class ColoredPoint : public Point {
public:
    int color;

    // Default constructor initializes point to (0, 0) and color to 0
    ColoredPoint() : Point(), color(0) {}

    // Parameterized constructor initializes point to (x, y) and color to the specified value
    ColoredPoint(int x, int y, int color) : Point(x, y), color(color) {}

    // Method to check if this point has the same color as another ColoredPoint
    bool sameColorAs(const ColoredPoint& p2) const {
        return p2.color == this->color;
    }
};

```

Класс `ColoredPoint` объявлен как публичный наследник класса `Point`, что означает, что экземпляры `ColoredPoint` будут обладать не только свойствами `x` и `y`, и методом `distTo`, но и дополнительным свойством `color`, а также методом `sameColorAs`. Таким образом, все указанные свойства и методы доступны для любого объекта типа `ColoredPoint`, созданного следующим образом:

```c++
ColoredPoint cp;
cp.x = 5;
cp.y = 6;
cp.color = 255;
```

Хотя наследование часто упоминается как один из принципов объектно-ориентированного программирования, его название, на мой взгляд, несколько неудачно. В реальной жизни термины **наследование** и **наследник** имеют несколько иной смысл. Более корректно было бы говорить о **создании подтипов**, однако, как бы то ни было, текущее обозначение сохранилось.

Важно также различать два аспекта **наследования**: как конкретную технологию, способ переноса свойств и методов из одного класса в другой, и как отношение между классами, моделирующее ситуацию, в которой объект класса-подтипа обязательно является объектом **класса-супертипа**.

```c++
class Circle: public Point{
	public:
		int radius;
		Circle(){
			x = 0;
			y = 0;
			radius = 0;
		}
}
```
В представленном примере, технически, класс `Circle` должен содержать все свойства класса `Point`, включая дополнительные свойства, такие как радиус. На первый взгляд, это делает наследование оправданным. Однако интуитивно возникает вопрос: является ли круг частным случаем точки? В случае с `Point` и `ColoredPoint` связь более очевидна: цветная точка действительно воспринимается как частный случай точки. Эта проблема будет более детально рассмотрена при обсуждении принципов SOLID. В то время как вы можете задуматься о том, какое из классов, например, «эллипс» или «круг», должно быть подклассом другого.

При наследовании важно учитывать модификаторы видимости атрибутов и методов. Если в базовом классе некоторые свойства и методы являются приватными, то подкласс не сможет использовать их в своих методах. Например, следующий код не скомпилируется, поскольку `x` и `y` объявлены в базовом классе как приватные, что делает эти свойства недоступными в методах производных классов:
```c++
class Point {
private:
    int x;
    int y;
public:
    Point() {
        x = 0;
        y = 0;
    }
};

class ColoredPoint : public Point {
private:
    int color;
public:
    ColoredPoint() {
        x = 0;
        y = 0;
        color = 0;
    }
};

```

Но делать свойства публичными также не является лучшим решением. В этой ситуации можно использовать модификатор `protected`, который предоставляет промежуточный уровень доступа: свойства и методы, обозначенные этим модификатором, доступны как в методах самого класса, так и в методах классов-потомков:

```c++
class Point {
protected:
    int x;
    int y;
    ...
};

```
Кроме того, существует три типа наследования: public (наиболее часто используемый), protected и private, которые указывают на то, как изменяется видимость (доступность) атрибутов базового класса в производном классе. Использование соответствующего ключевого слова при объявлении класса-потомка определяет, как будет изменяться доступ к атрибутам базового класса.

|                     | Каким станет атрибут |           |         |     |
| ------------------- | -------------------- | --------- | ------- | --- |
| Бывший тип атрибута | public               | protected | private |     |
| public              | public               | protected | private |     |
| protected           | protected            | protected | private |     |
| private             | private              | private   | private |     |
При публичном наследовании видимость атрибутов и методов базового класса остаётся неизменной: те, которые были public в предке, такими же остаются и в потомке. При protected-наследовании члены базового класса, которые были public, становятся protected в потомке, в то время как остальные члены сохраняют свою изначальную видимость. При private-наследовании все члены базового класса становятся private в производном классе.

Возвращаясь к вопросу о приватном наследовании, можно задать вопрос: является ли объект `ColoredPoint` одновременно объектом `Point` в следующем примере?

```c++
class ColoredPoint : private Point {
private:
    int color;
public:
    ...
};
```


Этот вопрос не имеет однозначного ответа. С одной стороны, `ColoredPoint` включает все свойства и методы `Point`, с другой стороны, внешний интерфейс `ColoredPoint` не демонстрирует, что он является `Point`. Например:

```c++
ColoredPoint cp;
cp.distTo(...); // ???

```
Такой вопрос важен, поскольку он может подразумевать две разные вещи: внутреннюю реализацию или внешнее поведение объекта. Например, вопрос «Является ли объект X уткой?» может означать: «Является ли объект X биологическим объектом семейства Anatidae?» или «Умеет ли объект X летать, плавать и издавать звуки, характерные для уток?». Другими словами, вопрос может касаться внутреннего содержания (реализации) или внешнего поведения (интерфейса) объекта. Чтобы избежать недоразумений, важно уточнять, что именно имеется в виду, или предоставлять максимально полный ответ.

В случае непубличного наследования `ColoredPoint` от `Point`, можно утверждать, что `ColoredPoint` «внутри» является `Point`, поскольку включает все её свойства и методы. Однако снаружи `ColoredPoint` не выглядит как `Point`, так как его интерфейс не включает публичные методы `Point`.

При публичном наследовании `ColoredPoint` и является, и выглядит как `Point`, так что в этом случае различия нет. Публичное наследование используется чаще всего.

Конструкторы и деструкторы могут присутствовать или отсутствовать как в базовом, так и в производном классах. Поскольку производный класс «внутри» содержит базовый класс, создание объекта `ColoredPoint` неизбежно включает создание объекта `Point`. Поэтому при создании объекта `ColoredPoint` сначала вызывается конструктор `Point`, затем конструктор `ColoredPoint`, а при уничтожении сначала вызывается деструктор `ColoredPoint`, а затем деструктор `Point`.

```c++
class Point {
public:
    Point() {}
    ~Point() {}
};

class ColoredPoint : public Point {
public:
    ColoredPoint() {}
    ~ColoredPoint() {}
};
```

При создании объекта в иерархии классов конструкторы всех предков вызываются последовательно, начиная с самого удалённого. При удалении объекта деструкторы вызываются в обратном порядке. В некоторых других языках программирования конструкторы и деструкторы нужно вызывать явно, но в C++ это происходит автоматически. Однако в C++ также можно контролировать вызов конструктора базового класса через секцию инициализации конструктора производного класса, что предоставляет дополнительную гибкость.

```c++
class Point {
private:
    int x;
    int y;

public:
    // Конструктор по умолчанию
    Point() : x(0), y(0) {}

    // Конструктор с параметрами
    Point(int x, int y) : x(x), y(y) {}

    // Конструктор копирования
    Point(const Point &t) : x(t.x), y(t.y) {}

    // Деструктор
    ~Point() {}
};

class ColoredPoint : public Point {
private:
    int color;

public:
    // Конструктор по умолчанию
    ColoredPoint() : Point(), color(0) {}

    // Конструктор с параметрами
    ColoredPoint(int x, int y, int color) : Point(x, y), color(color) {}

    // Конструктор копирования
    ColoredPoint(const ColoredPoint &t) : Point(t), color(t.color) {}

    // Деструктор
    ~ColoredPoint() {}
};

```

> Конструктор по умолчанию `ColoredPoint` вызывает конструктор по умолчанию `Point`. Конструктор с параметрами `ColoredPoint` вызывает конструктор с параметрами `Point`, конструктор копирования `ColoredPoint` – конструктор `Point`, и во всех трёх случаях конструкторы затем инициализируют оставшееся свойство.

## Расширение и изменения объектов при наследовании

До настоящего времени акцент делался на добавлении новых данных в класс-наследник. При наследовании класс-потомок может добавлять новые свойства и методы, но наследует и старые свойства и методы базового класса, которые не может удалить. В отличие от свойств, методы могут быть переопределены: класс-наследник получает все методы базового класса и может заменить их собственными реализациями. Наследование часто используется для изменения поведения существующего класса без изменения его исходного кода.

Таким образом, класс-наследник может:

- добавлять новые свойства;
- добавлять новые методы;
- переопределять существующие методы.

Хотя наследование не изменяет базовый класс, оно позволяет создать новый класс с изменённым поведением, сохраняя при этом исходную структуру. Для переопределения метода в производном классе необходимо объявить метод с той же сигнатурой, но с другой реализацией:

```c++
class Point {
private:
    int x;
    int y;

public:
    Point(int x, int y) : x(x), y(y) {}

    float area() {
        return 0;
    }

    void dump() {
        printf("x = %d, y = %d\n", x, y);
    }
};

class Circle : public Point {
private:
    int radius;

public:
    Circle(int x, int y, int radius) : Point(x, y), radius(radius) {}

    float area()  {
        return 3.14 * radius * radius;
    }

    void dump()  {
        printf("radius = %d, ", radius);
        Point::dump();
    }
};

```

В этом примере класс `Circle` переопределяет методы `area` и `dump`. Метод `area` полностью заменяет реализацию метода `area` класса `Point`, тогда как метод `dump` добавляет новую функциональность и затем вызывает метод `dump` базового класса с помощью `Point::dump()`.

Хотя синтаксис может варьироваться между языками программирования, основная идея остаётся той же: метод производного класса заменяет метод базового класса, при этом возможно вызов унаследованной версии. Это стандартная практика для адаптации поведения метода класса к новым требованиям.

Для демонстрации доступности методов базового класса используется следующий синтаксис:

```c++
Circle c(5, 6, 7);
c.dump();           // Вызов метода dump класса Circle
c.Point::dump();   // Явный вызов метода dump из класса Point
```
В первом случае вызывается метод `dump` класса `Circle`, во втором — унаследованный метод `dump` класса `Point`.

