# Курс: ООП
#computer_science #bash #note

# Практическое занятие №2. "Наследование"
###  Пример 0: Наследования класса `Car`

```c++
#include <iostream>
#include <cstring>

class Car
{
private:
   char   *make;
   char   *model;
   int    year;
   double mileage;

public:
   // Constructor
   Car(const char *make, const char *model, int year, double mileage)
      : year(year)
      , mileage(mileage)
   {
      this->make = new char[strlen(make) + 1];
      strcpy(this->make, make);
      this->model = new char[strlen(model) + 1];
      strcpy(this->model, model);
   }

   // Copy Constructor
   Car(const Car &other)
      : year(other.year)
      , mileage(other.mileage)
   {
      make = new char[strlen(other.make) + 1];
      strcpy(make, other.make);
      model = new char[strlen(other.model) + 1];
      strcpy(model, other.model);
   }

   // Destructor
   ~Car()
   {
      delete[] make;
      delete[] model;
      std::cout << "Car object has been destroyed." << std::endl;
   }


   // Method to output vehicle mileage information
   void displayMileage() const
   {
      std::cout << "Vehicle " << make << " " << model << " (" << year << ") has "
                << mileage << " miles." << std::endl;
   }

    // Setter for mileage: Updates the mileage of the car.
   void setMileage(double newMileage) 
   {
     mileage = newMileage;
   }
};

class ElectricCar : public Car
{
private:
   double batteryCapacity;
   double chargingTime;

public:
   // Constructor
   ElectricCar(const char *make, const char *model, int year, double mileage, double batteryCapacity, double chargingTime)
      : Car(make, model, year, mileage)
      , batteryCapacity(batteryCapacity)
      , chargingTime(chargingTime)
   {
   }

   // Destructor
   ~ElectricCar()
   {
      std::cout << "ElectricCar object has been destroyed." << std::endl;
   }

   // Method to display battery information
   void displayBatteryInfo() const
   {
      std::cout << "Electric Car with " << batteryCapacity << " kWh battery capacity and "
                << chargingTime << " hours charging time." << std::endl;
   }
};

// Main function to test the ElectricCar class
int main()
{
   ElectricCar eCar("Tesla", "Model S", 2023, 5000.0, 100.0, 1.5);
   eCar.displayMileage();
   eCar.displayBatteryInfo();
   return 0;
}
```

### Задание 1: Наследование класса `Student`

**Цель:** Расширить функциональность класса `Student` с помощью наследования.

**Задание:** Создайте класс `InternationalStudent`, который наследует от класса `Student`. Этот класс должен добавлять следующие новые поля и методы:

- **Поля:**
    - `country` (страна происхождения)
    - `language` (язык общения)
- **Методы:**
    - `displayInternationalStudentInfo()` – выводит информацию о стране происхождения и языке общения.

**Конструктор** класса `InternationalStudent` должен принимать все параметры конструктора базового класса `Student`, а также новые поля.

**Деструктор** класса `InternationalStudent` должен выводить сообщение о завершении обучения международного студента.

### Задание 2: Наследование класса `Book`

**Цель:** Расширить функциональность класса `Book` с помощью наследования.

**Задание:** Создайте класс `Textbook`, который наследует от класса `Book`. Этот класс должен добавлять следующие новые поля и методы:

- **Поля:**
    - `subject` (предмет)
    - `edition` (издание)
- **Методы:**
    - `displayTextbookInfo()` – выводит информацию о предмете и издании.

**Конструктор** класса `Textbook` должен принимать все параметры конструктора базового класса `Book`, а также новые поля.

**Деструктор** класса `Textbook` должен выводить сообщение о том, что объект "Учебник" уничтожен.

### Задание 3: Наследование класса `Computer`

**Цель:** Расширить функциональность класса `Computer` с помощью наследования.

**Задание:** Создайте класс `DesktopComputer`, который наследует от класса `Computer`. Этот класс должен добавлять следующие новые поля и методы:

- **Поля:**
    - `monitorSize` (размер монитора в дюймах)
    - `isGamingPC` (является ли игровой ПК)
- **Методы:**
    - `displayDesktopInfo()` – выводит информацию о размере монитора и статусе игрового ПК.

**Конструктор** класса `DesktopComputer` должен принимать все параметры конструктора базового класса `Computer`, а также новые поля.

**Деструктор** класса `DesktopComputer` должен выводить сообщение о завершении работы настольного компьютера.

### Задание 4: Наследование класса `BankAccount`

**Цель:** Расширить функциональность класса `BankAccount` с помощью наследования.

**Задание:** Создайте класс `CheckingAccount`, который наследует от класса `BankAccount`. Этот класс должен добавлять следующие новые поля и методы:

- **Поля:**
    - `overdraftLimit` (лимит овердрафта)
- **Методы:**
    - `setOverdraftLimit(double limit)` – устанавливает лимит овердрафта.
    - `displayAccountInfo()` – выводит информацию о лимите овердрафта и текущем балансе.

**Конструктор** класса `CheckingAccount` должен принимать все параметры конструктора базового класса `BankAccount` и новое поле `overdraftLimit`.

**Деструктор** класса `CheckingAccount` должен выводить сообщение о закрытии расчетного счета.

### Задание 5: Наследование класса `Phone`

**Цель:** Расширить функциональность класса `Phone` с помощью наследования.

**Задание:** Создайте класс `FeaturePhone`, который наследует от класса `Phone`. Этот класс должен добавлять следующие новые поля и методы:

- **Поля:**
    - `hasCamera` (наличие камеры)
    - `hasBluetooth` (наличие Bluetooth)
- **Методы:**
    - `displayFeaturePhoneInfo()` – выводит информацию о наличии камеры и Bluetooth.

**Конструктор** класса `FeaturePhone` должен принимать все параметры конструктора базового класса `Phone`, а также новые поля.

**Деструктор** класса `FeaturePhone` должен выводить сообщение о том, что телефон отключен.
### Задание 6: Наследование класса `Player`

**Цель:** Расширить функциональность класса `Player` с помощью наследования.

**Задание:** Создайте класс `ProfessionalPlayer`, который наследует от класса `Player`. Этот класс должен добавлять следующие новые поля и методы:

- **Поля:**
    - `team` (команда, в которой играет игрок)
    - `salary` (зарплата игрока)
- **Методы:**
    - `displayPlayerInfo()` – выводит информацию о команде и зарплате игрока.

**Конструктор** класса `ProfessionalPlayer` должен принимать все параметры конструктора базового класса `Player`, а также новые поля.

**Деструктор** класса `ProfessionalPlayer` должен выводить сообщение об удалении профессионального игрока.

### Задание 7: Наследование класса `Movie`

**Цель:** Расширить функциональность класса `Movie` с помощью наследования.

**Задание:** Создайте класс `Documentary`, который наследует от класса `Movie`. Этот класс должен добавлять следующие новые поля и методы:

- **Поля:**
    - `subject` (тема документального фильма)
    - `duration` (продолжительность в минутах)
- **Методы:**
    - `displayDocumentaryInfo()` – выводит информацию о теме и продолжительности документального фильма.

**Конструктор** класса `Documentary` должен принимать все параметры конструктора базового класса `Movie`, а также новые поля.

**Деструктор** класса `Documentary` должен выводить сообщение о завершении показа документального фильма.

### Задание 8: Наследование класса `Worker`

**Цель:** Расширить функциональность класса `Worker` с помощью наследования.

**Задание:** Создайте класс `Manager`, который наследует от класса `Worker`. Этот класс должен добавлять следующие новые поля и методы:

- **Поля:**
    - `department` (отдел, в котором работает менеджер)
    - `bonus` (премия менеджера)
- **Методы:**
    - `displayManagerInfo()` – выводит информацию об отделе и премии.

**Конструктор** класса `Manager` должен принимать все параметры конструктора базового класса `Worker`, а также новые поля.

**Деструктор** класса `Manager` должен выводить сообщение об увольнении менеджера.

### Задание 9: Наследование класса `Product`

**Цель:** Расширить функциональность класса `Product` с помощью наследования.

**Задание:** Создайте класс `PerishableProduct`, который наследует от класса `Product`. Этот класс должен добавлять следующие новые поля и методы:

- **Поля:**
    - `expirationDate` (срок годности)
    - `storageConditions` (условия хранения)
- **Методы:**
    - `displayPerishableInfo()` – выводит информацию о сроке годности и условиях хранения.

**Конструктор** класса `PerishableProduct` должен принимать все параметры конструктора базового класса `Product`, а также новые поля.

**Деструктор** класса `PerishableProduct` должен выводить сообщение о том, что товар больше не хранится на складе.

### Задание 10. Композиция Точки

**Цель:** Продемонстрировать понимание концепций композиции и глубокого копирования в объектно-ориентированном программировании, используя классы `Point` и `Section`.

**Задание:**

1. **Создайте класс `Point`:**
    
    - **Поля:**
        - `x` (координата X)
        - `y` (координата Y)
    - **Методы:**
        - Конструктор для инициализации координат.
        - Конструктор копирования.
        - Деструктор.
        - Метод `display()` для вывода информации о точке.
        - Метод `move(int dx, int dy)` для смещения точки на указанное расстояние.
2. **Создайте класс `Section`:**
    
    - **Поля:**
        - `pbeg` (начальная точка отрезка типа `Point`)
        - `pend` (конечная точка отрезка типа `Point`)
    - **Методы:**
        - Конструктор по умолчанию, который инициализирует `pbeg` и `pend` как точки с координатами (0, 0).
        - Конструктор с параметрами, который принимает координаты начальной и конечной точки и инициализирует `pbeg` и `pend`.
        - Конструктор копирования, который создаёт глубокую копию объектов `pbeg` и `pend`.
        - Деструктор, который освобождает ресурсы.
        - Метод `display()` для вывода информации об отрезке, включая координаты начальной и конечной точек.
        - Метод `length()` для вычисления длины отрезка.
3. **Добавьте обработку глубокого копирования:**
    
    - Убедитесь, что конструктор копирования класса `Section` создаёт новые объекты `Point`, а не просто копирует указатели на существующие точки. Проверьте, что деструктор корректно удаляет созданные объекты `Point`.
4. **Проверьте корректность работы классов:**
    
    - Напишите программу, которая создаёт несколько объектов `Section`, копирует их и изменяет координаты точек, чтобы убедиться, что каждое изменение затрагивает только нужный объект.
    - Проверьте работу методов `display()` и `length()` для каждого объекта.