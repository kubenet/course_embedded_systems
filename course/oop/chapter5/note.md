# Курс: ООП
#oop #note

# Практическое занятие №5. "Шаблоны С++ или минное поле"


Шаблоны — это такие части кода, в которых некоторые части могут меняться. Например, можно использовать разные типы данных.

Компилятор превращает шаблоны в обычный код, когда мы его используем.

В **C++** есть стандартная библиотека, которая называется **STL**. В ней есть шаблоны, которые можно использовать с разными типами данных.

В **STL** есть контейнеры и итераторы, которые можно использовать для хранения и обработки данных. Алгоритмы из STL тоже можно использовать с разными типами данных.

Но сначала вспомним о перегрузке функций.

## Перегрузка функций

В языке C++ можно создать функцию с одним именем, но разными наборами или типами аргументов и разными телами. Такие функции называются перегруженными.

Рассмотрим пример семейства перегруженных функций для печати переменной на экран.


```c++
#include <iostream>
#include <string>

void Print(int value) {
    std::cout << value << "\n";
}

void Print(const std::string& name, int value) {
    std::cout << name << ": " << value << "\n";  // печатаем название и саму величину
}

void Print(const std::string& str) {
    std::cout << str << "\n";
}

int main() {
    Print(42);  // версия 1
    Print("x", 42);  // версия 2
    Print("good bye");  // версия 3
}
```
Компилятор сравнивает разные версии функции по их именам и набору типов аргументов. Имена аргументов не влияют на выбор версии функции.

```c++
int f(int x) {
    return x;
}

int f(int y) {  // ошибка компиляции: функция с таким именем и типом параметра уже была
    return 2 * y;
}

double f(int x) {  // ошибка компиляции: перегружать по возвращаемому значению нельзя
    return 3 * x;
}
```
## Шаблонные функции

Рассмотрим классический пример. Предположим, у нас есть функция, вычисляющая максимум целых чисел:
```c++
int Max(int x, int y) {
    if (x > y) {
        return x;
    } else {
        return y;
    }
}
```

Она определена для аргументов типа `int`. Однако, если применить её к аргументам типа `double`, результат получится неожиданным. А её применение к строкам или векторам вообще не скомпилируется:

```c++
#include <iostream>
#include <string>

int main() {
    std::cout << Max(1, 2) << "\n";  // 2
    std::cout << Max(3.14159, 2.71828) << "\n";  // внезапно 3

    std::string word1 = "hello", word2 = "world";
    std::cout << Max(word1, word2);  // ошибка компиляции
}
```

В вызове `Max(3.14159, 2.71828)` аргументы будут преобразованы к типу `int`, то есть получится `Max(3, 2)`. Вызов `Max(word1, word2)` не скомпилируется, так как строки нельзя привести к типу `int`. Чтобы эти вызовы корректно заработали, надо определить перегруженные версии функции `Max`:

```c++
#include <iostream>
#include <string>

int Max(int x, int y) {
    if (x > y) {
        return x;
    } else {
        return y;
    }
}

double Max(double x, double y) {
    if (x > y) {
        return x;
    } else {
        return y;
    }
}

std::string Max(const std::string& x, const std::string& y) {
    if (x > y) {
        return x;
    } else {
        return y;
    }
}

int main() {
    std::cout << Max(1, 2) << "\n";  // 2
    std::cout << Max(3.14159, 2.71828) << "\n";  // 3.14159

    std::string word1 = "hello", word2 = "world";
    std::cout << Max(word1, word2);  // world
}
```
Составление идентичных функций — занятие утомительное и не всегда оправданное. Более того, такие функции не способны корректно обрабатывать новые, заранее неизвестные типы данных.

Однако шаблоны предоставляют возможность описать функцию единожды, выделив тип в качестве параметра.
```c++
template <typename T>
T Max(const T& x, const T& y) {
    if (x > y) {
        return x;
    } else {
        return y;
    }
}
```
Шаблон начинается с шапки `template`, после чего в угловых скобках указываются формальные имена параметров. В нашем случае параметр один — это тип `T` (от слова `type`). Вместо ключевого слова `typename` в этом месте допускается использовать слово `class` (вы можете встретить такие описания шаблонов на [cppreference.com](https://cppreference.com/)). А вместо имени T можно было бы использовать любой другой идентификатор.

Поскольку мы не знаем, будет ли тип T встроенным или сложным, мы на всякий случай передаём аргументы в функцию по константной ссылке, чтобы избежать ненужного копирования.

В нашей шаблонной функции Max используется оператор >. Он определён для обычных чисел, строк и векторов (если, конечно, для элементов вектора тоже определён этот оператор). Однако если применить наш шаблон к типу, не поддерживающему оператор >, то произойдёт ошибка компиляции.

```c++
struct Point {
    double x = 0.0;
    double y = 0.0;
    double z = 0.0;
};

int main() {
    Point p1, p2;
    Point p = Max(p1, p2);  // ошибка компиляции
}
```

## Вывод шаблонных параметров

Для каждого типа данных существует своя конкретная версия шаблонной функции `Max`. Она получается путём подстановки шаблонных аргументов в **угловые скобки**. Например, `Max<int>` — это версия функции для типа `int`, а `Max<std::string>` — версия для строк.

Важно понимать, что, несмотря на общий шаблон, это разные функции, которые создаются компилятором по образцу.

```c++
Max<double>(3.14159, 2.71828);  // 3.14159
Max<int>(3.14159, 2.71828);  // вызывается int-версия, вернётся 
```

Однако параметры шаблона в угловых скобках можно не писать: компилятор попытается сам угадать эти параметры по типу аргументов:

```c++
int main() {
    std::cout << Max(1, 2) << "\n";  // 2, вызывается Max<int>
    std::cout << Max(3.14159, 2.71828) << "\n";  // 3.14159, вызывается Max<double>

    std::string word1 = "hello", word2 = "world";
    std::cout << Max(word1, word2);  // world, вызывается Max<std::string>
}
```

## Перегрузка шаблонных функций

Шаблонные функции также могут быть [перегружены](https://en.cppreference.com/w/cpp/language/function_template#Function_template_overloading). Допустим, мы хотим вычислить максимум двух векторов, но при этом сравнить их сначала по размеру, а затем лексикографически. Стандартное сравнение векторов с помощью оператора `>` не учитывает размер. Поэтому мы создадим отдельную перегрузку для векторов.

```c++
#include <iostream>
#include <vector>

// общая версия
template <typename T>
T Max(const T& x, const T& y) {
    if (x > y) {
        return x;
    } else {
        return y;
    }
}

// перегрузка для векторов
template <typename T>
const std::vector<T>& Max(const std::vector<T>& v1, const std::vector<T>& v2) {
    if (v1.size() > v2.size()) {
        return v1;
    } else if (v1.size() < v2.size()) {
        return v2;
    } else if (v1 > v2) {
        return v1;
    } else {
        return v2;
    }
}

int main() {
    std::cout << Max(1, 2) << "\n";  // вызов общей версии

    std::vector<int> v1 = {1, 2, 3};
    std::vector<int> v2 = {4, 5};
    for (int x : Max(v1, v2)) {  // вызов перегруженной версии
        std::cout << x << " ";  // 1 2 3
    }
    std::cout << "\n";
}
```


## Разрешение неоднозначностей

В процессе компиляции, когда интерпретатор сталкивается с вызовом функции, ему необходимо определить, в каком пространстве имён следует искать функцию, какую из перегруженных версий использовать, а в случае с шаблонной функцией — как правильно вывести параметры шаблона.

После выбора перегруженной версии шаблонной функции может возникнуть необходимость в выборе [полной специализации шаблона](https://en.cppreference.com/w/cpp/language/template_specialization).

Правила поиска нужной функции [довольно сложны](https://en.cppreference.com/w/cpp/language/overload_resolution) и не будут здесь полностью описаны. Однако в контексте нашего учебника выбор функции будет интуитивно понятен.

## Шаблонные структуры

Структуры и классы также могут быть описаны в общем виде и параметризованы типами или константами времени компиляции. Типичный пример шаблонной структуры — `std::pair`. Определим по аналогии свою структуру `Triple` с тремя шаблонными типами:

```c++
#include <string>

template <typename T1, typename T2, typename T3>
struct Triple {
    T1 first;
    T2 second;
    T3 third;
};

int main() {
    Triple<int, int, int> point = {-1, 3, 2};
    Triple<std::string, std::string, int> wordPairsFreq = {"hello", "world", 42};
}
```

Здесь так же, как и в случае функций, компилятор генерирует по образцу две никак не связанные друг с другом структуры `Triple<int, int, int>` и `Triple<std::string, std::string, int>`.

## Шаблонные классы 
Пришло время детально изучить особенности шаблонов C++ и их идею.

Допусти у нас есть два класса:

```c++
class CArrayInt {
private:
    int[] _values;
    int _size;

public:
    CArrayInt(int size) {
        _size = size;
        _values = new int[_size];
   }

    int getCount() {
        return _size;
   }

    int getValue(int i) {
        return _values[i];
   }

    void setValue(int i, int item) {
        _values[i] = item;
   }

    virtual ~CArrayInt() {
        delete[] _values;
   }
}
```

и

```c++
class CArrayFloat {
private:
    float *_values;
    int _size;

public:
    CArrayFloat(int size) {
        _size = size;
        _values = new float[_size];
   }

    int getCount() {
        return _size;
   }

    float getValue(int i) {
        return _values[i];
   }

    void setValue(int i, float item) {
        _values[i] = item;
   }

    virtual ~CArrayFloat() {
        delete[_values];
   }
};
```
Один код может быть преобразован в другой путём автоматической замены одного типа на другой. Однако не все типы `int` могут быть заменены, поскольку они используются в качестве индексов.

Чтобы избежать необходимости копировать и вставлять код, можно использовать шаблоны. Вместо того чтобы заменять `int` на `float`, можно использовать имя `T`. Компилятору нужно указать, что это не настоящий тип, а просто имя, которое будет заменено на что-то другое.

```c++
template <class T>
class CArray {

private:
    T[] _values;
    int _size;

public:

    CArray(int size) {
        _size = size;
        _values = new T[_size];
   }

    int getCount() {
        return _size;
   }

    T getValue(int index) {
        return _values[index];
   }

    void setValue(int index, T item) {
        _values[index] = item;
   }

    virtual ~CArray() {
        delete[] _values;
   }
};
```

Если не обращать внимания на первую строку шаблона <class T>, то всё остальное — это просто шаблон, который можно использовать.

Можно заменить T на int и получить первый класс, а если заменить T на float, то получится второй класс.

Собственно, компилятор именно так и работает.

Мы не можем создавать объекты класса CArray самостоятельно, потому что это не класс, а шаблонный класс, то есть шаблон для создания класса. Но мы можем создавать объекты варианта класса CArray, где T заменено на то, что нам нужно в данный момент:

```c++
CArray<int> arr1(10);
CArray<float> arr2(10);
CArray<Base*> arr3(10);
```
Когда препроцессор встречает шаблон `CArray<float>`, он копирует исходный код `CArray`, называет его `CArrayfloat` и заменяет в нём тип `T` на `float`. Если же встречается `CArray<Base*>`, то процесс происходит аналогичным образом, только с заменой `T` на `Base*`.

Таким образом, один раз написав шаблон, можно избавиться от необходимости копировать и вставлять множество похожих классов, которые отличаются лишь типами данных или константными значениями. Однако при компиляции исходный код всё равно будет размножен и скомпилирован, но мы этого не увидим.

Именно эта скрытая природа шаблонов становится основной проблемой при их использовании. Если в исполняемом коде возникнет ошибка, то не всегда легко определить её источник, поскольку она может быть скрыта в размноженном коде, который мы не видим.

Кроме того, работа с шаблонами требует развитого воображения, чтобы мысленно представить, что получится при подстановке различных значений в шаблон. Например, попробуйте представить, как будут работать функции `getValue` и `setValue` с разными типами данных. **Для этого создайте у класса `Base` полный набор конструкторов с отладочным выводом, чтобы убедиться в этом самостоятельно**.


Шаблоны в C++ — это очень полезная технология, но я рекомендую использовать её только в ограниченных случаях, как показано здесь, и не увлекаться. Начав с простых шаблонов для создания контейнеров, можно слишком глубоко погрузиться в мир шаблонов, и вы не заметите, как оперируете шаблонами шаблонов шаблонов, а ваши сообщения об ошибках уже не умещаются на одном текстовом экране.

> **[Далее мы будем работать с шаблонными классами](https://en.cppreference.com/w/cpp/language/class_template)**
