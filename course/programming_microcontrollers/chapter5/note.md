# Курс: Программирование микроконтроллеров
# Практическое занятие №5. "Память"




Микроконтроллер (также известный как MCU) представляет собой интегральную схему (ИС), обычно используемую для выполнения определенных приложений или задач. Обычно этот тип ИС собирает информацию или данные из своего окружения, обрабатывает их и генерирует конкретные выходные данные в соответствии с собранными данными. Микроконтроллеры сегодня повсюду; они являются неотъемлемой частью современных встраиваемых систем, которые можно встретить практически повсюду в нашем мире: от умных часов до электромобилей; они сейчас даже находятся на поверхности Марса.

Одной из важнейших частей микроконтроллера является его память; Память временно или постоянно хранит информацию в микроконтроллерах и может использоваться для нескольких целей. На данном практическом занятии мы рассмотрим организацию памяти в микроконтроллерах, уделив особое внимание тем, которые присутствуют в платах Arduino®. Мы также рассмотрим несколько способов управления, измерения и оптимизации использования памяти в системах на базе Arduino.

# Что такое Память?

Блоки памяти представляют собой неотъемлемый компонент современных встроенных систем, особенно на основе микроконтроллеров. **Эти блоки, являющиеся полупроводниковыми устройствами, предназначены для хранения и извлечения информации или данных**. Центральный процессор (ЦП) микроконтроллера использует и обрабатывает данные, содержащиеся в блоках памяти, для выполнения конкретных задач.

На схеме ниже блоки памяти в микроконтроллерах обычно представлены в виде **массивов**. Эти массивы разделены на **ячейки**, предназначенные для хранения данных, и доступ к которым осуществляется посредством уникального идентификатора, представляющего собой **адрес** или положение относительно массива памяти. Информация в ячейках памяти хранится в двоичной форме (битах), обычно организованных в байтах (8 бит); ее также можно получить позднее с использованием микроконтроллера или других компонентов системы на базе микроконтроллера.

Память в вычислительных системах может быть **энергозависимой** или **энергонезависимой**. Энергозависимая память представляет собой **временную память**, где данные сохраняются во время работы системы, но утрачиваются при выключении. Энергонезависимая память является **постоянной**, и данные в ней сохраняются даже при отключении системы.

# Архитектура памяти 

Компьютерная архитектура является обширной областью, но мы сфокусируемся на ключевых аспектах, чтобы понять, как организована память в микроконтроллерах, применяемых в платах Arduino®.

## **Архитектура фон Неймана**

Архитектура фон Неймана, также известная как архитектура Принстона, была представлена Джоном фон Нейманом в середине 40-х годов. В этой архитектуре программные данные и инструкции хранятся в одном блоке памяти. Оба процессора имеют доступ через одну коммуникационную шину, как показано ниже. Эта архитектура играет фундаментальную роль, поскольку на ее основе построены практически все цифровые компьютеры.

![image][images/von_neumann.png]

_Доступ к обоим процессорам через одну коммуникационную шину._

Она также известен как ISA (архитектура набора команд) и включает в себя три основных блока:

1. **Центральный процессор (ЦП):** Центральный процессор представляет собой электрическую цепь, предназначенную для выполнения инструкций компьютерной программы. Он состоит из следующих ключевых компонентов:
    
    - **Блок управления (БУ):** Отвечает за обработку всех сигналов управления процессором. Блок управления направляет поток ввода-вывода, извлекает код инструкций и контролирует передачу данных в системе.
    - **Арифметико-логический блок (АЛУ):** Часть ЦП, выполняющая все вычислительные операции, которые могут потребоваться для сложения, вычитания, сравнения и выполнения логических операций, операций сдвига битов и арифметических операций.
    - **Разнообразие регистров:** Включает в себя различные регистры, используемые для хранения временных данных и промежуточных результатов.
2. **Блок основной памяти:** Блок основной памяти служит для хранения данных и инструкций, необходимых для выполнения программ. Это ключевой элемент, обеспечивающий доступ ЦП к необходимой информации.
    
3. **Устройство ввода/вывода:** Устройство ввода/вывода обеспечивает взаимодействие между компьютером и внешними устройствами. Оно обрабатывает ввод и вывод данных, обеспечивая коммуникацию между системой и внешним окружением.


![image][images/vn_cpu.png]

### **Регистры:**

Регистры представляют собой высокоскоростные области хранения в центральном процессоре (ЦП), из которых извлекаются данные, обрабатываемые процессором. Различаются следующие типы регистров:

1. **Аккумулятор:** Хранит результаты вычислений, выполняемых арифметико-логическим блоком (АЛУ). Служит промежуточным звеном между арифметическими и логическими операциями, предоставляя временное хранение данных.
    
2. **Счетчик программ (ПК):** Отслеживает местоположение в памяти следующих инструкций, которые требуется обработать. ПК передает следующий адрес в регистр адреса памяти (MAR).
    
3. **Регистр адреса памяти (MAR):** Хранит адреса ячеек памяти, содержащих инструкции, которые необходимо извлечь или сохранить.
    
4. **Регистр данных памяти (MDR):** Содержит инструкции, извлеченные из памяти, или данные, которые должны быть переданы в память и сохранены.
    
5. **Регистр текущих инструкций (CIR):** Содержит последние полученные инструкции, ожидающие кодирования и выполнения.
    
6. **Регистр буфера инструкций (IBR):** Инструкции, которые не требуется выполнять немедленно, помещаются в регистр буфера инструкций IBR.
    

### **Шины:**

Шины представляют собой средства передачи данных между различными компонентами компьютера, соединяя основные внутренние компоненты с процессором и памятью. Различают следующие типы шин:

1. **Шина данных:** Передает данные между блоком памяти, устройствами ввода-вывода и процессором.
    
2. **Адресная шина:** Передает адреса данных (а не сами данные) между памятью и процессором.
    
3. **Шина управления:** Передает команды управления от ЦП для координации действий внутри компьютера.
    

Von Neumann bottleneck: одна и та же _шина памяти_ используется для передачи инструкций и данных.

Типичный шаг исполнения программы:

- fetch — из памяти приносим следующую инструкцию;
- decode — определяем, как она будет исполняться;
- execute — исполнение:
    - производим вычисления и обновляем операнды;
    - обновляем instruction pointer.

```
   ┌───────────────┐
   │               │
   │               │             ┌─────────────┐
...│               │             │     IP      │
   ├───────────────┤             │             │
247│ add x, 1      │◄──────┐     │             │
   ├───────────────┤       └─────┤     247     │
248│ jmp 247       │             └─────────────┘
   ├───────────────┤
249│               │
   ├───────────────┤
250│               │
   ├───────────────┤
...│               │
   │               │
   │               │
   │               │
   └───────────────┘

```

### **Устройства ввода/вывода:**

Устройства ввода/вывода обеспечивают взаимодействие между компьютером и внешними устройствами. Они обрабатывают ввод и вывод данных, позволяя взаимодействовать с внешним окружением.

### **Cлабое место фон Неймана:**

Cлабое место архитектуры фон Неймана характеризуется тем, что инструкции могут выполняться только последовательно, что ограничивает производительность ЦП. Даже с увеличением объема кэш-памяти, оперативной памяти или увеличением скорости компонентов, узкое место фон Неймана может сдерживать общую производительность ЦП. Оптимизация конфигурации ЦП является необходимым условием для повышения производительности.

## **Гарвардская архитектура**

Гарвардская архитектура, получившая название от релейного компьютера Harvard Mark I, была представлена также в середине 40-х годов. Ее особенность заключается в использовании двух отдельных блоков памяти: один для программных инструкций и другой для программных данных. Доступ к этим блокам в гарвардской архитектуре осуществляется ЦП по разным коммуникационным шинам.

![image][images/harvard.png]

### Шины

 В гарвардской архитектуре существуют отдельные шины для инструкций и данных. Типы шин:

**Шина данных**: она передает данные между основной системой памяти, процессором и устройствами ввода-вывода.
**Шина адреса данных**: передает адрес данных от процессора к основной системе памяти.
**Шина инструкций**: она передает инструкции между основной системой памяти, процессором и устройствами ввода-вывода.
**Шина адреса инструкций**: передает адрес инструкций от процессора к основной системе памяти.
### Операционные регистры

В нем задействованы разные типы регистров, которые используются для хранения адресов различных типов инструкций. Например, регистр адреса памяти и регистр данных памяти являются операционными регистрами.

1. **Счетчик программ**: содержит местоположение следующей инструкции, которая будет выполнена. Затем счетчик программ передает следующий адрес в регистр адреса памяти.
2. **Арифметико-логический блок**: Арифметико-логический блок является частью ЦП, который выполняет все необходимые вычисления. Он выполняет сложение, вычитание, сравнение, логические операции, операции сдвига битов и различные арифметические операции.
3. **Блок управления**: Блок управления — это часть ЦП, которая управляет всеми сигналами управления процессором. Он управляет устройствами ввода и вывода, а также контролирует перемещение инструкций и данных внутри системы.
4. **Система ввода/вывода**: устройства ввода используются для считывания данных в основную память с помощью инструкций ввода ЦП. Информация с компьютера в виде вывода передается через устройства вывода. Компьютер выдает результаты вычислений с помощью устройств вывода.
### **Features**:

1. **Отдельные пространства памяти**. В гарвардской архитектуре существуют отдельные пространства памяти для инструкций и данных. Такое разделение гарантирует, что процессор может одновременно получать доступ как к памяти инструкций, так и к памяти данных, что обеспечивает более быстрый и эффективный поиск данных.
2. **Фиксированная длина инструкций**. В гарвардской архитектуре инструкции обычно имеют фиксированную длину, что упрощает процесс выборки инструкций и обеспечивает более быструю обработку инструкций.
3. **Параллельный доступ к инструкциям и данным**. Поскольку Гарвардская архитектура разделяет пространства памяти для инструкций и данных, процессор может получать доступ к обоим пространствам памяти одновременно, что позволяет выполнять параллельную обработку инструкций и данных.
4. **Более эффективное использование памяти**: Гарвардская архитектура позволяет более эффективно использовать память, поскольку память данных и инструкций можно оптимизировать независимо, что может привести к повышению производительности.
5. **Подходит для встроенных систем**: Гарвардская архитектура обычно используется во встроенных системах, поскольку она обеспечивает быстрый и эффективный доступ как к инструкциям, так и к данным, что имеет решающее значение в приложениях реального времени.
6. **Ограниченная гибкость**: отдельные пространства памяти в гарвардской архитектуре ограничивают гибкость процессора при выполнении определенных задач, таких как изменение инструкций во время выполнения. Это связано с тем, что для изменения инструкций требуется доступ к памяти инструкций, которая отделена от памяти данных.

### Преимущество Гарвардской архитектуры:

Гарвардская архитектура имеет две отдельные шины для инструкций и данных. Следовательно, ЦП может одновременно получать доступ к инструкциям и читать/записывать данные. Это главное преимущество Гарвардской архитектуры.

На практике используется модифицированная Гарвардская архитектура, где у нас есть два отдельных кеша (данных и инструкций). Это распространено и используется в процессорах **X86** и **ARM**.

1. **Быстрый и эффективный доступ к данным**. Поскольку гарвардская архитектура имеет отдельные области памяти для инструкций и данных, она обеспечивает параллельный и одновременный доступ к обоим областям памяти, что приводит к более быстрому и эффективному доступу к данным.
2. **Повышение производительности**. Использование фиксированной длины инструкций, параллельной обработки и оптимизированного использования памяти в гарвардской архитектуре может привести к повышению производительности и более быстрому выполнению инструкций.
3. **Подходит для приложений реального времени**: Гарвардская архитектура обычно используется во встроенных системах и других приложениях реального времени, где скорость и эффективность имеют решающее значение.
4. **Безопасность**. Разделение областей памяти инструкций и данных также может обеспечить определенную степень защиты от определенных типов атак, таких как атаки на переполнение буфера.
### Недостатки Гарвардской архитектуры:

1. **Сложность**. Использование отдельных пространств памяти для инструкций и данных в гарвардской архитектуре усложняет конструкцию процессора и может увеличить стоимость производства.
2. **Ограниченная гибкость**: Гарвардская архитектура обладает ограниченной гибкостью с точки зрения изменения инструкций во время выполнения, поскольку инструкции и данные хранятся в отдельных областях памяти. Это может затруднить или сделать невозможным реализацию некоторых типов программирования.
3. **Более высокие требования к памяти**: Гарвардская архитектура требует больше памяти, чем архитектура фон Неймана, что может привести к более высоким затратам и энергопотреблению.
4. **Ограничения размера кода**. Фиксированная длина инструкции в Гарвардской архитектуре может ограничивать размер кода.

## Сравнение

**1. Разделение пространства памяти:**

- _Гарвардская архитектура:_ Имеет отдельные пространства памяти для инструкций и данных, что обеспечивает параллельный доступ и повышает эффективность.
- _Архитектура фон Неймана:_ Использует общее пространство памяти для хранения как инструкций, так и данных, что может привести к конфликтам при одновременном доступе.

**2. Шины:**

- _Гарвардская архитектура:_ Имеет отдельные шины для инструкций и данных, что позволяет одновременный доступ к ним.
- _Архитектура фон Неймана:_ Использует общую шину для передачи как инструкций, так и данных, что ограничивает параллельный доступ.

**3. Параллельный доступ:**

- _Гарвардская архитектура:_ Позволяет параллельный доступ к инструкциям и данным, улучшая общую производительность.
- _Архитектура фон Неймана:_ Ограничивает параллельный доступ, поскольку обе категории используют общую шину.

**4. Гибкость:**

- _Гарвардская архитектура:_ Ограничивает гибкость при изменении инструкций во время выполнения из-за разделения пространств памяти.
- _Архитектура фон Неймана:_ Более гибкая в изменении инструкций в процессе выполнения, так как они хранятся в общей памяти.

**5. Эффективность использования памяти:**

- _Гарвардская архитектура:_ Позволяет оптимизировать использование памяти независимо для инструкций и данных, что может улучшить производительность.
- _Архитектура фон Неймана:_ Имеет ограниченные возможности оптимизации, так как инструкции и данные используют общую память.

**6. Применимость:**

- _Гарвардская архитектура:_ Часто используется во встроенных системах и приложениях реального времени, где важны быстродействие и эффективность.
- _Архитектура фон Неймана:_ Широко применяется в общих вычислительных устройствах, но может быть менее эффективной в некоторых встроенных системах.

**7. Безопасность:**

- _Гарвардская архитектура:_ Разделение пространств памяти может предоставить некоторую степень защиты от определенных видов атак.
- _Архитектура фон Неймана:_ Может быть менее защищенной из-за общего пространства памяти для инструкций и данных.

**8. Сложность:**

- _Гарвардская архитектура:_ Обычно более сложна в реализации из-за отдельных шин и пространств памяти.
- _Архитектура фон Неймана:_ Более проста в конструкции из-за общего пространства памяти и шины.

**9. Требования к памяти:**

- _Гарвардская архитектура:_ Обычно требует больше памяти, что может привести к более высоким затратам и энергопотреблению.
- _Архитектура фон Неймана:_ Обычно более экономична по требованиям к памяти.

**10. Использование в современных системах:** - _Гарвардская архитектура:_ Используется в некоторых встроенных системах и процессорах, таких как ARM и AVR. - _Архитектура фон Неймана:_ Применяется в общих вычислительных устройствах, включая большинство персональных компьютеров.

## Современные архитектуры
Современные вычислительные системы используют модели гибридной архитектуры, которые максимизируют производительность, используя лучшее из обоих миров: модели фон Неймана и Гарвардской модели.

Микроконтроллеры обычно используются во встроенных приложениях. Они должны выполнять определенные задачи надежно и эффективно, используя низкие или ограниченные ресурсы; Вот почему в микроконтроллерах в основном используется модель Гарвардской архитектуры: микроконтроллеры имеют небольшую память программ и данных, доступ к которым должен осуществляться одновременно. Однако в микроконтроллерах не всегда используется Гарвардская архитектура; некоторые семейства микроконтроллеров используют модели гибридной архитектуры или архитектуры фон Неймана.


# Типы памяти
Все различные блоки памяти внутри микроконтроллера можно разделить на два основных типа: ОЗУ и ПЗУ. ОЗУ (из оперативной памяти) в системах на базе микроконтроллеров представляет собой энергозависимую память, используемую для хранения временных данных, таких как переменные прошивки системы. ПЗУ (из постоянного запоминающего устройства) в системах на базе микроконтроллера — это энергонезависимая память, используемая для хранения постоянных данных, таких как встроенное ПО системы.

ОЗУ и ПЗУ в системах на базе микроконтроллеров разделены на три основные категории:

- Flash
- RAM
- EEPROM
## FLASH
**Твёрдотельная полупроводниковая энергонезависимая перезаписываемая память (FLASH)** в системах на базе микроконтроллера является частью его ПЗУ. Флэш-память — это место, где хранится встроенное ПО системы, предназначенное для выполнения. Например, вспомните знаменитый скетч Blink.ino: когда мы компилируем этот скетч, мы создаем двоичный файл, который позже сохраняется во флэш-памяти платы Arduino. Затем эскиз выполняется при включении платы.

## RAM
**Запоминающее устройство с произвольным доступом**  (**Random-access memory** (**RAM**) **ОЗУ** в системах на базе микроконтроллера — это место, где хранятся временные данные системы или данные времени выполнения; например, переменные, созданные функциями программы. Оперативная память в микроконтроллерах обычно представляет собой SRAM; это тип оперативной памяти, в которой для хранения одного бита данных используется триггер. Существует также другой тип оперативной памяти, который можно найти в микроконтроллерах: DRAM.

##  **EEPROM**
В системах на базе микроконтроллера **стираемое программируемое постоянное запоминающее устройство или EEPROM (Electrically Erasable Programmable Read-Only Memory)** также является частью его ПЗУ; на самом деле флэш-память — это разновидность EEPROM. Основное различие между флэш-памятью и EEPROM заключается в способе управления ими; EEPROM может управляться на уровне байтов (запись или стирание), тогда как Flash можно управлять на уровне блоков.

# Arduino 

Как указывалось ранее, платы Arduino® в основном основаны на двух семействах микроконтроллеров: AVR® и ARM®; важно знать, что распределение памяти различается в обеих архитектурах. В Гарвардской архитектуре AVR память организована так, как показано на рисунке ниже:

![image][images/Arduino_memeory.png]

В отношении плат Arduino на базе AVR важно отметить, как их SRAM организована в различные разделы:

- `Text`
- `Data`
- `BSS`
- `Stack`
- `Heap`

Раздел `Text` содержит инструкции, загруженные во флэш-память; Раздел `data` содержит переменные, инициализированные в скетче, раздел `BSS` содержит неинициализированные данные, раздел `stack` хранит данные функций и прерываний, а раздел `heap` хранит переменные, созданные во время выполнения.

В гибридных архитектурах ARM реализована так называемая **карта памяти** с различной конфигурацией карты адресов: 32-битной, 36-битной и 40-битной, которая зависит от требований адресного пространства системы на кристалле (SoC) с дополнительным DRAM. . Карта памяти обеспечивает интерфейс с дизайном SoC, сохраняя при этом большую часть управления системой на высоком уровне кодирования. Инструкции доступа к памяти могут использоваться в коде высокого уровня для управления модулями прерываний и встроенными периферийными устройствами. Все это контролируется **блоком управления памятью** (MMU).

Ресурс памяти обрабатывается MMU. Основная роль MMU заключается в том, чтобы позволить процессору независимо выполнять несколько задач в его собственном пространстве виртуальной памяти; Затем MMU использует таблицы трансляции для установления моста между адресами виртуальной и физической памяти. Виртуальный адрес управляется с помощью программного обеспечения с инструкциями памяти, а физический адрес — это система памяти, которая управляется в зависимости от входных данных таблицы трансляции, заданных виртуальным адресом.

Пример того, как организована память в микроконтроллерах на базе ARM виртуально и физически, показан на изображении ниже:

![image][images/arm_memory.png]

Память микроконтроллера на базе ARM организована в следующие разделы в пределах упомянутого ранее типа адреса:

- Виртуальный адрес:
	1. Код ядра и данные
	2. Код и данные приложения
- Физический адрес:
	1. ROM 
	2. RAM
	3. Flash
	4. Перефирия

# Измерения памяти
## Измерение флэш-памяти

Флэш-память на платах Arduino® можно измерить с помощью Arduino IDE. Как говорилось ранее, во флэш-памяти хранится код приложения; Arduino IDE сообщает об использовании флэш-памяти через консоль вывода компилятора, чтобы разработчики знали, сколько ресурсов флэш-памяти используется.

Например, на изображении ниже показан вывод компилятора IDE для платы Arduino® на базе AVR, Nano:

![image][images/avr_nano.png]

Журнал вывода консоли компилятора IDE для платы Arduino® на базе ARM, MKR WAN 1310, показан на изображении ниже:

![image][images/arm_mkrwan1310.png]

Журнал вывода консоли компилятора IDE для другого Arduino® на базе ARM, Portenta H7, показан на изображении ниже:

![image][images/arm_portentah7.png]

Обратите внимание, что выходные данные компилятора меняются в зависимости от того, основана ли плата на AVR или на ARM.

## Измерение памяти SRAM

Иногда возникают ситуации, когда даже когда код успешно компилируется и загружается в плату IDE, он внезапно зависает. Эти проблемы, вероятно, связаны с перегрузкой ресурсов памяти или недостатком памяти для выделения. Для решения этой проблемы необходимо понять, в каком секторе кода потребность в памяти превышает доступные ресурсы. Следующий пример кода можно использовать для измерения использования SRAM в платах Arduino® на базе AVR:

```c++
void display_freeram() {
  Serial.print(F("- SRAM left: "));
  Serial.println(freeRam());
}

int freeRam() {
  extern int __heap_start,*__brkval;
  int v;
  return (int)&v - (__brkval == 0  
    ? (int)&__heap_start : (int) __brkval);  
}
```

Помните, что в разделе `heap` хранятся переменные, созданные во время выполнения. В коде `__heap_start `и `__brkval` выглядят следующим образом:

- `__heap_start`: начало раздела `heap`.
- `__brkval`: последний указатель адреса памяти, используемый `heap`.

Следующий пример кода можно использовать для измерения использования SRAM в платах Arduino® на базе ARM:

```c++
extern "C" char* sbrk(int incr);

void display_freeram(){
  Serial.print(F("- SRAM left: "));
  Serial.println(freeRam());
}

int freeRam() {
  char top;
  return &top - reinterpret_cast<char*>(sbrk(0));
}
```

## Измерение памяти EEPROM

Управление памятью EEPROM можно легко выполнить с помощью встроенных библиотек, уже установленных в Arduino IDE. Библиотеку EEPROM можно использовать для чтения, записи и стирания памяти EEPROM. Следующий код показывает, как байт информации может быть сохранен в памяти EEPROM, а затем прочитан с помощью функций записи и чтения:

```c++
#include <EEPROM.h>

void setup() {
}

void loop {
  // Write data into an specific address of the EEPROM memory 
  EEPROM.write(address, value);

  // Read data of an specific address of the EEPROM memory 
  EEPROM.read(address);
}
```

Кроме того, можно очистить всю память EEPROM, установив для нее значение 0, как показано в коде ниже:

```c++
#include <EEPROM.h>

void setup() {
}

void loop {
  for (int i = 0 ; i < EEPROM.length() ; i++) {
    // Clear EEPROM memory 
    EEPROM.write(i, 0);

}
```


# Оптимизация использования памяти в системах на базе Arduino

Знание того, как код использует ресурсы памяти системы, — это лишь первая рекомендуемая задача в процессе разработки; совершенно другая задача — оптимизация использования памяти. Как следует из термина «разработка», требования могут меняться или корректироваться в зависимости от внешних факторов, таких как снижение мощности устройства из-за недоступности компонентов. Таким образом, архитектура кода может потребовать оптимизации для работы с ограниченными ресурсами памяти.

Процесс оптимизации использования памяти также подразумевает снижение вычислительной сложности, сокращение дополнительного времени, необходимого для обработки задач, при одновременном использовании меньшего количества ресурсов памяти для выполнения тех же задач. Процесс оптимизации использования памяти может помочь общему процессу оптимизации кода, поскольку он будет более эффективно управлять памятью, требуя разработки интеллектуальных алгоритмов.

## Оптимизация Flash памяти

Оптимизация **Flash** памяти является наиболее простым возможным источником оптимизации. **Flash** память — это место, в котором емкость, используемая скомпилированным кодом, можно значительно уменьшить, приняв во внимание некоторые детали.

### Отсоединить неиспользуемые источники

Отсоединение новых источников включает в себя **неиспользуемые библиотеки** и **остатки кода**. Остатки кода могут состоять из больше не используемых функций и плавающих переменных, которые занимают ненужное место в памяти. Это значительно улучшит размер скомпилированного кода и сделает процесс компиляции более понятным.

### Модульные задачи

**Модульные задачи** означают функции, которые оборачивают код, который будет использоваться повторно или постоянно, получая разные параметры. Это отличный способ сохранить чистую структуру кода и производительность, одновременно уменьшая объем памяти, необходимый для дополнительных задач, которые, возможно, потребуется реализовать.

Это приводит к компактной структуре кода, которую гораздо легче понять, когда требуется отладка, и которая требует от разработчика учитывать вычислительную сложность при разработке структуры кода или такого конкретного алгоритма.

## Оптимизация памяти SRAM

Память **SRAM**, вероятно, является наиболее важной единицей памяти в системе на базе микроконтроллера; оптимизация использования SRAM необходима для разработки надежных систем на базе микроконтроллеров. Нехватка SRAM обычно является наиболее распространенной проблемой памяти; Оптимизация SRAM может помочь уменьшить проблемы такого типа.

Идеальный способ использования команды «Print Line» — использовать строковую обертку F() вокруг литералов. См. пример ниже:

### String Wrapper

Инструкции `Serial.print()` или `Serial.println()` используют пространство SRAM, что может быть удобно, но нежелательно. Идеальный способ использования инструкций `Serial.print()` или `Serial.println()` — использование строковой оболочки `F()` вокруг литералов. Например:
```c++
Serial.println(F("Something"));
```

Обертывание строки с помощью оболочки` F()` приведет к перемещению строк только во флэш-память, а не к использованию пространства **SRAM**. Использование оболочки `F()` можно рассматривать как выгрузку таких данных во флэш-память вместо SRAM. Флэш-память гораздо более просторна, чем SRAM, поэтому лучше использовать флэш-память, чем SRAM, которая будет использовать раздел кучи. Это не означает, что объем памяти всегда будет доступен, поскольку объем флэш-памяти ограничен. Не рекомендуется засорять код инструкциями `Serial.print()` или `Serial.println()`, но используйте их там, где они наиболее важны внутри кода.

### PROGMEM

Не только строки занимают пространство SRAM, но и глобальные переменные также занимают довольно много места в SRAM. Поскольку глобальные и статические переменные передаются в пространство SRAM и помещают раздел `heap` памяти в `stack`. Пространство, занимаемое этими переменными, передаваемыми в пространство SRAM, будет сохранено в их местоположении и не будет меняться, что означает, что создается больше этих переменных, они будут использовать больше места и, следовательно, в системе возникают проблемы и проблемы из-за плохого управления памятью. .

**PROGMEM**, что означает «**Память программ**», может использоваться для хранения переменных данных во флэш-памяти, как и описанная ранее оболочка `F()`, но использование **PROGMEM** имеет один недостаток: скорость чтения данных. Использование ОЗУ обеспечит гораздо более высокую скорость чтения данных, но **PROGMEM**, поскольку он использует флэш-память, будет медленнее, чем ОЗУ, при том же размере данных. Таким образом, при разработке кода важно знать, какие переменные имеют решающее значение, а какие нет или имеют более низкий приоритет.

Использование `PROGMEM` в плате Arduino® на базе AVR показано в примере кода ниже:

```c++
#include <avr/pgmspace.h>

// Basic PROGMEM structure 
const PROGMEM DataType Variable_Name[] = {var0, var1, var2 ...};

// Storing an unsigned, 16-bit, integer
const PROGMEM uint16_t NumSet[] = {0, 1, 1, 2, 3, 5, 8 ...};

// Storing a char in PROGMEM
const char greetMessage[] PROGMEM = {"Something"};
```

Использование различается на разных уровнях, которые суммируются следующим образом:

- Уровень пространства имен

	- На уровне пространства имен мы указываем на переменные, и не важно, объявлена ли статика или нет. Если она объявлена, это означает, что переменная является явно статической; с другой стороны, это неявное статическое объявление.
-  Функциональный уровень

	- Если он объявлен внутри static, любой тип применимых данных, которыми нужно управлять, будет находиться между вызовами функций.
- Уровень класса
	- На уровне класса статическое объявление будет означать, что любой тип применимых данных, которые обрабатываются, будет совместно использоваться между экземплярами.

### Нединамическое распределение памяти

Динамическое распределение памяти обычно является подходящим методом, если размер оперативной памяти системы достаточно велик, чтобы его можно было обойти; однако для систем на базе микроконтроллера, таких как встроенные системы, подсчет каждого байта ОЗУ не рекомендуется.

Динамическое распределение памяти приводит к  **фрагментации кучи**. При фрагментации кучи многие области оперативной памяти, затронутые ею, не могут быть повторно использованы повторно, в результате чего остаются мертвые байты, которые можно использовать в качестве преимущества для других задач. Кроме того, когда при динамическом выделении памяти происходит освобождение памяти для освобождения пространства, это не обязательно уменьшает размер кучи. Поэтому, чтобы максимально избежать фрагментации кучи или оперативной памяти, можно следовать следующим правилам:

- **Расставьте приоритеты в использовании стека, а не кучи**:
	- Память `stack` не имеет фрагментации и может быть полностью освобождена при возврате функции. `Heap`, напротив, не может освободить пространство, даже если ей было дано указание сделать это. Сделать это поможет использование локальных переменных и старайтесь не использовать динамическое выделение памяти, состоящее из разных вызовов: `malloc`, `calloc`, `realloc`.
- Сокращенные глобальные и статические данные (если возможно):
	- Пока код выполняется, область памяти, занятая этими данными, не будет освобождена. Данные не будут изменены, поскольку постоянные данные занимают драгоценное пространство.
- Используйте короткие строки/литералы:
	- Хорошо, если строки/литералы будут как можно короче. Один символ занимает один байт ОЗУ, поэтому чем короче, тем лучше используется пространство памяти. Это не означает, что его можно сделать коротким и использовать в нескольких различных областях кода. Используйте его при необходимости и делайте его как можно короче, чтобы освободить место в оперативной памяти для других задач.
	- **Массивы** также рекомендуется иметь минимальный размер. Если требуется изменить размер массива, вы всегда можете повторно установить размер массива в коде. Это может быть утомительный и неэффективный метод жесткого кодирования размеров массива. Однако, если в коде используются массивы небольшого размера и менее трех массивов, может быть достаточно изменить размер вручную, зная требования. Разумный способ сделать это — массив изменяемого размера с ограниченным размером. Задачи будут использовать массив, не выходя за границу размера. Таким образом, он подходит для обширного кода. Однако предел размера массива должен быть проанализирован и сохранен как можно меньшим.
### Резервная функция

В задачах кода, работающих со строками, размер которых меняется в зависимости от результата операции, лучше всего использовать `Reserve()`. Эта функция поможет **зарезервировать буферное пространство и предварительно выделить его для строковой переменной**, изменив ее размер и избежав фрагментации памяти. Переменная `String`, размер которой изменяется, может возникнуть, например, в результате использования переменной типа `int`, которая будет использоваться как `String`.

Следующий код показывает, как использовать инструкцию `reserve()`:

```c++
// String_Variable is an String type variable
// Alloc_Size is the memory to be pre-allocated in number of Bytes with unsigned int type
String_Variable.reserve(Alloc_Size);
```

### Контроль размера буфера

Внутренним процессам также требуется пул памяти для целей обработки. Это то, над чем система будет работать в соответствии с размером определенного пула памяти. Этот размер буфера может быть определен пользователем и может быть уменьшен для выделения меньшего размера памяти. Подумайте об определении размера переменной массива, в котором важно не выделять чрезмерный размер, когда он использует только третью часть определенного размера.

Давайте обсудим пример: последовательная связь в Arduino. Последовательная связь — это регулярно используемый сервис в системах на базе Arduino; Последовательная связь в Arduino работает с использованием предустановленной библиотеки Serial (внешние библиотеки также могут эмулировать последовательную связь с помощью программного обеспечения). Между серверными службами последовательная связь определяет необходимый пул памяти как буфер определенного размера. Если высокоскоростная последовательная связь не является частью требований, размер последовательного буфера можно переопределить, чтобы сэкономить некоторое потребление памяти. Это можно легко сделать, изменив следующую строку кода в файле HardwareSerial.h, который можно найти в папке установки Arduino IDE:

```c++
#define SERIAL_TX_BUFFER_SIZE 64
#define SERIAL_RX_BUFFER_SIZE 64
```


### Корректирующее использование типов данных

Реализация соответствующего типа данных приводит к хорошей общей архитектуре кода. Разработчикам может быть желательно использовать самый простой или наиболее доступный тип данных для обработки данных в коде. Однако важно учитывать объем памяти, который он занимает при использовании определенных типов данных.

Типы данных существуют для упрощения формата потока данных и для обработки без несанкционированного доступа. Под незаконным доступом с точки зрения типов данных подразумевается обработка данных в коде несовместимого формата. Поэтому рекомендуется не злоупотреблять типом данных и использовать только удобные типы для каждого бита данных. Вместо этого тщательно проектируйте и распределяйте память в соответствии с требованиями, что поможет зарезервировать некоторое пространство памяти, если для дальнейших задач потребуется дополнительное пространство.

В следующей таблице показаны основные типы данных значений в Arduino:

|          **Type**           | **Byte Length** |       **Range of Values**       |
|:---------------------------:|:---------------:|:-------------------------------:|
|    ```boolean```    |        1        | Limited to logic true and false |
|     ```char```      |        1        |           -128 to 127           |
| ```unsigned char``` |        1        |            0 to 255             |
|     ```byte```      |        1        |            0 to 255             |
|      ```int```      |        2        |        -32,768 to 32,767        |
| ```unsigned int```  |        2        |           0 to 65,535           |
|     ```word```      |        2        |           0 to 65,535           |
|     ```long```      |        4        | -2,147,483,648 to 2,147,483,647 |
| ```unsigned long``` |        4        |       0 to 4,294,967,295        |
|     ```float```     |        4        | -3.4028235E+38 to 3.4028235E+38 |
|    ```double```     |        4        | -3.4028235E+38 to 3.4028235E+38 |


# Обращения к памяти

Сохранить значение регистра eax по адресу 0x40100, а потом загрузить обратно в регистр ebx:

```c
mov %eax, 0x40100     mov 0x40100, %ebx
```
(При этом мы используем 4 байта по адресам 0x40100, 0x40101, 0x40102, 0x40103.)

Положить в память по адресу 0x40100 целое число 0x1543:

```c
movl $0x1543, 0x40100
```

Как правило, мы используем в качестве адресов метки:

```c
.global main main:     mov x, %eax     call writei32     call finish x:  .int 43
```

Не любой адрес в памяти доступен для чтения и тем более записи:

```c
.global main main:     incl x     call finish x:  .int 43
```
При попытке исполнения инструкции `incl` операционная система остановит программу с сообщением «Segmentation fault», поскольку эти данные нельзя менять.

## Секции .data и .bss
Любые байты, порождаемые ассемблером, записываются в одну из _секций_ исполняемого файла. По умолчанию это секция `.text`, в которой ожидается машинный код и которая недоступна для записи.

Данные можно положить в секцию `.data`:

```c
incl x     .data x:  .int 43     .text     call finish
```
Обратите внимание, что ассемблер собирает вместе содержимое каждой из секций: в примере выше инструкция `call` окажется в памяти (и в исполняемом файле) сразу после `incl`.

Есть также секция .bss, в которую можно положить только нулевые байты:
```c
.bss z:  .int 0     .int 0     // .int 83  // would be an error
```

Typical memory layout:

```
           ┌──────────────────┐    Executable file
0x0000_0000│//////////////////│   ┌───────────────┐
           │//////////////////│   │ headers       │
           ├──────────────────┤   ├───────────────┤
           │.text   (read and │   │.text          │
           │         execute) │   │               │
      eip─►│                  │   │               │
           │                  │   │               │
           │                  │   │               │
           ├──────────────────┤   ├───────────────┤
           │.data   (read and │   │.data          │
           │         write)   │   │               │
           ├──────────────────┤   └───────────────┘
           │.bss    (read and │
           │         write)   │
           │                  │
           ├──────────────────┤
           │//////////////////│
           │//////////////////│    /// = unmapped region
           │//////////////////│          (inaccessible memory)
           │//////////////////│
           │//////////////////│
           │//////////////////│
      esp─►│stack             │
           │                  │
           │                  │
           │                  │
           │                  │
           ├──────────────────┤
           │//////////////////│
0xffff_ffff│//////////////////│
           └──────────────────┘

```


Бывают read-only данные (например, тексты сообщений программы), для них есть секция `.rodata`. Эта секция не имеет собственной директивы, поэтому нужно воспользоваться директивой `.section`:

```c
.section .rodata pi_digits:     .byte 3,1,4,1,5,9,2,6
```

(На практике вместо `.rodata` константные данные часто кладут в `.text`.)
## Стек

Writable область памяти, которая используется как стек :-). Стек на x86 растёт _вниз_ (от старших адресов к младшим). На верхушку стека (первый занятый байт) указывает регистр esp.

Скопировать верхушку стека (первые 4 байта) в регистр `eax`:

    `mov (%esp), %eax`

Для того, чтобы класть данные на стек и выталкивать их оттуда, есть специальные инструкции:

    `push %eax  // то же, что sub $4, %esp; mov %eax, (%esp)     pop %eax   // то же, что mov (%esp), %eax; add $4, %esp`

Инструкция `push` одна из немногих, которые могут обратиться к двум адресам памяти сразу:

    `.data x:  .int 1900     .text     pushl x  // взять 4 байта из памяти по адресу x              // и положить их в стек, то есть тоже в память`

Можно пользоваться памятью выше `esp`, если вы знаете, что там что-то есть. Например, если вы положили в стек два 32-битных числа, их можно оттуда читать и там изменять:

    `pushl $6     pushl $7      // теперь стек выглядит так:     //    07 00 00 00  06 00 00 00 ...     //    ↑ esp      mov 4(%esp), %eax  // загрузили в %eax число 6     incl (%esp)        // теперь на верхушке стека лежит число 8`

Память _ниже_ `esp` использовать не следует.

Инструкция `push %esp` кладёт на стек то значение `esp`, которое было до её исполнения (не уменьшенное на 4).
