# Курс: Программирование микроконтроллеров
# Практическое занятие №6. "Чистый Си"

# Программирование Arduino Uno на стандартном C

## Введение
Этот репозиторий предоставляет структуру в [Standard AVR C](http://avr-libc.nongnu.org), которая отражает структуру Arduino. Это позволяет студенту программировать ATmega328P или его эквиваленты, используя **стандартный C** в относительно знакомом (Arduino) контексте. Ценность программирования ATmega328P на языке C заключается в том, что с использованием 8-битного процессора легче понять концепции C по сравнению с программированием на C на ПК. Это также позволяет научиться программировать встроенный микроконтроллер в менее сложной среде по сравнению с 32-битным микроконтроллером, таким как Raspberry Pi Pico.

Чтобы использовать эту платформу, необходимо установить цепочку инструментов *avr-gcc*, соответствующую своей платформе (Linux, macOS или Windows). Инструкции для этого приведены [здесь](https://wellys.com/posts/avr_c_setup/).

Для надежного подхода к отладке в Linux (Linux или WSL) вы можете добавить [Bloom](https://bloom.oscillate.io/) и *avr-gdb*. Bloom обеспечивает графическое отображение регистров и памяти микроконтроллера, а также необходимое соединение чипа с avr-gdb. [gdb](https://www.sourceware.org/gdb/) — простой, но чрезвычайно мощный инструмент отладки. Я считаю, что его проще использовать, чем большинство IDE, таких как Visual Studio, MPLAB IDE и т. д. Дополнительные рекомендации можно найти в [Разработка на C для ATmega328: Настройка Bloom и gdb для аппаратной отладки](https://wellys.com/posts/avr_c_gdb_bloomsetup/ ).

## Шаги использования
1. Установите набор инструментов. [Подробности здесь](https://www.wellys.com/posts/avr_c_setup/)
2. Если вы используете Linux и хотите попробовать аппаратную отладку, рассмотрите возможность [использования Bloom, avr-gdb и отладчика](https://www.wellys.com/posts/avr_c_gdb_bloomsetup/).


## Платы и микроконтроллеры

Этот код был тщательно протестирован с Arduino Uno и [Microchip ATmega328PB Xplained Mini] (https://www.microchip.com/en-us/development-tool/ATMEGA328PB-XMINI). Я предпочитаю последнюю плату для разработки, поскольку она включает в себя аппаратный отладчик на той же плате, который хорошо работает с [Bloom](https://bloom.oscillate.io/) и стоит всего 12 долларов! Если вы хотите приобрести новую плату для работы с этим кодом, я рекомендую плату Microchip.

Если у вас есть Uno, он будет работать очень хорошо. Если вы хотите добавить аппаратную отладку, вам необходимо приобрести устройство, совместимое с debugWIRE, например [Microchip MPLAB Snap] (https://www.microchip.com/en-us/development-tool/PG164100) или [Atmel ICE] (https://www.microchip.com/en-us/development-tool/ATATMEL-ICE).

Другие микроконтроллеры Microchip AVR, скорее всего, будут работать, но у меня нет времени их тестировать. Если процессор не ATmega328P, важно установить переменные MCU и частоты процессора (F_CPU) в Makefile. Конкретную информацию о том, как настроить среду для вашей платы и микроконтроллера, см. в содержимом **Makefile** ниже.
## Arduino Framework и стандартные процедуры замены C
Большая часть стандартной библиотеки C предоставляется [AVR Libc](https://www.nongnu.org/avr-libc/). Я рекомендую держать ссылку на онлайн-руководство открытой во время разработки кода. Код в этом репозитории — это код, необходимый для программирования Uno с использованием тех же процедур, что и в Arduino Framework.
### Функции платформы Arduino

Для использования каждой используемой функции требуется `#include` (пример):
```С
#include "functionname.h" /* формат включения */

#include "analogRead.h" /* например, для использования AnalogRead() */
#include "unolib.h" /* добавьте этот файл для общего определения */
```
Благодаря этому код становится меньше, чем в случае с большим файлом, содержащим все доступные функции.

### Функции платформы Arduino
* **analogRead(pin)**: чтение одного из 6 аналоговых контактов (A0–A5). Возвращает 10-битное значение со ссылкой на AREF, см. [analogReference()](https://www.arduino.cc/reference/en/language/functions/analog-io/analogreference/). В данном случае это только значение ПО УМОЛЧАНИЮ VCC или 5В. Чтобы преобразовать показание в напряжение, умножьте его на 0,0048 (для опорного напряжения 5 В).
* **analogWrite(pin, n)**: настройка таймера/счетчиков для подачи ШИМ-сигнала. Имейте в виду, что ШИМ использует таймер/счетчики, см. это [Примечание к таблице данных AVR: PWM](https://wellys.com/posts/avr_c_step2/), чтобы узнать, какому выводу назначен таймер/счетчики. Такие примеры, как *button* (T/C 2) и *micros* (T/C 1), также используют одни и те же таймеры/счетчики, поэтому конфликт может быть проблемой.
* pin = номер контакта Arduino UNO, в названии должен быть символ «\~» (3, 5, 6, 9, 10, 11)
* n = n/255 Рабочий цикл, т.е.
	* е; n=127, 127/255 \~= рабочий цикл 50 %
	* Частоты ШИМ на выводах
	* UNO контакт 3/PD3, 488,3 Гц
	* UNO контакт 5/PD5, 976,6 Гц
	* UNO контакт 6/PD6, 976,6 Гц
	* UNO контакт 9/PB1, 976,6 Гц
	* UNO контакт 10/PB2, 976,6 Гц
	* UNO контакт 11/PB3, 488,3 Гц
	* 
* **digitalRead(pin)**: возвращает значение (1 или 0) контакта Uno (только контакты 0–13). При использовании последовательного ввода-вывода (printf/puts/getchar) контакты Uno 0 и 1 использовать нельзя. digitalRead() не настроен на использование A0-A5.
* **digitalWrite(pin, level)**: установите для вывода UNO значение HIGH, LOW или TOG (только контакты 0–13). При использовании последовательного ввода-вывода (printf/puts/getchar) контакты Uno 0 и 1 использовать нельзя. В этой версии также добавлен TOG, который переключает уровень. Гораздо проще, чем проверять уровень и устанавливать противоположный уровень, и требует меньше кода. digitalWrite() не настроен на использование A0-A5.
* **pinMode(pin, mode)**: определите INPUT, OUTPUT, INPUT_PULLUP для вывода UNO (только контакты 0–13). Не настроен на использование A0-A5.
* **delay(ms)**: Блокировка задержки использует встроенную функцию \_delay_ms стандарта C, однако позволяет использовать переменную в качестве аргумента.
* **millis()**: возвращает длинное целое число, содержащее текущее количество тактов в миллисекундах. Просмотрите пример миллиса, чтобы понять, как его использовать. millis() использует *sys_clock_2*, который представляет собой системные часы, настроенные с помощью Таймера/Счетчика 2.
### Стандартные функции ввода-вывода C, адаптированные для ATmega328P
Используйте эти стандартные функции ввода-вывода C вместо последовательного класса Arduino. См. пример *serialio* для примера реализации. В файле необходимо следующее:
```C
# in the include section at the top of the file
#include "uart.h"
#include <stdio.h>

# at the top of the main function, prior to using I/O functions
	init_serial();
```

- getChar(char): то же, что и C getChar() (в настоящее время без прерываний)
- printf(строка, переменные): то же, что и C printf(), ограниченная функциональность должна быть документирована. Есть два способа добавить printf, они описаны в Makefile в примерах. Также полезно просмотреть документацию avr-libc printf.
- puts(строка): то же, что и C puts()
### Добавлены функции помимо Arduino Framework.
* **`buttons[i]`** — обеспечивает устранение дребезга кнопок. Каждая кнопка должна быть прикреплена к штифту Uno.
* Требуется *sysclock_2()*, информацию о реализации см. в *examples/button*.
* *`buttons[i].uno`* — это контакты Uno, прикрепленные к кнопке, и, как и в случае с digitalRead, функция преобразует вывод Uno в порт/контакт.
* *`buttons[i].pressed`* указывает, была ли нажата кнопка (истина или ненулевая)
* в зависимости от приложения вам может потребоваться установить *`buttons[i].pressed`* на ноль после успешного нажатия, если вы зависите от второго нажатия для изменения состояния. В противном случае у вас возникнет состояние гонки, при котором одно нажатие считается за два нажатия (это не отскок, это быстрое чтение в конечном автомате).

* **определяемая пользователем кнопка RESET** — поскольку debugWIRE использует вывод \~RESET для связи, полезно определить другой вывод для использования в качестве вывода RESET. Это выполняется с помощью этого [метода](http://avr-libc.nongnu.org/user-manual/FAQ.html#faq_softreset).
Плата ATmega328PB XPLAINED MINI имеет встроенную пользовательскую кнопку на PB7. Процедура сброса устранит дребезг кнопки. Чтобы использовать сброс, процедура требует включения *sysclock.h* и *init_sysclock_2()*. В трёх примерах уже включен *reset*: **button**, **millis и **analogRead**. Дополнительные переменные для установки находятся в *unolib.h*:
```С
#define RESET_BUTTON PB7
#define RESET_MASK 0b11000111
```
Я рекомендую не менять маску, если только у вас не возникнут серьезные проблемы с дребезгом. Контакт кнопки должен быть выражен как контакт на порту B и с номером контакта, как показано.

* **Генерация случайных чисел** — с помощью Mersenne Twister, TinyMT32 можно создавать 32-битные целые числа без знака. Существует две тестовые процедуры: *tinymt*, которые демонстрируют, как их настроить и использовать, а также *rand_test* , который сравнивает время выполнения *tinymt* и *random()*. Похоже, что rand() работает в 4 раза быстрее, чем tinyMT, однако я не проверял «случайность» этих двух процедур.

### Многозадачность
В папке примеров есть шесть примеров многозадачности. Два из них — это сторонний код, который я добавил для рассмотрения в качестве моделей многозадачности. А остальные четыре — это разработка, которую я документирую более подробно [здесь](https://wellys.com/posts/avr_c_step6/)

В двух словах:
* *многофункциональность* — это первая итерация, просто доказательство того, что *"однострочный планировщик"* работает.
* *multi_Ard* использует предыдущий пример кода, который является быстрым и упрощает его с помощью вызовов типа Arduino (pinMode и digitialWrite) для упрощения интеграции.
* *мультимассив* переходит от структуры отдельной функции к общей функции с использованием массива для многозадачности.
* *multi_struct* использует тот же подход, что и предыдущий код, однако использует структуру для обеспечения полностью перекрывающейся многозадачности.

## Источники

Другие источники информации, которые были полезны:
* [AVR Libc](https://www.nongnu.org/avr-libc/)
* [Сообщество AVR Freaks](https://www.avrfreaks.net/)
* [Ардуино в C | Встроенная свобода](https://balau82.wordpress.com/arduino-in-c/)
* [Программирование Arduino на «чистом C»](http://audiodiwhy.blogspot.com/2019/01/programming-arduino-in-pure-c-now-were.html)
* [EMBEDDS: Учебные пособия по AVR](https://embedds.com/avr-tutorials/)
* [CCRMA: AVR](https://ccrma.stanford.edu/wiki/AVR#AVR_Microcontrollers)
* [Руководства по электронике и программированию Efundies: AVR] (https://efundies.com/avr/)
