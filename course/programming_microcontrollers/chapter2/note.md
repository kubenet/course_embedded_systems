# Курс: Программирование микроконтроллеров

## Практическое задание №2. "АЦП, Средства индикации, Интерфейсы связи, Сенсоры"
1.  Введение в АЦП:
    -   Введение в АЦП.
    -   Простая фильтрация
2. Средства индикации:
	-  ШИМ.
	- Сдвиговые регистры.
3.  Интерфейсы связи:
	- UART.
	-   I2C.
    -   SPI.
5.  Работа с различными сенсорами:
    -   Виды сенсоров.
    -   Взаомодействие между двумя платами Arduino.    

> Описание всех команд [Arduino](https://www.arduino.cc/reference/en/)

## Введение в АЦП
![Принцип работы АЦП](https://www.lcard.ru/sites/default/files/styles/termin_style_image/public/TERMINS/adc_termin_0.png?itok=UauFjZLk)
Аналого-цифровой преобразователь (АЦП, Analog-to-digital converter, ADC) — устройство, преобразующее входной аналоговый сигнал в  _цифровой сигнал_  (в цифровой  _двоичный код_). Для задач измерения значения сигнала в произвольный момент времени используют  _асинхронный режим_  работы с АЦП с жестко не привязанными по времени одиночными аналого-цифровыми преобразованиями. Для задач измерения функциональной зависимости изменения аналогового сигнала используют  _синхронный режим_  работы АЦП. Синхронный режим работы АЦП без пропусков данных на сколь угодно большом интервале времени называют также  _потоковым режимом_. Синхронные АЦП, как правило, поддерживают  _покадровый принцип сбора данных_, когда оцифрованные отчёты измерения образуют условные кадры с заданным количеством отсчётов, соответствующих заданным каналам измерения.

АЦП является неотъемлемой частью  [системы сбора данных](https://www.lcard.ru/lexicon/data_acquisition_system).

**Основные параметры АЦП:**

-   Входной _диапазон сигнала ([диапазон измерения](https://www.lcard.ru/lexicon/spec_meas_range))_.
-   _Частота преобразования_ [Гц] – частота следования аналого-цифровых преобразований. В терминологии  [ЦОС](https://www.lcard.ru/lexicon/dig_sig_processing)  частота преобразования АЦП называется частотой дискретизации сигнала в его цифровом представлении.
-   _Период преобразования_ [c] = [1/Гц] – величина, обратная частоте преобразования. В терминологии ЦОС период преобразования АЦП является периодом преобразования сигнала в его цифровом представлении. Для  [асинхронных](https://www.lcard.ru/lexicon/sync_async_io)  АЦП нормируется время преобразования.
-   _[Полоса частот](https://www.lcard.ru/lexicon/freq_band)  пропускания_  АЦП [Гц]…[Гц]. Это диапазон частот сигнала, который пропускает преобразователь по уровню сигнала -3 дБ.
-   _Разрядность АЦП_  – количество N двоичных разрядов преобразователя, при этом количество _уровней квантования_ сигнала в цифровом представлении АЦП равно 2N.
-   _Соотношение сигнал/шум_ канала преобразования АЦП [дБ]
-   Технология АЦП. Типичные представители: _АЦП последовательного приближения, сигма-дельта АЦП_.
-   _Межканальное прохождение_ [дБ].

Верхняя частота полосы частот пропускания _АЦП последовательного приближения_ может быть значительно больше _частоты преобразования АЦП_, а верхняя частота _полосы частот пропускания_ сигма-дельта АЦП не превышает половины частота преобразования АЦП.

АЦП различаются типами входов. Чаще встречаются АЦП с  [входом напряжения](https://www.lcard.ru/lexicon/voltage_input), реже – с  [входом тока](https://www.lcard.ru/lexicon/current_input)  или  [входом заряда](https://www.lcard.ru/lexicon/charge_input).

Многоканальные АЦП строятся по принципу независимых параллельных каналов АЦП или по принципу АЦП с коммутацией каналов.

АЦП с коммутацией каналов разделяются на  [АЦП с входным коммутатором каналов](https://www.lcard.ru/lexicon/d16_se32)  (у которых коммутационный процесс происходит непосредственно в  _измерительной цепи_) и на АЦП с внутренним коммутатором, например, как у  [E20-10](https://www.lcard.ru/products/external/e20-10) (у которых  _коммутационный процесс_  происходит внутри и  _измерительную цепь_  не затрагивает).

Важной характеристикой АЦП является наличие [_гальванической изоляции_](https://www.lcard.ru/lexicon/galvanic_isolation) входной сигнальной цепи. Для АЦП с  _входом напряжения_  важной характеристикой является тип входа напряжения: _[дифференциальный вход](https://www.lcard.ru/lexicon/diff_input),  [вход с общей землёй](https://www.lcard.ru/lexicon/com_gnd_input)_.

По потребительским свойствам все АЦП можно разделить на  _АЦП общего применения_  и  _специализированные АЦП_. Для общего применения больше всего подходят АЦП, имеющие дифференциальные входы напряжения и гальваноразвязку ([LTR11](https://www.lcard.ru/products/ltr/ltr11),  [LTR24-1](https://www.lcard.ru/products/ltr/ltr24)). К специализированным АЦП можно отнести преобразователи, имеющие специальный вход специфического датчика (например, тензометрического – [LTR212](https://www.lcard.ru/products/ltr/ltr212),  [LTR216](https://www.lcard.ru/products/ltr/ltr216), или ICP-датчика – [LTR25](https://www.lcard.ru/products/ltr/ltr25)), либо предназначенные для выполнения специальных функций (например, измерение частоты – [LTR51](https://www.lcard.ru/products/ltr/ltr51)). В то же время, у  _АЦП общего применения_  могут присутствовать специализированные режимы (каналы) измерения (например, измерение сопротивления модулем  [LTR114](https://www.lcard.ru/products/ltr/ltr114)).
### Функции
`AnalogRead(<номер порта>)`
-   номер порта – номер аналогового порта, с которого мы будем считывать значение
Возвращаемое значение: число типа int в диапазоне от 0 до 1023, так как у `Arduino Uno` 10-битный АЦП
```c++
analogRead(A0); // считать сигнал с аналогового порта A0
analogRead(15); // аналогично, порт 15 и A0 – это одно и то же
```
### Примеры

#### Преобразование значения с помощью функции map()

В `Arduino` есть специальная функция, упрощающая преобразование диапазонов значений. Вы передаете ей значение и два диапазона (исходный и требуемый), а функция возвращает новое значение, которое будет также относиться к границам требуемого диапазона как и к границам исходного. Например, значение 5 в диапазоне от 0 до 10 преобразуется в значение 10 в диапазоне от 0 до 20. Значение 500 из диапазона от 0 до 1000 преобразуется в значение 5 из диапазона от 0 до 10.

Пример использования функции `map` совместно с функцией `analogRead ()`:

`int val = map(analogRead(A0), 0, 1023, 1, 10);` Вернет значение аналогового порта в диапазоне от 0 до 10. При этом 0 будет соответствовать 0, а 10 – 1023.

1.  Пример чтения значения с АЦП и вывод его в Serial Monitor:

```cpp
const int adcPin = A0; // Пин, к которому подключен сигнал АЦП

void setup() {
  Serial.begin(9600); // Инициализация Serial Monitor
}

void loop() {
  int adcValue = analogRead(adcPin); // Чтение значения с АЦП
  Serial.println(adcValue); // Вывод значения в Serial Monitor
  delay(500); // Задержка 0.5 секунды
}

```

2.  Пример использования АЦП для управления светодиодом:

```cpp
const int adcPin = A0; // Пин, к которому подключен сигнал АЦП
const int ledPin = 9; // Пин, к которому подключен светодиод

void setup() {
  pinMode(ledPin, OUTPUT); // Устанавливаем пин светодиода в режим OUTPUT
}

void loop() {
  int adcValue = analogRead(adcPin); // Чтение значения с АЦП
  int brightness = map(adcValue, 0, 1023, 0, 255); // Преобразование значения в диапазон яркости светодиода (0-255)
  analogWrite(ledPin, brightness); // Установка яркости светодиода
}

```

3.  Пример использования АЦП для контроля температуры с помощью термистора:

```cpp
const int adcPin = A0; // Пин, к которому подключен сигнал АЦП

void setup() {
  Serial.begin(9600); // Инициализация Serial Monitor
}

void loop() {
  int adcValue = analogRead(adcPin); // Чтение значения с АЦП
  float voltage = adcValue * (5.0 / 1023.0); // Преобразование значения в напряжение
  float temperature = (voltage - 0.5) * 100; // Расчет температуры по формуле
  Serial.println(temperature); // Вывод значения температуры в Serial Monitor
  delay(1000); // Задержка 1 секунда
}

```

4.  Пример использования АЦП для измерения освещенности с помощью фоторезистора:

```cpp
const int adcPin = A0; // Пин, к которому подключен сигнал АЦП

void setup() {
  Serial.begin(9600); // Инициализация Serial Monitor
}

void loop() {
  int adcValue = analogRead(adcPin); // Чтение значения с АЦП
  Serial.println(adcValue); // Вывод значения освещенности в Serial Monitor
  delay(1000); // Задержка 1 секунда
}
```
### Простая фильтрация
По разным причинам (например, некачественный источник питания, наводки и т. д.) мы можем наблюдать шум. То есть, когда мы считываем положение потенциометра, показания колеблются в каких то пределах. Этого можно избежать, фильтруя входной сигнал, и для этого есть несколько способов.

#### Среднее арифметическое

Один из самых простых способов. Суммируем значения, делим на количество измерений, тем самым добиваясь усреднения значений
```c++
const int NUMS = 30; // кол-во значений, которое мы будем суммировать, “сила фильтра”
int srArif() {
	long sum = 0;
	for (int i = 0; i<NUMS; i++)
	sum += analogRead(A0);
	return ((float)sum/NUMS);
}
```
#### Бегущее среднее

Работает по принципу буфера, в котором хранит несколько предыдущих значений. При каждом вызове буфера самое старое значение стирается, а самое новое добавляется, а после происходит усреднение по принципу среднего арифметического. Один из наиболее часто используемых фильтров.
```c++
void setup() {
	Serial.begin(9600);
}

float val = 0;

void loop() {
	int newVal = analogRead(A0);
	val += (newVal - val)*0.1;
	Serial.print(newVal);
	Serial.print(‘ , ’);
	Serial.println(val);
}
```
1.  Пример фильтра скользящего среднего для сглаживания значений АЦП:

```cpp
const int adcPin = A0; // Пин, к которому подключен сигнал АЦП

const int numReadings = 10; // Количество считываемых значений АЦП для фильтрации
int readings[numReadings]; // Массив для хранения считанных значений
int index = 0; // Индекс текущего считываемого значения

void setup() {
  Serial.begin(9600); // Инициализация Serial Monitor

  for (int i = 0; i < numReadings; i++) {
    readings[i] = 0; // Инициализация массива значений
  }
}

void loop() {
  int adcValue = analogRead(adcPin); // Чтение значения с АЦП
  // Удаление старого значения
  int total = 0;
  for (int i = 0; i < numReadings - 1; i++) {
    readings[i] = readings[i + 1];
    total += readings[i];
  }

  // Добавление нового значения
  readings[numReadings - 1] = adcValue;
  total += readings[numReadings - 1];

  // Вычисление среднего значения
  int average = total / numReadings;

  Serial.println(average); // Вывод среднего значения в Serial Monitor
  delay(1000); // Задержка 1 секунда
}
```

2.  Пример фильтра экспоненциального сглаживания для сглаживания значений АЦП:

```cpp
const int adcPin = A0; // Пин, к которому подключен сигнал АЦП
float smoothedValue = 0; // Сглаженное значение

void setup() {
  Serial.begin(9600); // Инициализация Serial Monitor
}

void loop() {
  int adcValue = analogRead(adcPin); // Чтение значения с АЦП
  // Вычисление сглаженного значения
  smoothedValue = (0.9 * smoothedValue) + (0.1 * adcValue);
  Serial.println(smoothedValue); // Вывод сглаженного значения в Serial Monitor
  delay(1000); // Задержка 1 секунда
}

```

3.  Пример фильтра нижних частот (RC-фильтр) для сглаживания значений АЦП:

```cpp
const int adcPin = A0; // Пин, к которому подключен сигнал АЦП
const float alpha = 0.1; // Коэффициент сглаживания
float smoothedValue = 0; // Сглаженное значение

void setup() {
  Serial.begin(9600); // Инициализация Serial Monitor
}

void loop() {
  int adcValue = analogRead(adcPin); // Чтение значения с АЦП
  // Вычисление сглаженного значения
  smoothedValue = (alpha * adcValue) + ((1 - alpha) * smoothedValue);
  Serial.println(smoothedValue); // Вывод сглаженного значения в Serial Monitor
  delay(1000); // Задержка 1 секунда
}

```

4.  Пример фильтра Медианного фильтра для сглаживания значений АЦП:

```cpp
const int adcPin = A0; // Пин, к которому подключен сигнал АЦП

const int numReadings = 5; // Количество считываемых значений АЦП для фильтрации
int readings[numReadings]; // Массив для хранения считанных значений
int index = 0; // Индекс текущего считываемого значения

void setup() {
  Serial.begin(9600); // Инициализация Serial Monitor

  for (int i = 0; i < numReadings; i++) {
    readings[i] = 0; // Инициализация массива значений
  }
}

void loop() {
  int adcValue = analogRead(adcPin); // Чтение значения с АЦП

  // Заполняем массив считанными значениями
  readings[index] = adcValue;
  index = (index + 1) % numReadings;

  // Сортируем массив значений
  for (int i = 0; i < numReadings - 1; i++) {
    for (int j = i + 1; j < numReadings; j++) {
      if (readings[i] > readings[j]) {
        int temp = readings[i];
        readings[i] = readings[j];
        readings[j] = temp;
      }
    }
  }

  // Вычисляем медиану массива значений
  int medianIndex = numReadings / 2;
  int medianValue = readings[medianIndex];

  Serial.println(medianValue); // Вывод медианного значения в Serial Monitor
  delay(1000); // Задержка 1 секунда
}
```
5. Фильтр [Каламана](https://en.wikipedia.org/wiki/Kalman_filter)
```c++
// ADC pin
const int adcPin = A0;

// Kalman Filter variables
float currentEstimate = 0;     // Filtered state variable
float errorEstimate = errorMeasure;
float lastEstimate = 0;
// Process noise
const float q = 0.1;
// Measurement noise
const float r = 10;

void setup() {
  Serial.begin(9600); 
  // Set ADC pin as input
  pinMode(adcPin, INPUT);
}

void loop() {
  // Read ADC value
  int rawValue = analogRead(adcPin);
  
  // Apply the simpleKalman function
  float filteredValue = simpleKalman(rawValue);
  // Print filtered value to Serial monitor
  Serial.println(filteredValue);
  // Delay for visualization purposes
  delay(100);
}

float simpleKalman(float newVal) {
  // Calculate the Kalman gain
  float kalmanGain = errorEstimate / (errorEstimate + errorMeasure);
  // Update the current estimate
  float updatedEstimate = lastEstimate + kalmanGain * (newVal - lastEstimate);
  // Update the error estimate
  errorEstimate = (1.0 - kalmanGain) * errorEstimate + fabs(lastEstimate - updatedEstimate) * q;
  // Update the last estimate
  lastEstimate = updatedEstimate;
  return updatedEstimate;
}
```

6. Альфа фильтр
```c++
// ADC pin
const int adcPin = A0;

// Alpha value
const float alpha = 0.2;

// Previous estimate
float prevEstimate = 0;

float alphaFilter(float newVal) {
  // Calculate the current estimate
  float currentEstimate = alpha * newVal + (1 - alpha) * prevEstimate;

  // Update the previous estimate
  prevEstimate = currentEstimate;

  return currentEstimate;
}

void setup() {
  Serial.begin(9600);
  
  // Set ADC pin as input
  pinMode(adcPin, INPUT);
}

void loop() {
  // Read ADC value
  int rawValue = analogRead(adcPin);
  
  // Apply the alphaFilter function
  float filteredValue = alphaFilter(rawValue);
  
  // Print filtered value to Serial monitor
  Serial.println(filteredValue);
  
  // Delay for visualization purposes
  delay(100);
}

```
7.  [Альфа-Бета фильтр](https://en.wikipedia.org/wiki/Alpha_beta_filter)
```c++
// ADC pin
const int adcPin = A0;

// Alpha and Beta values
const float alpha = 0.5;
const float beta = 0.2;

// Previous estimates
float prevEstimate = 0;
float prevRate = 0;

float alphaBetaFilter(float newVal) {
  // Calculate the current estimate
  float currentEstimate = alpha * newVal + (1 - alpha) * (prevEstimate + prevRate);

  // Calculate the current rate
  float currentRate = beta * (currentEstimate - prevEstimate) + (1 - beta) * prevRate;

  // Update the previous estimates
  prevEstimate = currentEstimate;
  prevRate = currentRate;

  return currentEstimate;
}

void setup() {
  Serial.begin(9600);
  
  // Set ADC pin as input
  pinMode(adcPin, INPUT);
}

void loop() {
  // Read ADC value
  int rawValue = analogRead(adcPin);
  
  // Apply the alphaBetaFilter function
  float filteredValue = alphaBetaFilter(rawValue);
  
  // Print filtered value to Serial monitor
  Serial.println(filteredValue);
  
  // Delay for visualization purposes
  delay(100);
}
```
8. Альфа-бета-гамма фильтр
```c++
// ADC pin
const int adcPin = A0;

// Filter coefficients
const float alpha = 0.2;
const float beta = 0.1;
const float gamma = 0.05;

// Previous estimates and rates
float prevEstimate = 0;
float prevRate = 0;

float abgFilter(float newVal) {
  // Calculate rate of change
  float currentRate = (newVal - prevEstimate) / (1.0 / millis());

  // Calculate current estimates
  float currentEstimate = prevEstimate + prevRate * (1.0 / millis()) + alpha * (newVal - prevEstimate);
  float currentRateEstimate = prevRate + beta * (newVal - prevEstimate) / (1.0 / millis());
  float currentAccelerationEstimate = gamma * (newVal - prevEstimate) / (1.0 / millis());

  // Update previous estimates and rates
  prevEstimate = currentEstimate;
  prevRate = currentRate;

  // Combine estimates to obtain final filtered value
  float filteredValue = currentEstimate + currentRateEstimate + currentAccelerationEstimate;

  return filteredValue;
}

void setup() {
  Serial.begin(9600);
  
  // Set ADC pin as input
  pinMode(adcPin, INPUT);
}

void loop() {
  // Read ADC value
  int rawValue = analogRead(adcPin);
  
  // Apply the abgFilter function
  float filteredValue = abgFilter(rawValue);
  
  // Print filtered value to Serial monitor
  Serial.println(filteredValue);
  
  // Delay for visualization purposes
  delay(100);
}

```

## Средства индикации

Пришло время поговорить про различные средства индикации. Конечно, работа с микроконтроллерами - это работы с датчиками, работа с выходами и входами, шинами и т.д. И это, конечно же, какие-то отладочные работы. А что, как не индикация, наглядно покажет нам где ошибка? Поэтому на этом занятии мы рассмотрим основные средства индикации.

Начнем конечно же со светодиодов и их производных. `LED` - `light emitting diode` - `светодиод`. Самый простой и универсальный способ проверить работу программы, первое что мы подключаем при знакомстве и один из самых популярных компонентов. Также, существуют светодиодные матрицы, объединенные общим катодом или анодом.

Светодиодные ленты - ленты, в которых светодиоды соединены последовательно. Самые простые - светят каким-то одним цветом, `RGB` ленты - могут светиться тремя цветами, и, наконец, самый вариативный вариант - адресная светодиодная лента. В ней мы можем управлять конкретными светодиодами и их цветом. Как правило, для подключения ленты требуется источник питания, так как такие ленты требуют большого тока из-за количества светодиодов.

Сегментные индикаторы - индикаторы, в которых светодиоды расположены в виде цифр, или шкалы. Можно подключать каждый светодиод отдельно, но тем самым займем много пинов `Arduino`. Существуют специальные сдвиговые регистры, разгружающие выводы нашей платы.

Дисплеи, и в частности `tft` дисплеи - дисплеи с матрицей, которая состоит из транзисторов в виде тонкой пленки. Бывают монохромные и цветные.

Не стоит забывать про звуковую индикацию - в качестве примера можно сделать сигнализацию для обнаружения предметов, реакции на движение, детектировании утечек газа.  

### ШИМ

На прошлом занятии мы познакомились с типами сигналов (цифровые и аналоговые). И проговорили, что наша плата не может генерировать аналоговый сигнал, только цифровой - вкл и выкл. Но как же быть? Ведь нам порой очень важно менять какое-то значение во времени, будь то плавное нарастание свечения светодиода или скорость мотора. Напомню, что в `Arduino` нет цифро - аналогового преобразователя. Но мы все-таки можем добиться плавного управления цифровым сигналом. Для этих целей существует широтно-импульсная модуляция. Сокращенно `ШИМ`, на английском - `PWM`(можете увидеть в datasheet’ах). Как это работает? Представьте себе вентилятор, работающий в полную мощность, с постоянным напряжением. Теперь давайте включать вентилятор на секунду, а затем на секунду выключать, и повторять это по кругу. Вентилятор начнет крутиться в два раза медленнее. Но мы, скорее всего, будем видеть моменты включения и выключения, особенно если вентилятор маленький. Давайте возьмем большой вентилятор, обладающий большей инертность, и здесь уже почти незаметны моменты включения и выключения. Заставим его работать в 4 раза медленнее, будем подавать напряжение на 0,5 секунд, а затем на 1,5 секунды выключать. Это и есть ШИМ сигнал.

Основные характеристики ШИМ `Arduino`: частота, скважность, период заполнения.

![](https://lh3.googleusercontent.com/X3bPJBWuMg_uBR3V_QIWgiBraAcvyuGKdRKreyZpFC3tzJHeKmkgKyJV6D1kP6j52Yhw3BavEfvGJVQDvZkQzvgp0PkE1BPImpZ8yKYgBI3RGWcWzGcb4pC5v3gRegs38YJWJNt-CF1WIhNw-zS6Xw)

Пример ШИМ по отношению к напряжению
Коэффициент заполнения - отношение длительности периода к периоду импульса.

![](https://lh5.googleusercontent.com/bHyYJ19S0WwZSwC7x1EEWf3_dEVZ_pfvYOhoRX0hEcR8HsxckDr-gTBzyYrQsSqO9_CjZQAj_NxJuHbPdZvLvyTmFYbenQjAchl3d1L656ObAzFBkolYgqXoWQC687segPL7svN7PcQ46rZF2y2vPA)

Примеры желаемого напряжения и соответствующего ШИМ сигнала(в % указан коэффициент заполнения)
Скважность - величина, обратная коэффициенту заполнения.
> [Пример 1: Светодиод с потенцилометром](https://wokwi.com/projects/376357059222770689)
> [Пример 2: Светодиод с датчиком температуры](https://wokwi.com/projects/376357149151807489)
#### Примеры

Давайте перейдем к практике, и попробуем управлять яркостью светодиода посредством ШИМ. Если мотор, вентилятор из примера или, например лампочка, имеют инертность, то как быть со светодиодом, ведь он практически не имеет задержки включения. Но выход есть. В примере с вентилятором у нас был период 2 секунды, то есть 0,5 Гц. А теперь давайте представим, если наша частота будет 1000Гц, или вообще 25000 Гц! Тут будет задействована уже инертность глаза, он не заметит включение и выключение светодиода, для него это будет изменением яркости. Давайте посмотрим как это работает. Частота ШИМ сигнала Arduino - 488,28 Гц.

Для того, чтобы воспользоваться ШИМ сигналом, надо найти на плате цифровой пин со специальной пометкой ~ (тильда). Чтобы сгенерировать ШИМ сигнал, есть специальная функция - `analogWrite()`, которая принимает два аргумента - номер пина и так называемое заполнение ШИМ сигнала. По умолчанию все выходы ШИМ у нас 8-битные, поэтому максимальное значение 0-255.

![Подключения светодиода](https://lh4.googleusercontent.com/eBHj1boupG5ZU_UnL5kamFGwJGETbtdNKkcX27XBRlPaYeu9V8eXQlxTJS5hc6g_4UvFJ2u0PADgBunLbAj1iYwdM2oyKK5r2Yj05AEg6dMmqfwmXayi-rFR7YM-0LJyumz9aGqRP1ICvESs5A0_NQ)

Давайте сделаем так, чтобы цвет плавно нарастал а потом убывал.
```c++

void setup() {
	pinMode(5, OUTPUT);
} 

void loop() {
	for (int i = 0; i<255; i++) {
		analogWrite(5, i);
		delay (20);
	}
	for (int i=255; i>=0; i--){
		analogWrite(5, i);
		delay(20);
	}
}
```
##### RGB светодиод
> [Пример 1: RGB с потенцилометром](https://wokwi.com/projects/376357270455290881)
> 
![Подключение RGB светодиода](https://lh4.googleusercontent.com/ynThHfcJmNsawDLbhpdeqCnJDEnR1W63L-_mqO-y-7BmVu83Ruk72GWRb3hMm_yrk2taB5kA-zdwEQOwFzv4fiC7fZMCjPhYaermGFcVbsapI1G8msLcJbZ8xd1jl4JvXcILfaUPhOAnhyOLUcqsDA)
Программа для создания плавного переливания цвета(пример с несколькими цветами)
```c++
#define RED_LED 11
#define GREEN_LED 3
#define BLUE_LED 6
int t = 7; // задержка в переменной, чтобы каждый раз не писать

void setup() {
	pinMode(RED_LED, OUTPUT);
	pinMode(GREEN_LED, OUTPUT);
	pinMode(BLUE_LED, OUTPUT);
}

void loop() {
	//от красного к желтому
	for (int value = 0; value <= 255; value++)// нам необходимо ввести переменную в цикле, которая бы увеличивалась, в зависимости от нужного цвета(или уменьшалась)
	{
		analogWrite(RED_LED, 255); // красный горит
		analogWrite(GREEN_LED, value); // за каждый проход по циклу мы плавно добавляем зеленый цвет к красному, чтобы получился желтый
		analogWrite(BLUE_LED, LOW); // синий выключен, так как он не используется ни в красном ни в желтом цвете
		delay(t);
	}

	//от желтого к зеленому
	for (int value = 0; value <= 255; value++) // помните, что мы начинаем от цвета, на котором закончили, то есть на желтом
	{
		analogWrite(RED_LED, 255 - value); // чтобы плавно перейти к зеленому, теперь нам нужно вычитать нашу переменную value из 255
		analogWrite(GREEN_LED, 255); // то есть в сочетании цветов красный медленно угасает, а тем временем зеленый горит постоянно
		analogWrite(BLUE_LED, LOW);
		delay(t);
	}
}
```
#### Матрицы
>[Пример 1: max7219](https://wokwi.com/projects/376357324045920257)
ак мы уже знаем, сегментные индикаторы, будь то шкалы или цифры, состоят из отдельных светодиодов, соединенных вместе. Например, у группы светодиодов могут быть соединены все катоды. Такой индикатор имеет приписку «с общим катодом», в противном случае — «с общим анодом».

А что будет, если мы разместим светодиоды не в виде цифры или шкалы, а в виде сетки? Получится уже вполне себе графический индикатор. То есть такой, на котором можно отобразить не только число, но и какое-то изображение.

Такая сетка называется матричным индикатором, а в случае использования светодиодов — светодиодной матрицей. Разрешение матричного индикатора — это количество точек по горизонтали и вертикали. Например, самые распространенные индикаторы имеют разрешение 8×8 точек.

[![Светодиодная матрица на Ардуино](https://robotclass.ru/wp-content/uploads/2016/12/led-matrix-8x8-1024x768.jpg)](https://robotclass.ru/wp-content/uploads/2016/12/led-matrix-8x8.jpg)

Если требуется светодиодная матрица с большим разрешением, то её просто-напросто составляют из нескольких 8×8 индикаторов. Как это делать, мы увидим позже. А пока разберемся как соединяются все 64 светодиода внутри матрицы.

Конечно, можно бы было как и в случае семисегментного индикатора соединить все светодиоды общим катодом или анодом. В этом случае нам бы потребовалось либо 64 вывода контроллера, либо 8 сдвиговых регистров. Оба варианта весьма расточительны.

Более правильный вариант — объединить светодиоды в группы по 8 штук с общим катодом. Пусть это будут столбцы матрицы. Затем, параллельные светодиоды в этих столбцах объединить снова в группы по 8 штук уже с общим анодом. Получится вот такая схема:

[![Светодиодная матрица на Ардуино, схема](https://robotclass.ru/wp-content/uploads/2016/12/led-matrix-8x8-schema.png)](https://robotclass.ru/wp-content/uploads/2016/12/led-matrix-8x8-schema.png)

Предположим, стоит задача зажечь светодиод R6C3. Для этого нам потребуется подать высокий уровень сигнала на вывод R6, а вывод C3 соединить с землей.

[![Светодиодная матрица на Ардуино, схема](https://robotclass.ru/wp-content/uploads/2016/12/led_8x8_R6C3.png)](https://robotclass.ru/wp-content/uploads/2016/12/led_8x8_R6C3.png)

Не выключая эту точку, попробуем зажечь другую — R3C7. Положительный контакт питания соединим с R3 и землю с C7. Но в таком случае строки R6 и R3 будут пересекаться с колонками C3 и C7 не в двух, а в четырех местах! Следовательно и зажжется не две, а четыре точки. Проблема!

[![Светодиодная матрица на Ардуино, схема](https://robotclass.ru/wp-content/uploads/2016/12/led_8x8_R6C3_R3C7.png)](https://robotclass.ru/wp-content/uploads/2016/12/led_8x8_R6C3_R3C7.png)

Очевидно, что помочь сможет всё та же  [динамическая индикация](http://robotclass.ru/tutorials/arduino-dynamic-led-indication/). Если мы будем включать точки R6C3 и R3C7 по-очереди очень быстро, то сможем использовать персистентность зрения — способность интерпретировать быстро сменяющиеся изображения как одно целое.





##### Оценка применимости
Давайте теперь поговорим про большую нагрузку. Как вы уже поняли, микроконтроллеры отвечают за логику, и управлять большими мощностями с них не получится. `Arduino` в этом плане дает чуть больше свободы, но следующие микроконтроллеры, которые вы будете изучать, будут отвечать исключительно за логику. Поэтому сейчас мы познакомимся со средствами управления большой нагрузкой.

1.  Транзистор
    
2.  Электромагнитное реле
    
3.  Твердотельное реле
    
4.  Оптопара
    
### Сдвиговые регистры
> [Пример 1: Один сдвиговый регистр](https://wokwi.com/projects/376357505861682177)
> [Пример 2: Два сдвиговых регистра](https://wokwi.com/projects/376357857072826369)
#### Что такое сдвиговые регистры ?

Как только мы захотим подключить, например, семисегментные индикаторы, мы сразу столкнемся с проблемой - они занимают очень много места на плате. Другими словами чтобы подключить один семисегментный индикатор, нужно занять восемь выходов на плате. А что делать, если мы захотим подключить два таких индикатора, или вообще сделать часы - четыре индикатора? Плюс несколько моторов, реле и пару датчиков. Даже просто четыре индикатора будут выглядеть так:

  

![](https://lh3.googleusercontent.com/l-7iMM8EhRzsUTMrchD2bY3WNlkBtGlhZlEK9bifGaPoQJxIy_MA33pYRlSB0dMGO20OcrxaYnQ7UdpcLHqtrh3otOA3z2fNy7SCGy5jVCUBHB2Dq8em4wGd7D_ub91ekUItN508473iDH0bEhvqTQ)

Можно взять плату с большим количеством выводов, но гораздо проще и быстрее подключить сдвиговый регистр. Когда вычислительных мощностей хватает, и проблема только в выводах, это будет дешевле и компактнее.

Итак, сдвиговый регистр - это устройство, которое принимает поток последовательных битов и одновременно выводит их значения на параллельных контактах ввода вывода. Регистры сдвига часто применяются для управления большим количеством светодиодов.

Напомню, что существует два типа передачи данных, последовательный и параллельный. До этого занятия мы работали в параллельном режиме, когда писали `digitalWrite()` для нескольких светодиодов. Сдвиговые регистры позволяют легко конвертировать последовательные и параллельные методы передачи данных. Мы будем пользоваться последовательно - параллельным регистром сдвига, с его помощью принимать данные последовательно, а выводить параллельно. Так же, можно каскадировать регистры, и управлять множеством цифровых выходов, используя всего три контакта Arduino.

#### Регистр 74HC595

![](https://lh5.googleusercontent.com/F_iyfbws9Gj8alPUiqTX6_dipeFYon_AWxTfRyWDphZybq3gVNuukB3YfCJt7Lmuwowq7icJsojhJXEIFZoC7jtDKFJXkCAPIquE1kOoVTL05vhdAotRvYDGhO6M4ETkKmcMryyziK-xIMjwPG8rNA)

- `Qa` - `Qh` - восемь параллельных выходов сдвигового регистра

- `GND` - соединяется с GND на плате

- `SER(DATA)` - выход данных, по нему передается восемь последовательных битов данных для установки значений на параллельных выходах

- `SRCLK(CLOCK)` - тактовый вход. Когда мы подаем высокое напряжение(HIGH) на этот вход, происходит считывание, происходит считывание одного бита данных с входа DATA в сдвиговый регистр. Чтобы получить все восемь битов данных, необходимо подать восемь импульсов.

- `RCLK(LATCH)` - так называемая защелка, благодаря этому входу мы выводим последовательные данные на параллельные выходы.

Осталось еще два контакта, которые в данный момент мы не будем использовать, но если вы будете соединять несколько сдвиговых регистров, то есть, делать каскад, вам понадобится эта информация.

- `QE` - разрешение вывода данных на параллельные выходы. Обратите внимание, что над этими буквами стоит черта, это значит что активный уровень для этого входа - низкий. Когда на этом входе низкий уровень, параллельные выходы будут включены, когда высокий - выключены. У нас этот контакт подключен к GND, соответственно все выходы постоянно включены. Его можно соединить с пином ардуино, и тогда можно управлять этим процессом.

- `SRCRL` - контакт сброса. При подаче напряжения низкого уровня очищает содержимое сдвигового регистра. У нас подключен к 5В.
#### Принцип работы

Каждый раз, когда сигнал на входе `SRCLK(CLOCK)` меняется с низкого на высокий, все значения, хранящиеся в восьми выходных ячейках, сдвигаются на одну позицию. Данные из последней ячейки либо сбрасываются, либо передаются на выход `Qh`(при каскадном подключении). Одновременно последовательные данные на входе `SER(DATA)` сдвигаются на одну позицию. За восемь тактов - импульсов предыдущие значения сбрасываются, а новые загружаются. Подача высокого сигнала на вход `RCLK(LATCH)` выводит значения, хранящиеся в ячейках, на выходы регистра.

Допустим мы хотим зажечь несколько светодиодов, подключенных к выходам `Qa`, `Qc`, `Qe`, `Qg`. В двоичном представлении это выглядит так: `10101010`.

  

![](https://lh3.googleusercontent.com/axkxGwyioD4_cTS5arQp0OW6jOd_5re4QRpz_X3nGy27KbG2jfcFyNVmeHhM8Nrw1ABJ5FObDniNFkryimEs438HyYziLNt_6MWS07MOtjwUMnudllPSzlKfHlV2Z1KSn-CFBYBPKQQMrOVbjJ1puQ)
##### Пример
![](https://lh3.googleusercontent.com/2qF4G0bQIl33phQlXOe0P53LQi129LKfbC3blFiECKEsPD7GAKreEZ7JScUhPFnAJWJvyg98mEsHv47KihHRmeOZOFihAVVcAQ9brVMOe0eI5pARdWCzBMGMyi4HsLPEahy5uhwBaySyIS6iKMpppw)

  
```c++
const int SER = 8;
const int LATCH = 9;
const int CLK = 10; 

void setup() { 
	pinMode(SER, OUTPUT);
	pinMode(LATCH, OUTPUT);
	pinMode(CLK, OUTPUT);
	digitalWrite(LATCH, LOW);
	shiftOut(SER, CLK, MSBFIRST, B10101010);
	digitalWrite(LATCH, HIGH);
}

void loop() {}
```
#### Функция shiftOut()

Функция `shiftOut` используется для поразрядной выдачи данных. Эта функция принимает четыре аргумента:

-   номер контакта `DATA`
    
-   номер контакта `CLOCK`
    
-   порядок выдачи битов
    
-   значение, выдаваемое на выход
    

Аргумент `MSBFIRST` показывает, что самый старший бит(крайний левый) будет отправлен первым. Если написать `LSBFIRST`, то мы отправим крайний правый бит - самый младший.

`shiftOut()` это функция, которая и генерирует тот самый импульс, о котором мы говорили в начале, тем самым сообщая внешнему устройству о поступлении нового бита. Интересное замечание: функция является программной реализацией `SPI`, но работает медленнее, так как аппаратная версия реализована в отдельной библиотеке.

#### Преобразование между форматами

Мы написали программу, в которой передавали биты в двоичном виде. Но так же можно передавать сигналы в сдвиговый регистр в десятичном формате. В некоторых проектах удобнее представлять информацию в таком виде. Каждый разряд двоичного числа представляет следующую ступень числа 2(начиная с младшего, самого правого). Давайте переведем то что у нас уже есть в двоичный код.

![](https://lh6.googleusercontent.com/uvPLBMu3prc98Igzyd6DH1xwPDXkLm_ZmVL25wWrqhbpWhUUOlHOtqDEwdgrZi-uokf3T3kWKaRoSBTzu3ru29B4BvHkqmSR0irS1f0kx_a4V1Efq39eXl5Eg40rJUKrp0v_PvE-NOhQBg6iwi_DDw)

Теперь в том месте программы, где мы вызываем функцию `shiftOut()` вместо `B10101010` можно смело написать 170, и ничего не изменится.

  

#### Создание световых эффектов

С помощью функции `shiftOut()` можно очень быстро обновлять данные в ячейках сдвиговых регистров, чтобы создавать динамичные световые анимации. Давайте создадим эффект “бегущего огня”. Для этого представим в десятичном виде положение каждого светодиода в регистре, создадим последовательность из этих чисел, и передадим в функцию `shiftOut()`.

![](https://lh5.googleusercontent.com/ZnQS3tspu9oTSA0BL06vHOcrEsu-ZIIex_cHqTP7AdJqRLu2Sk6BfyiZ_PgwM-mbfrKTjVBEXkdTuSrvnwhhUEsjyi3zwrWaYDrXD2ghWFgNX0JKh6YDmQR_aPePv2NNv_8rEuwdPGyF4ScGjdxzUA)
```c++
const int SER = 8;
const int LATCH = 9;
const int CLK = 10;
// последовательность
int vs[14] = {1,2,4,8,16,32,64,128,64,32,16,8,4,2};

void setup() {
	pinMode(SER, OUTPUT);
	pinMode(LATCH, OUTPUT);
	pinMode(CLK, OUTPUT);
}

void loop() {
	for (int i = 0; i<14;i++)
	{
		digitalWrite(LATCH, LOW);
		shiftOut(SER, CLK, MSBFIRST, vs[i]);
		digitalWrite(LATCH, HIGH);
		delay(20);
	}
}
```
  Пример кода, где массив в двоичном виде используется в цикле. Обратите внимание, как выглядит второй цикл - в нем, в функции `shiftOut()` четвертый аргумент это разность тройки и `i`-го элемента. Изменяя этот аргумент можно добиться более быстрого перемещения бегущего огня.
```c++ 
int dataPin = 8;
int clockPin = 10;
int latchPin = 9;

byte path[4] = {
	B11000011,
	B00111100,
	B00100100,
	B00011000
};

void setup() {
	pinMode(latchPin, OUTPUT);
	pinMode(clockPin, OUTPUT);
	pinMode(dataPin, OUTPUT);
}

void loop() {
	for (int i = 0; i < 4; i++) {
		digitalWrite(latchPin, LOW);
		shiftOut(dataPin, clockPin, LSBFIRST, path[i]);
		digitalWrite(latchPin, HIGH);
		delay(250);
	}
	for (int i = 0; i < 4; i++) {
		digitalWrite(latchPin, LOW);
		shiftOut(dataPin, clockPin, LSBFIRST, path[3 - i]);
		digitalWrite(latchPin, HIGH);
		delay(250);
	}
}
```
  Так же можно использовать довольно интересную функцию `bitWrite(x, n, b)` - где `x` - переменная, у которой нужно изменить бит, `n` - номер бита, состояние которого необходимо изменить(начинается с крайнего правого), `b` - новое значение бита (`0` или `1`).

Реализация бегущего огня с помощью `bitWrite()`.
```c++
int dataPin = 8;
int clockPin = 10;
int latchPin = 9;

void setup() {
	pinMode(latchPin, OUTPUT);
	pinMode(clockPin, OUTPUT);
	pinMode(dataPin, OUTPUT);
}

void loop() {
	byte byteToSend = 0; //Создаем пустой байт B00000000
	for (int bitPos = 0; bitPos < 8; bitPos++) { // В переменной хранится позиция изменяемого бита
		byteToSend = 0; // Обнуляем байт при каждом проходе
		bitWrite(byteToSend, bitPos, HIGH); // При bitPos=0 получим B00000001, при bitPos=1 - B00000010, при bitPos=2 - B00000100 и т.д.
		digitalWrite(latchPin, LOW);
		shiftOut(dataPin, clockPin, MSBFIRST, byteToSend); // Инвертируем сигнал при помощи MSBFIRST, грузим с первого бита
		digitalWrite(latchPin, HIGH);
		delay(50);
	}
}
```
#### Реализация ШИМ с помощью сдвигового регистра

К сожалению ШИМ сдвиговым регистром не поддерживается. Поэтому есть небольшая хитрость - мы будем использовать выход регистра OE. OE можно назвать логическим нулем для всех выходов. Если мы подключим этот выход к ШИМ Arduino, мы можем смещать логический ноль, тем самым имитировать ШИМ на выходах.
```c++
int dataPin = 8;
int latchPin = 9;
int clockPin = 10;
int pwmPin = 6;

void setup() {
	//устанавливаем режим OUTPUT
	pinMode(latchPin, OUTPUT);
	pinMode(clockPin, OUTPUT);
	pinMode(dataPin, OUTPUT);
	pinMode(pwmPin, OUTPUT);
	digitalWrite(latchPin, LOW); // устанавливаем синхронизацию "защелки" на LOW
	shiftOut(dataPin, clockPin, LSBFIRST, B11110001);
	digitalWrite(latchPin, HIGH); //"защелкиваем" регистр, тем самым устанавливая значения на выходах
}

void loop() {
	for (int i=0; i<256; i++) {
		analogWrite(pwmPin, i); // Назначаем выходу ШИМ разные значения
		delay(2); // Делаем паузу, чтобы не мигало слишком быстро
	}
}

```

#### Светодиодная матрица и сдвиговые регистры

В нашем уроке мы будем подключать к Ардуино Уно самую простую светодиодную матрицу 8×8 красного свечения. Нумерация выводов начинается с нижнего левого угла. При этом, нумерация ног 1-16 не связана никакой логикой с нумерацией колонок и строк C и R.

[![Распиновка светодиодной матрицы 8x8](https://robotclass.ru/wp-content/uploads/2016/12/8X8-Matrix-Pinout.jpg)](https://robotclass.ru/wp-content/uploads/2016/12/8X8-Matrix-Pinout.jpg)

Ориентируясь на урок про динамическую индикацию, попробуем использовать в схеме управления матричным индикатором 8-битные сдвиговые регистры. Один регистр подключим к выводам индикатора, отвечающим за колонки, а второй к выводам строк.

**Принципиальная схема**

[![Принципиальная схема светодиодная матрица Ардуино](https://robotclass.ru/wp-content/uploads/2016/12/led-matrix-8x8_%D1%81%D1%85%D0%B5%D0%BC%D0%B0_c-1024x428.png)](https://robotclass.ru/wp-content/uploads/2016/12/led-matrix-8x8_%D1%81%D1%85%D0%B5%D0%BC%D0%B0_c.png)

**Важное замечание №1.**  Необходимо, чтобы резисторы в этой схеме были на линиях, идущих от первого сдвигового регистра. Этот сдвиговый регистр отвечает за колонки. При таком подключении, каждый резистор будет задавать ток только для одного светодиода на каждом шаге динамического алгоритма. Следовательно, все светодиоды будут светиться равномерно.

**Важное замечание №2.** Указанная выше схема носит сугубо ознакомительный характер. Правильнее будет включить в разрыв между вторым регистром и матрицей дополнительную силовую микросхему, например транзисторную сборку ULN2003.

##### Пример

Чтобы было веселей, попробуем высветить на индикаторе смайлик. Как уже было сказано, для вывода изображения на матрицу воспользуемся динамической индикацией. А именно, будем высвечивать нашу картинку построчно. Сначала зажжем нужные колонки в самой верхней строке, затем во второй, в третьей, и так все 8 строк.

[![Светодиодная матрица на Ардуино, схема](https://robotclass.ru/wp-content/uploads/2016/12/led_8x8.gif)](https://robotclass.ru/wp-content/uploads/2016/12/led_8x8.gif)

За колонки у нас будет отвечать первый сдвиговый регистр, а за строки второй. Следовательно, вывод строки будет состоять из двух последовательных записей в регистр: сначала передаем код строки, затем код точек в этой строке.

В этой программе мы также воспользуемся ускоренной версией функции `digitalWrite`. Это необходимо для того, чтобы процесс динамической индикации проходил очень быстро. В противном случае, мы увидим заметное мерцание матрицы.
```c
const byte data_pin = PD2;
const byte st_pin = PD3;
const byte sh_pin = PD4;

unsigned long tm, next_flick;
const unsigned int to_flick = 500;

byte line = 0;

const byte data[8] = {
    0b00111100,
    0b01000010,
    0b10100101,
    0b10000001,
    0b10100101,
    0b10011001,
    0b01000010,
    0b00111100
};

void latchOn(){
    digitalWriteFast(st_pin, HIGH); 
    digitalWriteFast(st_pin, LOW);
}

void fill( byte d ){
    for(char i=0; i<8; i++){
        digitalWriteFast(sh_pin, LOW);
        digitalWriteFast(data_pin, d & (1<<i));
        digitalWriteFast(sh_pin, HIGH);
    }
}

void setPinFast(byte pin){
    DDRD |= _BV(pin);
}

void digitalWriteFast(byte pin, byte sig){
    if( sig )
        PORTD |= _BV(pin);
    else
        PORTD &= ~_BV(pin);
}

void setup() {
    setPinFast(data_pin);
    setPinFast(st_pin);
    setPinFast(sh_pin);
}

void loop() {
    tm = micros();
    if( tm > next_flick ){
        next_flick = tm + to_flick;
        line++;
        if( line == 8 )
            line = 0;
        // передаем код строки
        fill( ~(1<<(7-line)) );
        // зажигаем точки в строке № line
        fill( data[line] );
        // открываем защелку
        latchOn();
    }
}
```

Основная часть этой программы, включая переменные  `data_pin, sh_pin, st_pin, next_flick, to_flick`  и функцию  `fill`
Массив  `data` хранит восемь строк нашей картинки. Для экономии памяти мы записали каждую комбинацию точек в бинарном виде.

Функция  `latchOn` открывает защелку регистра. Это нужно делать только после заполнения обоих сдвиговых регистров.

## Интерефсы связи:
`Arduino Uno` поддерживает следующие интерфейсы связи:

1.  **Serial (UART)**: Arduino Uno имеет один hardware-сериальный порт, который может использоваться для связи с компьютером или другими устройствами через USB. Он используется для программирования и отладки Arduino Uno, а также для обмена данными с внешними устройствами.
    
2.  **I2C (TWI)**: Arduino Uno имеет два пина (A4 и A5), которые могут быть использованы для связи по шине I2C. Этот интерфейс позволяет подключать несколько устройств к одной шине с использованием только двух проводов.
    
3.  **SPI**: Arduino Uno имеет три пина (10, 11 и 13), которые могут быть использованы для связи по шине SPI. Этот интерфейс используется для обмена данными между Arduino Uno и другими устройствами, такими как датчики, дисплеи и память.
    
4.  **Аналоговые пины**: Arduino Uno имеет 6 аналоговых пинов (A0-A5), которые могут быть использованы для чтения аналоговых сигналов, например, с датчиков.
    
5.  **Цифровые пины**: Arduino Uno имеет 14 цифровых пинов, которые можно использовать для управления и чтения цифровых сигналов.
    
6.  **Питание**: Arduino Uno имеет различные пины для подачи питания (5V и 3.3V) и заземления (GND).
### Serial(UART)
`UART` (Universal Asynchronous Receiver/Transmitter, универсальный асинхронный приемопередатчик) - это аппаратный модуль для последовательной асинхронной передачи данных между устройствами. Он обеспечивает передачу и прием данных по одному проводу, используя только два состояния сигнала - высокий и низкий уровни напряжения.

`UART` является основным интерфейсом связи на многих микроконтроллерах, включая `Arduino Uno`. Он позволяет обмениваться данными между Arduino и другими устройствами, такими как компьютер или периферийные устройства.

Назначение линий:

-   `TX` (Transmission) - линия передачи данных от `Arduino` к другому устройству
-   `RX` (Reception) - линия приема данных от другого устройства к `Arduino`

`UART `использует асинхронную передачу данных, что означает, что данные передаются без синхронизации по внешнему тактовому сигналу. Вместо этого, каждый передаваемый бит сопровождается стартовым битом и стоповым битом, которые помогают синхронизироваться между устройствами.

Основные характеристики **UART**:
[Wokwi docs](https://docs.wokwi.com/guides/serial-monitor)
-   Скорость передачи данных (битрейт) - устанавливает скорость передачи данных между устройствами. На` Arduino Uno` можно настроить скорость передачи от 300 бит/с до 115200 бит/с.
-   Формат кадра данных - определяет, какие биты используются для передачи данных (бит данных) и какой бит для ошибок (бит паритета).
-   Чтение и запись данных - `Arduino Uno` предоставляет функции для чтения и записи данных через `UART`. Например, функция `Serial.read()` используется для чтения данных из буфера входного потока, а функция `Serial.write()` - для записи данных в буфер выходного потока.

`UART` является простым и широко распространенным интерфейсом связи, который позволяет обмениваться данными между Arduino и другими устройствами. Он часто используется для отладки и программирования Arduino, а также для передачи данных между различными датчиками, модулями связи и периферийными устройствами.
Набор функций  **Serial**  служит для связи устройства Ардуино с компьютером или другими устройствами, поддерживающими последовательный интерфейс обмена данными. Все платы Arduino имеют хотя бы один последовательный порт ([UART](https://ru.wikipedia.org/wiki/UART), иногда называют USART). Для обмена данными  **Serial**  используют цифровые порты ввод/вывода 0 (RX) и 1 (TX), а также USB порт. Важно учитывать, что если вы используете функции  **Serial**, то нельзя одновременно с этим использовать порты 0 и 1 для других целей.

[Среда разработки Arduino](https://arduino.ru/Arduino_environment)  имеет встроенный монитор последовательного интерфейса (Serial monitor). Для начала обмена данными необходимо запустить монитор нажатием кнопки Serial monitor и выставить ту же скорость связи (baud rate), с которой вызвана функция begin().

Плата  [Arduino Mega](https://arduino.ru/Hardware/ArduinoBoardMega)  имеет три дополнительных последовательных порта:  **Serial1**  на портах 19 (RX) и 18 (TX),  **Serial2**  на портах на портах 17 (RX) и 16 (TX),  **Serial3**  на портах на портах 15 (RX) и 14 (TX). Чтобы использовать эти порты для связи с компьютером понадобится дополнительные адаптеры USB-to-serial, т.к. они не подключены к встроенному адаптеру платы Mega. Для связи с внешним устройством через последовательный интерфейс соедините TX порт вашего устройства с RX портом внешнего устройства и RX порт вашего устройства с портом TX внешнего и соедините "землю" на устройствах. (Важно! Не подключайте эти порты напрямую к RS232 порту, это может повредить плату).

#### Функции

-   [begin](https://arduino.ru/Serial/Begin)()
-   [end](https://arduino.ru/Serial/End)()
-   [available](https://arduino.ru/Reference/Serial/Available)()
-   [read](https://arduino.ru/Reference/Serial/Read)()
-   [flush](https://arduino.ru/Reference/Serial/Flush)()
-   [print](https://arduino.ru/Reference/Serial/Print)()
-   [println](https://arduino.ru/Reference/Serial/Println)()
-   [write](https://arduino.ru/Reference/Serial/Write)()
-   [peek](https://arduino.ru/Reference/Serial/Peek)()

#### Пример
##### 1. Print Some Data

```cpp
void setup() {
  // Initialize UART baud rate
  Serial.begin(9600);
}

void loop() {
  // Print a message to the Serial monitor
  Serial.println("Hello, World!");

  // Delay for visualization purposes
  delay(1000);
}

```

In this example, the Arduino board writes the message "Hello, World!" to the Serial monitor every second.

##### 2. Read Some Data

```cpp
void setup() {
  // Initialize UART baud rate
  Serial.begin(9600);
}

void loop() {
  // Check if there is any data available to read from the Serial port
  if (Serial.available()) {
    // Read the data from the Serial port
    char receivedByte = Serial.read();

    // Process the received data
    // (e.g., print it to the Serial monitor)
    Serial.print("Received: ");
    Serial.println(receivedByte);
  }
}

```
##### 3. Использование базовых функций Serial

В данном примере функция `Serial.begin(9600)` используется для инициализации `UART`-связи со скоростью передачи данных `9600`.

Приведем примеры других функций `Serial`, используемых в этом коде:

- Serial.available()` используется для проверки наличия данных, доступных для чтения из последовательного порта. В одном из примеров, если доступно хотя бы 3 байта, код считывает данные и обрабатывает их.

- `Serial.read()` используется для чтения байта из последовательного порта. В одном из примеров код считывает байт и обрабатывает его (например, преобразует в верхний регистр).

- `Serial.flush()` используется для того, чтобы дождаться передачи всех исходящих данных, прежде чем приступить к выполнению кода.CopyCopy

- `Serial.print()` и `Serial.println()` используются для отправки данных в последовательный порт в целях отладки или мониторинга. В одном из примеров код печатает значение переменной.

- `Serial.write()` используется для записи байта данных в последовательный порт.

- `Serial.peek()` используется для подглядывания за следующим байтом в буфере Serial без его удаления. В одном из примеров код подсматривает следующий байт и выполняет некоторое действие, основываясь на его значении.
```c++
void setup() {
  // Initialize UART baud rate
  Serial.begin(9600);
}

void loop() {
  // Check if there is any data available to read from the Serial port
  if (Serial.available()) {
    // Read the data from the Serial port
    char receivedByte = Serial.read();

    // Process the received data
    // (e.g., convert it to uppercase)
    char processedByte = toupper(receivedByte);

    // Send the processed data back to the Serial port
    Serial.print("Processed: ");
    Serial.println(processedByte);
  }
  // Example using Serial.available()
  if (Serial.available() >= 3) {
    // Read three bytes from the Serial port
    char receivedData[3];
    for (int i = 0; i < 3; i++) {
      receivedData[i] = Serial.read();
    }

    // Process the received data
    // (e.g., send it to another function for further processing)
    processReceivedData(receivedData);
  }
  // Example using Serial.print()
  int variable = 42;
  Serial.print("The value of variable is ");
  Serial.println(variable);

  // Example using Serial.flush()
  Serial.print("Send some data...");
  delay(1000);
  Serial.flush(); // Wait for all outgoing data to be transmitted
  Serial.println("Data sent.");

  // Example using Serial.write()
  char dataToSend = 'A';
  Serial.write(dataToSend);

  // Example using Serial.peek()
  if (Serial.available()) {
    // Peek at the next byte without removing it from the buffer
    char nextByte = Serial.peek();

    // Process the next byte
    // (e.g., check if it is a specific character)
    if (nextByte == 'X') {
      // Do something
    }
  }
}

void processReceivedData(char* data) {
  // Process the received data
  // (e.g., perform calculations or send it to another device)
}
```
##### 4. Read Data, Do Something, and Send After

```cpp
void setup() {
  // Initialize UART baud rate
  Serial.begin(9600);
}

void loop() {
  // Check if there is any data available to read from the Serial port
  if (Serial.available()) {
    // Read the data from the Serial port
    char receivedByte = Serial.read();

    // Process the received data
    // (e.g., convert it to uppercase)
    char processedByte = toupper(receivedByte);

    // Send the processed data back to the Serial port
    Serial.print("Processed: ");
    Serial.println(processedByte);
  }
}

```
In this example, the Arduino board reads the data sent from the Serial monitor, processes it (e.g., converts it to uppercase), and sends the processed data back to the Serial port.

#### Использование библиотеки `SoftwareSerial.h`
1.  Чтение и вывод на компьютер:

```cpp
#include <SoftwareSerial.h>

SoftwareSerial mySerial(2, 3); // Установка пинов RX и TX для SoftwareSerial

void setup() {
  Serial.begin(9600); // Настройка стандартного Serial порта на скорость 9600 бит/с
  mySerial.begin(9600); // Настройка SoftwareSerial порта на скорость 9600 бит/с
}

void loop() {
  if (mySerial.available()) { // Проверка наличия данных в SoftwareSerial порту
    char data = mySerial.read(); // Чтение данных из SoftwareSerial порта
    Serial.print("Received: ");
    Serial.println(data); // Вывод данных в стандартный Serial порт
  }
}

```

2.  Передача данных на Arduino:

```cpp
#include <SoftwareSerial.h>

SoftwareSerial mySerial(2, 3); // Установка пинов RX и TX для SoftwareSerial

void setup() {
  Serial.begin(9600); // Настройка стандартного Serial порта на скорость 9600 бит/с
  mySerial.begin(9600); // Настройка SoftwareSerial порта на скорость 9600 бит/с
}

void loop() {
  if (Serial.available()) { // Проверка наличия данных в стандартном Serial порту
    char data = Serial.read(); // Чтение данных из стандартного Serial порта
    mySerial.print("Received: ");
    mySerial.println(data); // Отправка данных в SoftwareSerial порт
  }
}
```
#### [Кольцевой буфер](https://en.wikipedia.org/wiki/Circular_buffer)
[Заметка](https://habr.com/ru/companies/otus/articles/557310/)
```c++
// Circular buffer size
#define BUFFER_SIZE 128

// UART buffer
char uartBuffer[BUFFER_SIZE];
volatile uint8_t uartBufferHead = 0;
volatile uint8_t uartBufferTail = 0;

// UART receive interrupt handler
void uartReceiveISR() {
  // Read the received byte from UART
  char receivedByte = Serial.read();

  // Calculate the next buffer head index
  uint8_t nextHead = (uartBufferHead + 1) % BUFFER_SIZE;

  // Check if the buffer is full
  if (nextHead != uartBufferTail) {
    // Store the received byte in the buffer
    uartBuffer[uartBufferHead] = receivedByte;
    uartBufferHead = nextHead;
  }
}

void setup() {
  // Initialize UART baud rate
  Serial.begin(9600);

  // Set the UART receive interrupt
  Serial.setTimeout(1); // Set a short timeout to trigger receive ISR
  Serial.attachInterrupt(uartReceiveISR);
}

void loop() {
  // Check if there is any data in the buffer
  if (uartBufferTail != uartBufferHead) {
    // Calculate the next buffer tail index
    uint8_t nextTail = (uartBufferTail + 1) % BUFFER_SIZE;

    // Read the next byte from the buffer
    char nextByte = uartBuffer[uartBufferTail];
    uartBufferTail = nextTail;

    // Handle the received byte
    // (e.g., send it to another function for processing)
    processReceivedByte(nextByte);
  }

  // Other code in the main loop
}

void processReceivedByte(char receivedByte) {
  // Process the received byte
  // (e.g., print it to the Serial monitor)
  Serial.print("Received: ");
  Serial.println(receivedByte);
}

```
### I2C

`I2C`(Inter-Integrated Circuits, межмикросхемное соединение) - последовательная ассиметричная шина для связи интегральных схем. Другими словами это протокол синхронной связи. Это значит, что оба устройства, которые обмениваются информацией с помощью данного протокола, должны использовать общий канал синхронизации.

Этот протокол связи был придуман в компании `Phillips`, далее сертифицирован в 2000 годах. Так как многие компании не хотят платить за использование сертифицированного протокола, они используют аналоги с другими названиями, но с таким же принципом. В интернете вы можете увидеть другие названия протокола `I2C`.

Для чего нам эта шина? Чтобы разобраться в этом, давайте посмотрим как она устроена. Как уже говорилось выше, протокол соединяет два устройства двумя линиями, одно устройство будет ведущим а другое ведомым. Так вот, ведомых устройств может быть несколько! Это значит, что мы можем сделать ведущим устройством нашу плату, а к ней через `I2C` подключить несколько датчиков, используя всего два вывода на плате! То есть `I2C` превращает нашу плату в конструктор, к которому мы можем цеплять очень большое количество периферии!

Назначение линий:

- `SCL` - Serial Clock - по этой линии передается общий сигнал синхронизации, который генерируется ведущим устройством

 - `SDA` - Serial Data - по этой линии осуществляется передача данных между ведущим и ведомым

Ведущее устройство также называют `master`, а ведомое - `slave`.

В любой момент времени только ведущее устройство может инициировать процесс обмена данными. При этом, так как ведомых может быть несколько, ведущий должен обращаться к ним по адресам. Соответственно, только ведомый с указанным адресом должен отвечать на сигнал ведущего, а все остальные ведомые должны не реагировать на этот сигнал. По сути, в подключении устройств мы ограничены лишь адресами подключенных устройств. Адресов может быть 127.

Пример кода для использования `I2C`:
#### Пример
##### 1.  Чтение данных с датчика `BMP180`:

```cpp
#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BMP085.h>

Adafruit_BMP085 bmp;

void setup() {
  Serial.begin(9600);
  if (!bmp.begin()) {
    Serial.println("Could not find a valid BMP085 sensor, check wiring!");
    while (1);
  }
}

void loop() {
  float temperature = bmp.readTemperature();
  float pressure = bmp.readPressure() / 100.0;
  float altitude = bmp.readAltitude();

  Serial.print("Temperature: ");
  Serial.print(temperature);
  Serial.println(" *C");
  
  Serial.print("Pressure: ");
  Serial.print(pressure);
  Serial.println(" hPa");
  
  Serial.print("Altitude: ");
  Serial.print(altitude);
  Serial.println(" meters");

  delay(1000);
}

```

##### 2.  Управление дисплеем `LCD` с использованием библиотеки `LiquidCrystal_I2C.h`:

```cpp
#include <Wire.h>
#include <LiquidCrystal_I2C.h>

LiquidCrystal_I2C lcd(0x27, 16, 2); // Установка адреса и размеров дисплея

void setup() {
  lcd.begin(16, 2); // Инициализация дисплея
  lcd.backlight(); // Включение подсветки
  lcd.print("Hello, World!"); // Вывод текста на дисплей
}

void loop() {
  // Дополнительные операции с дисплеем
}
```

### SPI

`SPI` (Serial Peripheral Interface, последовательный периферийный интерфейс) - это синхронный последовательный интерфейс связи между микроконтроллером и другими периферийными устройствами. Он позволяет передавать данные по нескольким линиям одновременно, используя одну линию для синхронизации и отдельные линии для передачи данных.

`SPI` является широко распространенным интерфейсом на многих микроконтроллерах, включая `Arduino Uno`, и используется для связи с различными устройствами, такими как датчики, дисплеи, память и другие периферийные устройства.

Назначение линий:

-   `SCK` (Serial Clock) - линия синхронизации, которая устанавливает тактовую частоту передачи данных между микроконтроллером и периферийным устройством.
-   `MOSI` (Master Out Slave In) - линия передачи данных от микроконтроллера к периферийному устройству.
-   `MISO` (Master In Slave Out) - линия передачи данных от периферийного устройства к микроконтроллеру.
-   `SS` (Slave Select) - линия выбора ведомого устройства, используется для выбора конкретного периферийного устройства в множестве подключенных устройств.

`SPI` поддерживает полный дуплексный режим передачи данных, что означает, что микроконтроллер и периферийное устройство могут передавать данные одновременно в оба направления. Передача данных осуществляется побитово, с настройкой скорости передачи данных.

Основные характеристики `SPI`:

-   Режим передачи данных (`Mode`) - определяет состояние линий синхронизации и передачи данных, которое используется для выполнения передачи данных между микроконтроллером и периферийным устройством.
-   Скорость передачи данных (`bitrate`) - устанавливает скорость передачи данных между микроконтроллером и периферийным устройством.
-   Количество бит в кадре данных (`Bit Order`) - определяет порядок передачи битов данных, либо старший бит (`MSB`) передается первым, либо младший бит (`LSB`) передается первым.

Чтение и запись данных через `SPI` в Arduino Uno осуществляется с помощью библиотеки `SPI` и соответствующих функций, которые предоставляются в ней. Например, функция `SPI.transfer()` используется для передачи и чтения данных по линиям `SPI`.

Пример кода для использования `SPI`:

##### 1.  Запись и считывание данных с SD-карты:

```cpp
#include <SPI.h>
#include <SD.h>

File myFile;

void setup() {
  Serial.begin(9600);
  if (!SD.begin(10)) { // Инициализация SD-карты на пине 10
    Serial.println("No SD card found");
    while (1);
  }
  
  myFile = SD.open("example.txt", FILE_WRITE); // Открытие файла для записи
  if (myFile) {
    myFile.println("Hello, world!"); // Запись данных в файл
    myFile.close(); // Закрытие файла
  }
  
  myFile = SD.open("example.txt"); // Открытие файла для чтения
  if (myFile) {
    while (myFile.available()) {
      Serial.write(myFile.read()); // Чтение данных из файла и вывод в Serial порт
    }
    myFile.close(); // Закрытие файла
  }
}

void loop() {
  // Дополнительные операции с SD-картой
}
```

## Работа с различными сенсорами
### Виды сенсоров

На прошлом занятии мы познакомились с платой `Arduino`, ее средой программирования и получили общие знания об устройстве. Дальше по курсу мы будем углублять знания и каждое занятие будет посвящено отдельным функциям платы или определенным компонентам, принципам их работы. И сегодня мы познакомимся с сенсорами - средствами получения информации об окружающем мире.

Если говорить про `Arduino` с точки зрения IoT, то датчики играют очень важную роль. Так как эта концепция построена на считывании данных, `Arduino` является идеальной средой для прототипирования - подключаемых датчиков много, вплоть до модулей машинного зрения. Поэтому сегодня мы поговорим про сенсоры, какие они бывают, как получают информацию и какие процессы при этом происходят в нашей плате.

Давайте разделим все сенсоры на группы, в зависимости от считываемых данных. Можно выделить несколько групп:

-   **Климатические датчики**: измерение температуры и влажности воздуха, земли, измерение атмосферного давления и прочее.
    
-   **Датчики освещенности**: измерение интенсивности света и другие параметры света.
    
-   **Датчики определения в пространстве**: акселерометр, гироскоп, магнитометр.
    
-   **Датчики механического воздействия**: кнопки, потенциометры и другие элементы для взаимодействия с проектами.
    

Это основные группы, но существует большое количество различных датчиков, и некоторые из них нельзя отнести к какой-то конкретной группе, например, датчики газа.

### Библиотека Wire.h

Для начала давайте познакомимся с основными функциями и операторами библиотеки `Wire.h`. Напишем код, в котором `I2C` совместимый датчик будет ведомым устройством, а мы с платы будем запрашивать с него информацию. Библиотека не требует скачивания, так как по умолчанию добавлена в Arduino IDE.
```c++
#include <Wire.h>
  
int light_address = 29; //адрес нашего устройства
  
void setup() {
	Serial.begin(9600);
}
  
void loop() {
	Wire.beginTransmission(light_address); // начинаем общение с шиной
	Wire.begin();//инициализируем прослушаивание шины
	Wire.write(0);//отправляем ноль, чтобы считать показания с датчика
	Wire.endTransmission();//заканчиваем общение с шиной
	Wire.requestFrom(light_address, 1);//ждем единицу с датчика
	while(Wire.available() == 0);//цикл будет крутиться пока мы не получим информацию
		int c = Wire.read();// полученное значение добавляем в переменную
	Serial.println(c);
	delay(500);
}
```
  
Ведущий инициирует обмен данными. Для этого он генерирует импульсы(всего 9) и посылает их по линии `SCL`. Одновременно на линии `SDA` он выставляет адрес адрес устройства(ведомого), с которым необходимо установить связь. Адрес тактируется первыми семью тактами(отсюда ограничение подключаемых модулей, 2 в 7 степени = 128). Далее идет бит операции - чтение или запись, и бит подтверждения, что ведомое устройство получило запрос. Если бит подтверждения не пришел, обмен заканчивается, или ведущий продолжает посылать запросы.

![](https://lh6.googleusercontent.com/NJ0wn3EW5WLptAW6rEBC9h74yTDoYJoJBrRhoqjyjz9Rve1oP6piTz1Q4HE2SV2cNKWG-zDB_X_fHl1gKLh9f1lN-w7szTSmwerPE5NDO1cvy3bUa5dAIEeZQ9xra3M8dXSzKdGeXWrzDx4w10tsu7U)

  ### Датчик `I2C` VL6180X

Пример с датчиком освещенности и приближения. Обратите внимание, что данный датчик требует подключения дополнительной библиотеки. Используется схема с прошлого занятия, со сдвиговым регистром.

[Datasheet](http://wiki.amperka.ru/_media/%D0%BF%D1%80%D0%BE%D0%B4%D1%83%D0%BA%D1%82%D1%8B:troyka-proximity:dt_vl6180x.pdf)

  

![](https://lh6.googleusercontent.com/xp5FfKEsfX2rmTLEeeUe7DkXtYkZMbegIgY9cyuhVe4AOuTjxJTfO7qdnhxVjQovHCdGXSF7VjIvYJQX1vtM7rXENRvUAVrAw0saAstkZzXTDCoTNQ76_HBcqdgmagjJ49-BGX73NBnNM4ZHs6hjMA)
```c++
#include <Wire.h> //библиотека I2C
#include <SparkFun VL6180X.h> // библиотека для датчика
#define VL6180X_ADDRESS 0x29

VL6180x sensor(VL6180X_ADDRESS); // инициализация датчика
const int SER = 8;
const int LATCH = 9;
const int CLK = 10;
int vs[8] = {1,2,4,8,32,64,128,255};

void setup() {
	Serial.begin(9600);
	while (sensor.VL6180xInit()) {
		Serial.println("Failed to initalize");
		delay(1000);
		}
	sensor.VL6180xDefautSettings(); // загрузка настроек датчика по умолчанию
	delay(1000);
	pinMode(SER, OUTPUT);
	pinMode(LATCH, OUTPUT);
	pinMode(CLK, OUTPUT);
}

void loop() {
	int dist = sensor.getDistance();// метод для измерения расстояния
	dist = map(dist, 0, 200, 0, 8);
	dist = constrain(dist, 0, 8);
	digitalWrite(LATCH, LOW);
	shiftOut(SER, CLK, MSBFIRST, vs[dist]);
	digitalWrite(LATCH, HIGH);
	delay(10);
}
```

### Взаимодействие между двумя платами Arduino

Здесь мы будем использовать две платы Arduino, одна будет ведущим устройством, а вторая - ведомым. Ведущее устройство будет отправлять сообщения ведомому, которое будет выводить их в последовательный монитор порта, для того чтобы убедиться, что все работает.

![](https://lh3.googleusercontent.com/i6zLAPbBJpV51EwObHT-hvUGzL2_kSgb6xvihzl4HZ648g-zHhFff7kWdT-F2ic2flMwPPb_ccuiFFplnXB3bUlUSelKs4AAIUmPny2wyaVCmJ-9bfhKJfA8V6JJcTEcACISXuPh88PoYMaifDJm-w)

Как видите, в данном примере линии шины вынесены на плате под отдельным названием. Если вы используете плату `Arduino UNO`, у вас `SDA` и `SCL` это `A4` и `A5`. Резисторы - 4,7 кОм.

Далее можно открыть примеры скетча для библиотеки Wire, и воспользоваться следующими примерами: master_writer для ведущего устройства, и slave_receiver для ведомого. Ниже вы найдете эти скетчи. Для того, чтобы видеть приходящие сообщения, ведомое устройство мы оставим подключенным к компьютеру, а ведущее - к другому источнику питания.

#### Для ведущего устройства:
```c++
#include <Wire.h>
void setup() {
	Wire.begin(); // подключиться к шине i2c (для ведущего устройства
}
byte x = 0;

void loop() {
	// адрес не указывается)
	Wire.beginTransmission(4); // инициализировать передачу устройству #4
	Wire.write("x is ");
	Wire.write(x);
	Wire.endTransmission();
	x++;
	delay(500);
}
```
#### Для ведомого устройства:
```c++
#include <Wire.h> 

void setup() {
	Wire.begin(4); // подключиться к шине i2c с адресом #4
	Wire.onReceive(receiveEvent); //обработчик события
	Serial.begin(9600); //последовательного порта
}

void loop() {
	delay(100);
}

void receiveEvent(int howMany) {
	while (1 < Wire.available()) { // цикл по всем принятым байтам, кроме последнего
		char c = Wire.read(); // прочитать байт как
		Serial.print(c);// вывести символ
		int x = Wire.read(); целое число // прочитать байт как
		Serial.println(x);// вывести целое число
	}
}
```
Скетч для ведомого устройства использует прерывания для принятия сообщений.

  

### 1-Wire

Шина `1-Wire` служит целям, похожим на цели шины `I2C`, то есть она обеспечивает возможность взаимодействий микроконтроллеров с периферийными устройствами посредством минимального количества линий передачи данных. Стандарт `1-Wire`, разработанный в компании Dallas Semiconductor, свел потребность в линиях до логического минимума — всего одной. Шина имеет более низкое быстродействие, чем `I2C`, но обладает интересной особенностью — паразитным питанием (parasitic power), позволяющее подключать периферийные устройства к микроконтроллеру всего двумя проводами: `GND` (ground — земля) и комбинированным проводом питания и передачи данных.

Шина `1-Wire` поддерживается более узким диапазоном устройств, чем `I2C`. Большинство из них производят компании Dallas Semiconductor и Maxim. К их числу относятся устройства идентификации картриджей для принтеров, флеш-память и ЭСППЗУ, а также `АЦП`. Однако наибольшую популярность среди устройств `1-Wire` у радиолюбителей завоевал температурный датчик `DS18B20` компании Dallas Semiconductor.

`1-Wire` — это именно шина, а не соединение «точка–точка». К ней можно подключить до 255 устройств.

Так же как `I2C`, интерфейс `1-Wire` использует понятия ведущего и ведомого устройств. Микроконтроллер играет роль ведущего, а периферийные устройства — ведомых. Каждое ведомое устройство еще на заводе получает уникальный идентификационный номер, который часто называют адресом, чтобы его можно было идентифицировать на шине, к которой подключено множество ведомых. Адрес имеет размер `64` бита, что позволяет иметь примерно `1,8 × 1019` разных идентификационных номеров.

Подобно `I2C`, протокол `1-Wire` предусматривает переключение режима работы шины ведущим устройством на ввод и вывод, чтобы иметь возможность двусторонних взаимодействий. Однако в шине `1-Wire` отсутствует отдельная линия передачи тактовых сигналов, поэтому нули и единицы передаются длинными и короткими импульсами. Импульс длительностью 60 мкс обозначает 0, а длительностью 15 мкс — 1.

Обычно линия данных находится под напряжением с уровнем `HIGH`, но, когда микроконтроллеру (ведущему) требуется послать команду устройству, он генерирует специальный импульс сброса с уровнем `LOW` длительностью не менее 480 мкс. Вслед за ним следует последовательность импульсов 1 и 0.

#### Сканирование шины

Поскольку каждое ведомое устройство, подключенное к шине, имеет уникальный идентификационный номер, присвоенный на заводе, нужен какой-то способ определить адреса устройств, подключенных к шине. Было бы неблагоразумно «зашивать» адреса устройств в скетч, потому что в случае замены новое ведомое устройство будет иметь уже другой адрес и скетч не сможет обращаться к нему. Поэтому ведущее устройство (`Arduino`) должно создать своеобразную опись устройств на шине. Здесь следует отметить, что первые 8 бит в адресе определяют «семейство», которому принадлежит устройство, то есть по ним можно определить, является ли устройство, например, датчиком DS18B20 или относится к какому-то другому типу.

В библиотеке `OneWire` имеется функция `search`, которую можно использовать для поиска всех ведомых устройств на шине. Следующий пример выводит адреса всех устройств на шине в монитор последовательного порта:
```c++
#include <OneWire.h>

OneWire bus(10); // пин 10 как шина данных
void setup()
{
	Serial.begin(9600);
	byte address[8]; // 64 бита
	while (bus.search(address)) {
		for(int i = 0; i < 7; i++) {
			Serial.print(address[i], HEX);
			Serial.print(" "); 
		}
		// проверить контрольную сумму
		if (OneWire::crc8(address, 7) == address[7]) {
			Serial.println(" CRC OK"); 
			}
		else {
			Serial.println(" CRC FAIL"); 
			}
		}
}

void loop()
{
}
```
#### Пример
```c++
#include <OneWire.h>
#include <DallasTemperature.h>
const int busPin = 10;
OneWire bus(busPin);
DallasTemperature sensors(&bus);
DeviceAddress sensor;

void setup()
{
	Serial.begin(9600); sensors.begin();
	if (!sensors.getAddress(sensor, 0)) 
}

void loop() {
	sensors.requestTemperatures();
	float tempC = sensors.getTempC(sensor);
	Serial.println(tempC);
	delay(1000);

}
```
Этот скетч выводит в окно монитора последовательного порта температуру в градусах Цельсия, прочитанную с единственного датчика температуры
Может произойти такое, что вы не можете найти адрес вашего датчика, или адрес отличается от указанного. Для это есть специальный скетч по поиску адреса у устройства, совместимого с `I2C`. В этом скетче мы просто посылаем запрос на обмен данными на каждый адрес, и в итоге находим тот адрес, который нам отвечает.

```c++
void setup(){
	Wire.begin();
	Serial.begin(9600);
	while (!Serial);
	Serial.println("\nI2C Scanner");
}

void loop(){
	byte error, address;
	int nDevices;
	Serial.println("Scanning...");
	nDevices = 0;
	for(address = 8; address < 127; address++ ){
		Wire.beginTransmission(address);
		error = Wire.endTransmission();
		if (error == 0){
			Serial.print("I2C device found at address 0x");
			if (address<16)
				Serial.print("0");
			Serial.print(address,HEX);
			Serial.println(" !");
			nDevices++;
		}
		else if (error==4) {
			Serial.print("Unknown error at address 0x");
			if (address<16)
				Serial.print("0");
			Serial.println(address,HEX);
		}
	}
	if (nDevices == 0)
		Serial.println("No I2C devices found");
	else
		Serial.println("done");
delay(5000);
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE3NTQ1NzU3NDNdfQ==
-->