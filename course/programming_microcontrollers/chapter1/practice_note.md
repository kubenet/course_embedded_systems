# Курс: Программирование микроконтроллеров
## Структура команд и синтакс языка программирования контроллера Arduino
Для сохранения простоты, были сделаны некоторые
исключения, что улучшает руководство при использовании начинающими в качестве дополнительного источника информации - наряду с другими web-сайтами, книгами, семинарами и классами. Подобное решение, призвано акцентировать внимание на использовании Arduino для автономных задач и, например, исключает более сложное использование массивов или использование
последовательного соединения.
Начиная с описания структуры программы для Arduino на языке C, этот блокнот содержит описание синтаксиса наиболее общих элементов языка и иллюстрирует их использование в примерах и фрагментах кода. Блокнот содержит примеры функций ядра библиотеки Arduino, а в приложении приводятся примеры схем и начальных программ.
## Мотивация
1.  **Практическое применение**: Arduino - это платформа, которая имеет широкое применение в реальных проектах и приложениях. Студенты, изучающие Arduino, могут создавать функциональные устройства и системы, такие как умные дома, роботы, системы автоматизации и другие интересные проекты. Это позволяет студентам увидеть практическое применение своих навыков программирования и электроники, что может быть очень мотивирующим.
    
2.  **Исследование и экспериментирование**: Arduino предоставляет студентам возможность исследовать и экспериментировать с различными аспектами программирования и электроники. Студенты могут создавать свои собственные проекты, тестировать различные идеи и решать реальные проблемы. Это позволяет студентам развивать свою творческую мысль и получать ценный опыт в области исследования.
    
3.  **Универсальность и доступность**: Arduino является доступной и широко используемой платформой, которую можно легко получить и использовать. Это делает Arduino привлекательным выбором для студентов, не имеющих опыта в программировании или электронике. Arduino также поддерживается большим сообществом разработчиков и энтузиастов, что позволяет студентам обмениваться идеями, задавать вопросы и получать поддержку.
4. **Arduino Uno**  контроллер построен на  **ATmega328**  ([техническое описание](http://out.arduino.ru/?redirect=http%3A%2F%2Fwww.atmel.com%2Fdyn%2Fresources%2Fprod_documents%2Fdoc8161.pdf&baseU=https%3A%2F%2Farduino.ru%2FHardware%2FArduinoBoardUno), pdf). Платформа имеет 14 цифровых вход/выходов (6 из которых могут использоваться как выходы ШИМ), 6 аналоговых входов, кварцевый генератор 16 МГц, разъем USB, силовой разъем, разъем ICSP и кнопку перезагрузки. Для работы необходимо подключить платформу к компьютеру посредством кабеля USB, либо подать питание при помощи адаптера AC/DC или батареи.
![enter image description here](https://store.arduino.cc/cdn/shop/products/A000066_03.front_934x700.jpg?v=1629815860)

В отличие от всех плат, использовавших FTDI USB микроконтроллер для связи по USB, новый  **Ардуино Uno**  использует микроконтроллер  **ATmega8U2**  ([техническое описание, pdf](http://out.arduino.ru/?redirect=http%3A%2F%2Fwww.atmel.com%2Fdyn%2Fresources%2Fprod_documents%2Fdoc7799.pdf&baseU=https%3A%2F%2Farduino.ru%2FHardware%2FArduinoBoardUno)).

"Uno" переводится как один с итальянского и разработчики тем самым намекают на грядущий выход Arduino 1.0. Новая плата стала флагманом линейки плат Ардуино. Для сравнения с предыдущими версиями можно обратиться к  [полному списку плат Arduino](https://arduino.ru/Hardware).

## Характеристики
| | |
|--|--|
| Микроконтроллер | ATmega328 |
|Рабочее напряжение| 5 В|
|Входное напряжение (рекомендуемое) | 7-12 В |
|Входное напряжение (предельное)|6-20 В|
|Цифровые Входы/Выходы|14 (6 из которых могут использоваться как выходы  [ШИМ](https://arduino.ru/Tutorial/PWM))|
|Аналоговые входы|6|
|Постоянный ток через вход/выход|40 мА|
|Постоянный ток для вывода 3.3 В|50 мА|
|Флеш-память|32 Кб (ATmega328) из которых 0.5 Кб используются для загрузчика|
|ОЗУ|2 Кб (ATmega328)|
|EEPROM|1 Кб (ATmega328)|
|Тактовая частота|16 МГц|
## Схема и исходные данные

Файлы EAGLE:  [arduino-duemilanove-reference-design.zip](https://arduino.ru/Schematic/arduino-uno-reference-design.zip)

Принципиальная схема:  [arduino-duemilanove-schematic.pdf](https://arduino.ru/Schematic/arduino-uno-schematic.pdf)

## Питание

**Arduino Uno**  может получать питание через подключение USB или от внешнего источника питания. Источник питания выбирается автоматически.

Внешнее питание (не USB) может подаваться через преобразователь напряжения AC/DC (блок питания) или аккумуляторной батареей. Преобразователь напряжения подключается посредством разъема 2.1 мм с центральным положительным полюсом. Провода от батареи подключаются к выводам Gnd и Vin разъема питания.

Платформа может работать при внешнем питании от 6 В до 20 В. При напряжении питания ниже 7 В, вывод 5V может выдавать менее 5 В, при этом платформа может работать нестабильно. При использовании напряжения выше 12 В регулятор напряжения может перегреться и повредить плату. Рекомендуемый диапазон от 7 В до 12 В.

Выводы питания:

-   **VIN**. Вход используется для подачи питания от внешнего источника (в отсутствие 5 В от разъема USB или другого регулируемого источника питания). Подача напряжения питания происходит через данный вывод.
-   **5V**. Регулируемый источник напряжения, используемый для питания микроконтроллера и компонентов на плате. Питание может подаваться от вывода VIN через регулятор напряжения, или от разъема USB, или другого регулируемого источника напряжения 5 В.
-   **3V3**. Напряжение на выводе 3.3 В генерируемое встроенным регулятором на плате. Максимальное потребление тока 50 мА.
-   **GND**. Выводы заземления.

## Память

Микроконтроллер ATmega328 располагает 32 кБ флэш памяти, из которых 0.5 кБ используется для хранения загрузчика, а также 2 кБ ОЗУ (SRAM) и 1 Кб EEPROM.(которая читается и записывается с помощью  [библиотеки EEPROM](https://arduino.ru/Reference/Library/EERPOM)).

##  Входы и Выходы

Каждый из 14 цифровых выводов Uno может настроен как вход или выход, используя функции [pinMode()](https://arduino.ru/Reference/PinMode),  [digitalWrite()](https://arduino.ru/Reference/DigitalWrite), и  [digitalRead()](https://arduino.ru/Reference/DigitalRead), . Выводы работают при напряжении 5 В. Каждый вывод имеет нагрузочный резистор (по умолчанию отключен) 20-50 кОм и может пропускать до 40 мА. Некоторые выводы имеют особые функции:

-   **Последовательная шина: 0 (RX) и 1 (TX)**. Выводы используются для получения (RX) и передачи (TX) данных TTL. Данные выводы подключены к соответствующим выводам микросхемы последовательной шины ATmega8U2 USB-to-TTL.
-   **Внешнее прерывание: 2 и 3**. Данные выводы могут быть сконфигурированы на вызов прерывания либо на младшем значении, либо на переднем или заднем фронте, или при изменении значения. Подробная информация находится в описании функции  [attachInterrupt()](https://arduino.ru/Reference/AttachInterrupt).
-   **ШИМ: 3, 5, 6, 9, 10, и 11.**  Любой из выводов обеспечивает  [ШИМ](https://arduino.ru/Tutorial/PWM)  с разрешением 8 бит при помощи функции  [analogWrite()](https://arduino.ru/Reference/AnalogWrite).
-   **SPI: 10 (SS), 11 (MOSI), 12 (MISO), 13 (SCK).** Посредством данных выводов осуществляется связь SPI, для чего используется  [библиотека SPI](https://arduino.ru/Reference/Library/SPI).
-   **LED: 13.** Встроенный светодиод, подключенный к цифровому выводу 13. Если значение на выводе имеет высокий потенциал, то светодиод горит.

На платформе Uno установлены 6 аналоговых входов (обозначенных как A0 .. A5), каждый разрешением 10 бит (т.е. может принимать 1024 различных значения). Стандартно выводы имеют диапазон измерения до 5 В относительно земли, тем не менее имеется возможность изменить верхний предел посредством вывода AREF и функции  [analogReference()](https://arduino.ru/Reference/AnalogReference). Некоторые выводы имеют дополнительные функции:

-   **I2C: 4 (SDA) и 5 (SCL).**  Посредством выводов осуществляется связь I2C (TWI), для создания которой используется  [библиотека Wire.](http://out.arduino.ru/?redirect=http%3A%2F%2Farduino.cc%2Fen%2FReference%2FWire&baseU=https%3A%2F%2Farduino.ru%2FHardware%2FArduinoBoardUno)

Дополнительная пара выводов платформы:

-   **AREF.**  Опорное напряжение для аналоговых входов. Используется с функцией  [analogReference()](https://arduino.ru/Reference/AnalogReference).
-   **Reset.** Низкий уровень сигнала на выводе перезагружает микроконтроллер. Обычно применяется для подключения кнопки перезагрузки на плате расширения, закрывающей доступ к кнопке на самой плате Arduino.

Обратите внимание на соединение между выводами  [Arduino и портами ATmega328](https://arduino.ru/Hardware/ATMega168pins).

## Связь

На платформе  **Arduino Uno**  установлено несколько устройств для осуществления связи с компьютером, другими устройствами Arduino или микроконтроллерами. ATmega328 поддерживают последовательный интерфейс UART TTL (5 В), осуществляемый выводами 0 (RX) и 1 (TX). Установленная на плате микросхема ATmega8U2 направляет данный интерфейс через USB, программы на стороне компьютера "общаются" с платой через виртуальный COM порт. Прошивка ATmega8U2 использует стандартные драйвера USB COM, никаких стороних драйверов не требуется, но на Windows для подключения потребуется файл ArduinoUNO.inf. Мониторинг последовательной шины (Serial Monitor) программы Arduino позволяет посылать и получать текстовые данные при подключении к платформе. Светодиоды RX и TX на платформе будут мигать при передаче данных через микросхему FTDI или USB подключение (но не при использовании последовательной передачи через выводы 0 и 1).

Библиотекой SoftwareSerial возможно создать последовательную передачу данных через любой из цифровых выводов Uno.

ATmega328 поддерживает интерфейсы I2C (TWI) и SPI. В Arduino включена библиотека Wire для удобства использования шины I2C.

## Программирование

Платформа программируется посредством ПО Arduino. Из меню **Tools > Board**  выбирается «Arduino Uno» (согласно установленному микроконтроллеру). Подробная информация находится в  [справочнике](https://arduino.ru/Reference)  и  [инструкциях](https://arduino.ru/Arduino_environment).

Микроконтроллер ATmega328 поставляется с записанным загрузчиком, облегчающим запись новых программ без использования внешних программаторов. Связь осуществляется оригинальным протоколом STK500.

Имеется возможность не использовать загрузчик и запрограммировать микроконтроллер через выводы ICSP (внутрисхемное программирование). Подробная информация находится в  [данной инструкции](http://out.arduino.ru/?redirect=http%3A%2F%2Farduino.cc%2Fen%2FHacking%2FProgrammer&baseU=https%3A%2F%2Farduino.ru%2FHardware%2FArduinoBoardUno).

## Автоматическая (программная) перезагрузка

**Uno**  разработана таким образом, чтобы перед записью нового кода перезагрузка осуществлялась самой программой Arduino на компьютере, а не нажатием кнопки на платформе. Одна из линий DTR микросхемы ATmega8U2, управляющих потоком данных (DTR), подключена к выводу перезагрузки микроконтроллеру ATmega328 через 100 нФ конденсатор. Активация данной линии, т.е. подача сигнала низкого уровня, перезагружает микроконтроллер. Программа Arduino, используя данную функцию, загружает код одним нажатием кнопки Upload в самой среде программирования. Подача сигнала низкого уровня по линии DTR скоординирована с началом записи кода, что сокращает таймаут загрузчика.

Функция имеет еще одно применение. Перезагрузка Uno происходит каждый раз при подключении к программе Arduino на компьютере с ОС Mac X или Linux (через USB). Следующие полсекунды после перезагрузки работает загрузчик. Во время программирования происходит задержка нескольких первых байтов кода во избежание получения платформой некорректных данных (всех, кроме кода новой программы). Если производится разовая отладка скетча, записанного в платформу, или ввод каких-либо других данных при первом запуске, необходимо убедиться, что программа на компьютере ожидает в течение секунды перед передачей данных.

На Uno имеется возможность отключить линию автоматической перезагрузки разрывом соответствующей линии. Контакты микросхем с обоих концов линии могут быть соединены с целью восстановления. Линия маркирована «RESET-EN». Отключить автоматическую перезагрузку также возможно подключив резистор 110 Ом между источником 5 В и данной линией.

## Токовая защита разъема USB

В  **Arduino Uno**  встроен самовостанавливающийся предохранитель (автомат), защищающий порт USB компьютера от токов короткого замыкания и сверхтоков. Хотя практически все компьютеры имеют подобную защиту, тем не менее, данный предохранитель обеспечивает дополнительный барьер. Предохранитель срабатыват при прохождении тока более 500 мА через USB порт и размыкает цепь до тех пока нормальные значения токов не будут востановлены.

## Средства разработки
### Arduino IDE

Программа, написанная в среде Arduino, называется скетч. Скетч пишется в текстовом редакторе, имеющем инструменты вырезки/вставки, поиска/замены текста. Во время сохранения и экспорта проекта в области сообщений появляются пояснения, также могут отображаться возникшие ошибки. Окно вывода текста(консоль) показывает сообщения Arduino, включающие полные отчеты об ошибках и другую информацию. Кнопки панели инструментов позволяют проверить и записать программу, создать, открыть и сохранить скетч, открыть мониторинг последовательной шины:

![компиляция кода](https://arduino.ru/sites/default/files/aruino_environment/play.gif)_Verify/Compile_  
Проверка программного кода на ошибки, компиляция.

![остановка мониторинга](https://arduino.ru/sites/default/files/aruino_environment/stop.gif)_Stop_  
Остановка мониторинга последовательной шины(Serial monitor) или затемнение других кнопок.

[![создание нового скетча](https://arduino.ru/sites/default/files/resize/aruino_environment/new-23x23.gif)](https://arduino.ru/sites/default/files/aruino_environment/new.gif)_New_  
Создание нового скетча.

[![открыть файл скетча](https://arduino.ru/sites/default/files/resize/aruino_environment/open-23x23.gif)](https://arduino.ru/sites/default/files/aruino_environment/open.gif)_Open_  
Открытие меню доступа ко всем скетчам в блокноте. Открывается нажатием в текущем окне.

_Примечание_: из-за наличия ошибки в Java данное меню не может прокручиваться; при необходимости открыть скетч из этого списка проследуйте в меню File | Sketchbook.

[![сохранение скетча](https://arduino.ru/sites/default/files/resize/aruino_environment/save-23x23.gif)](https://arduino.ru/sites/default/files/aruino_environment/save.gif)_Save_  
Сохранение скетча.

[![загрузка скетча в контроллер](https://arduino.ru/sites/default/files/resize/aruino_environment/export-23x23.gif)](https://arduino.ru/sites/default/files/aruino_environment/export.gif)_Upload to I/O Board_  
Компилирует программный код и загружает его в устройство Arduino. Описание загрузки приведено ниже.

[![Serial monitor](https://arduino.ru/sites/default/files/resize/aruino_environment/serial_monitor-23x23.gif)](https://arduino.ru/sites/default/files/aruino_environment/serial_monitor.gif)_Serial Monitor_  
Открытие мониторинга последовательной шины (Serial monitor).

Дополнительные команды сгруппированы в пять меню: File, Edit, Sketch, Tools, Help. Доступность меню определяется работой, выполняемой в данный момент.

**Edit**

-   _Copy for Discourse_  
    Копирует в буфер обмена подходящий для размещения на форуме код скетча с выделением синтаксиса.

-   _Copy as HTML_  
    Копирует код скетча в буфер обмена как HTML код, для размещения на веб-страницах.

**Sketch**

-   _Verify/Compile_  
    Проверка скетча на ошибки.

-   _Import Library_  
    Добавляет библиотеку в текущий скетч, вставляя директиву #include в код скетча. Подробная информация в описании библиотек ниже (Libraries).

-   _Show Sketch Folder_  
    Открывает папку, содержащую файл скетча, на рабочем столе.

-   _Add File..._  
    Добавляет файл в скетч (файл будет скопирован из текущего места расположения). Новый файл появляется в новой закладке в окне скетча. Файл может быть удален из скетча при помощи меню закладок.

**Tools**

-   _Auto Format_  
    Данная опция оптимизирует код, например, выстраивает в одну линию по вертикали открывающую и закрывающую скобки и помещает между ними утверждение.

-   _Board_  
    Выбор используемой платформы. Список с описанием платформ приводится ниже.

-   Serial Port  
    Меню содержит список последовательных устройств передачи данных (реальных и виртуальных) на компьютере. Список обновляется автоматически каждый раз при открытии меню Tools.

-   _Burn Bootloader_  
    Пункты данного меню позволяют записать Загрузчик (Bootloader) в микроконтроллер на платформе Arduino. Данное действие не требуется в текущей работе с Arduino, но пригодится, если имеется новый ATmega (без загрузчика). Перед записью рекомендуется проверить правильность выбора платформы из меню. При использовании AVR ISP необходимо выбрать соответствующий программатору порт из меню Serial Port.

#### Блокнот (Sketchbook)

Средой Arduino используется принцип блокнота: стандартное место для хранения программ (скетчей). Скетчи из блокнота открываются через меню File > Sketchbook или кнопкой Open на панели инструментов. При первом запуске программы Arduino автоматически создается директория для блокнота. Расположение блокнота меняется через диалоговое окно Preferences.

#### Закладки, Файлы и Компиляция

Позволяют работать с несколькими файлами скетчей (каждый открывается в отдельной закладке). Файлы кода могут быть стандартными Arduino (без расширения), файлами С (расширение *.с), файлами С++ (*.срр) или головными файлами (.h).

#### Загрузка скетча в Arduino

Перед загрузкой скетча требуется задать необходимые параметры в меню  **Tools > Board** и  **Tools > Serial Port**. Платформы описываются далее по тексту. В ОС Mac последовательный порт может обозначаться как dev/tty.usbserial-1B1 (для платы USB) или /dev/tty.USA19QW1b1P1.1 (для платы последовательной шины, подключенной через адаптер Keyspan USB-to-Serial). В ОС Windows порты могут обозначаться как COM1 или COM2 (для платы последовательной шины) или COM4, COM5, COM7 и выше (для платы USB). Определение порта USB производится в поле Последовательной шины USB Диспетчера устройств Windows. В ОС Linux порты могут обозначаться как /dev/ttyUSB0, /dev/ttyUSB1.

После выбора порта и платформы необходимо нажать кнопку загрузки на панели инструментов или выбрать пункт меню File > Upload to I/O Board. Современные платформы Arduino перезагружаются автоматически перед загрузкой. На старых платформах необходимо нажать кнопку перезагрузки. На большинстве плат во время процесса будут мигать светодиоды RX и TX. Среда разработки Arduino выведет сообщение об окончании загрузки или об ошибках.

При загрузке скетча используется Загрузчик (Bootloader) Arduino, небольшая программа, загружаемая в микроконтроллер на плате. Она позволяет загружать программный код без использования дополнительных аппаратных средств. Загрузчик (Bootloader) активен в течении нескольких секунд при перезагрузке платформы и при загрузке любого из скетчей в микроконтроллер. Работа Загрузчика (Bootloader) распознается по миганию светодиода (13 пин) (напр.: при перезагрузке платы).

#### Библиотеки

Библиотеки добавляют дополнительную функциональность скетчам, например, при работе с аппаратной частью или при обработке данных. Для использования библиотеки необходимо выбрать меню  **Sketch > Import Library**. Одна или несколько директив  **#include**  будут размещены в начале кода скетча с последующей компиляцией библиотек и вместе со скетчем. Загрузка библиотек требует дополнительного места в памяти Arduino. Неиспользуемые библиотеки можно удалить из скетча убрав директиву  **#include**.

На Arduino.cc имеется  [список библиотек](http://out.arduino.ru/?redirect=http%3A%2F%2Farduino.cc%2Fen%2FReference%2FLibraries&baseU=https%3A%2F%2Farduino.ru%2FArduino_environment "список библиотек для Ардуино"). Некоторые библиотеки включены в среду разработки Arduino. Другие могут быть загружены с различных ресурсов. Для установки скачанных библиотек необходимо создать директорию «libraries» в папке блокнота и затем распаковать архив. Например, для установки библиотеки DateTime ее файлы должны находится в подпапке  **/libraries/DateTime**  папки блокнота.

Смотрите  [данную инструкцию](http://out.arduino.ru/?redirect=http%3A%2F%2Farduino.cc%2Fen%2FHacking%2FLibraryTutorial&baseU=https%3A%2F%2Farduino.ru%2FArduino_environment "написание библиотек")  для написания собственной библиотеки.

#### Аппаратные средства других разработчиков

Поддерживаемые аппаратные средства других производителей добавляются в соответствующую подпапку папки блокнота. Устанавливаемые платформы могут включать собственные характеристики (в меню платформы), корневые библиотеки, загрузчик(Bootloader) и характеристики программатора. Для установки требуется распаковать архив в созданную папку. (Запрещено использовать наименование папки "arduino", т.к. могут быть перезаписаны встроенные данные платформы Arduino.) Для деинсталляции данных удаляется соответствующая директория.

Подробная информация по созданию сборок описаний аппаратных средств других производителей находится на  [страницах сайта Google Code](http://out.arduino.ru/?redirect=https%3A%2F%2Fcode.google.com%2Fp%2Farduino%2Fwiki%2FPlatforms&baseU=https%3A%2F%2Farduino.ru%2FArduino_environment "создание сборок аппартных средств").

#### Мониторинг последовательной шины (Serial Monitor)

Отображает данные посылаемые в платформу Arduino (плата USB или плата последовательной шины). Для отправки данных необходимо ввести текст и нажать кнопку Send или Enter. Затем выбирается скорость передачи из выпадающего списка, соответствующая значению  **Serial.begin**  в скетче. На ОС Mac или Linux платформа Arduino будет перезагружена (скетч начнется сначала) при подключении мониторинга последовательной шины.

Имеется возможность обмена информацией с платформой через программы Processing, Flash, MaxMSP и т.д. (см. подробности на странице описаний интерфейсов).

#### Настройки
Некоторые настройки изменяются в окне  **Preferences**  (меню Arduino в ОС Mac или File в ОС Windows и Linux). Остальные настройки находятся в файле, месторасположение которого указано в окне Preferences.

### ThinkerCAD
[ThinkerCAD](https://www.tinkercad.com/) – это онлайн-среда моделирования, позволяющая создавать и тестировать различные электрические схемы без необходимости использования физических компонентов. Это мощный инструмент, который дает возможность разработчикам и электронным инженерам собирать, тестировать и отлаживать схемы, используя виртуальные компоненты и программное обеспечение Arduino.

Один из наиболее популярных применений ThinkerCAD - моделирование работы Arduino. С его помощью можно создавать виртуальные прототипы устройств, создавать алгоритмы и проверять их работоспособность до начала физической реализации проекта. Это позволяет сэкономить время и ресурсы, а также производить быструю отладку и исправление ошибок.
С использованием ThinkerCAD вы можете создавать различные электрические схемы, начиная от базовых, таких как соединение резисторов и светодиодов, до более сложных, включающих микроконтроллеры, датчики и другие электронные компоненты. Программа предлагает широкий спектр оригинальных компонентов, которые можно просто перетащить и разместить на виртуальной плате для создания схемы. В основном окне можно производить сборку схемы из существующих в библиотеке компонентов.
ThinkerCAD также предоставляет возможность программировать микроконтроллеры, такие как Arduino, используя встроенный визуальный инструмент для кодирования. С помощью этого инструмента вы можете создавать скрипты и алгоритмы для контроля и взаимодействия с подключенными компонентами вашей схемы. Визуальное программирование гарантирует простоту использования и позволяет вам сразу же видеть результаты своей работы.

![enter image description here](https://ampermarket.kz/images/tinkercad_inst_5.png)

### Wokwi
[Wokwi](https://wokwi.com/) – это онлайн-симулятор для плат Arduino, Raspberry Pi Pico и ESP32 или даже вашей собственной платы микроконтроллера, предназначенный для изучения программирования без реального оборудования. Wokwi предлагает удобный и интуитивно понятный интерфейс, который позволяет быстро создавать и собирать схемы, а также программировать различные контроллеры, включая Arduino и другие популярные микроконтроллеры.
#### Возможности Wokwi

-   Над микроконтроллерными проектами можно работать прямо из браузера, аппаратные компоненты не нужны.
-   Wokwi имитирует основные платы для прототипирования: Arduino, ESP32 DevKit, Raspberry Pi Pico и другие.
-   Смоделированный проект можно подключить к интернету через MQTT, HTTP, NTP и другиепротоколы.
-   Через встроенный визуальный логический анализатор можно захватить цифровые сигналы в моделировании (например, UART, I2C, SPI) и проанализировать их на своём компьютере.
-   Для прошаренных пользователей есть функция расширенной отладки через GDB и возможность моделирования SD-карты. Код можно сразу запустить в исполнение или внести правки.
-   В сервисе есть огромная база готовых стартовых проектов, где можно посмотреть всё — вплоть до кода с комментариями и описаниями разработчиков.

[![](https://blog.themarfa.name/content/images/2022/09/image-45.png)](https://blog.themarfa.name/content/images/2022/09/image-45.png)

Одной из главных особенностей Wokwi является возможность моделирования и программирования Arduino. С его помощью вы можете создавать виртуальные прототипы устройств, разрабатывать и отлаживать программы и алгоритмы, а также тестировать и проверять работоспособность проектов до их физической реализации. Это не только экономит время и ресурсы, но и позволяет быстро исправлять ошибки и оптимизировать свои проекты. Слева - текстовый редактор, где можно работать с файлами программы(и не только), а справа - непосредственно поле симулятора. Сейчас там только базовая плата. Для того что бы добавить какой-либо элемент необходимо нажать на кнопку "+" и откроется выпадающий список элементов. Wokwi предлагает широкий спектр компонентов, которые можно использовать для создания электронных схем. С его помощью вы можете соединять различные элементы, такие как резисторы, светодиоды, конденсаторы, микроконтроллеры и другие, для создания электрических цепей. Интерфейс Wokwi интуитивно понятен и позволяет легко перемещать и подключать компоненты, а также настраивать их свойства.
И действительно, нам прислали представленный ниже скриншот вместе с размытым видео, показывающим, как светодиодный дисплей обновляется по мере запуска программы в веб-браузере.


![ESP32 MicroPython Simulator](https://cnx-software.ru/wp-content/uploads/2023/04/esp32-micropython-simulator-1024x576.jpg)

Учитывая низкую стоимость плат ESP32 и необходимость в использовании внешних модулей или макетных плат для создания проектов, эмуляторы для данного типа плат не являются необходимостью. 

Следовательно, это может объяснить популярность  [Wokwi](https://wokwi.com/), которая представляет собой отличную платформу для обучения, поддерживающую несколько плат Arduino (Uno, Mega, Nano), Raspberry Pi Pico и универсальную плату ESP32, программированные как на Arduino, так и на MicroPython.

![Wokwi Arduino and Raspberry Pi Pico](https://cnx-software.ru/wp-content/uploads/2023/04/wokwi-arduino-raspberry-pi-pico.png)

Также возможно добавление  [пользовательских плат](https://github.com/wokwi/wokwi-boards), чтобы не ограничиваться официально поддерживаемыми платами. Пользователи могут начинать свои проекты с нуля, выбирая только плату, добавляя компоненты и создавая код самостоятельно, либо использовать существующие проекты, например, проект датчика температуры и влажности ESP32 + DHT22.

![Wokwi ESP32 Simulator](https://cnx-software.ru/wp-content/uploads/2023/04/wokwi-esp32-simulator-1024x731.png)

Доступно графическое представление Arduino, и для запуска моделирования необходимо нажать зеленую кнопку. Результаты температуры и влажности отображаются в виртуальной последовательной консоли.

Также можно добавлять дополнительные компоненты, такие как светодиоды, потенциометры, кнопки, датчики, VCC, GND и другие. Диаграмма также доступна в исходном коде в формате JSON.

![Диаграмма и компоненты в Wokwi](https://cnx-software.ru/wp-content/uploads/2023/04/wokwi-add-components-1024x731.png)

Wokwi предоставляет бесплатные возможности использования, но также доступна  [платная программа Wokwi Club](https://docs.wokwi.com/getting-started/wokwi-club), предлагающая членам возможности, такие как добавление библиотек Arduino, загрузка пользовательских двоичных файлов, подключение к Wi-Fi ESP32 и сохранение проектов в приватном режиме. Участники также могут принимать участие в голосовании за новые функции Wokwi.
## Структура программы 
Базовая структура программы для Arduino довольно проста и состоит, по меньшей мере, из двух частей. В этих двух обязательных частях, или функциях, заключён выполняемый код.
~~~ c++
void setup()
{
	// подготовка
}

void loop()
{
	// выполнение
}
~~~

Перед функцией `setup` - в самом начале программы, обычно, идёт, объявление всех переменных. `setup` - это первая функция, выполняемая программой, и выполняемая только один раз, поэтому она используется для установки режима работы портов `(pinMode())` или инициализации последовательного соединения. Следующая функция `loop` содержит код, который выполняется постоянно — читаются входы, переключаются выходы и т.д. Эта функция — ядро всех программ Arduino и выполняет основную работу.
### `setup()`
Функция `setup()` вызывается один раз, когда программа стартует. Используйте её для установки режима выводов или инициализации последовательного соединения. Она должна быть включена в программу, даже если в ней нет никакого содержания.
```c++
void setup()
{
	pinMode(pin, OUTPUT); // устанавливает пин как выход
}
```
### `loop()`
После вызова функции `setup()` – управление переходит к функции `loop()` , которая делает в точности то, что означает её имя — непрерывно выполняется, позволяя.
```c++
void loop()
{
	digitalWrite(pin, HIGH);
	delay(1000);
	digitalWrite(pin, LOW);
	delay(1000);
}
```
### Комментарии
#### `/*` ... `*/` блок комментария
Блок комментария или однострочный комментарий — это область текста, которая
игнорируется программой и используется для добавления текста с описанием кода
или примечаний. Комментарий помогают другим понять эту часть программы. Он
начинается с `/*` и заканчивается `*/` и может содержать множество строк.

Поскольку комментарии игнорируются программой, а, следовательно, не занимают места в памяти, они могут быть достаточно ёмкими, но кроме того, они
могут использоваться для «пометки» блоков кода с отладочной целью.

**Примечание**: Хотя допускается вставка однострочного комментария в блоке
комментария, второй блок комментария не допускается.

#### `//`однострочный комментарий
Однострочный комментарий начинается с `//` и заканчивается (внутренним) кодом перехода на другую строку. Как и блок комментария, он игнорируется программой и не занимает места в памяти.
`//` вот так выглядит однострочный комментарий
Однострочный комментарий часто используется после действенного выражения, чтобы дать больше информации о том, что выражение выполняет или в качестве напоминания на будущее.
 
1. Комментарии помещаются прямо над кодом**, к которому они относятся. Так проще понять, о чём речь, не вникая в содержание каждой строчки. Совсем короткие пояснения можно писать справа.
```
# определяем общую структуру товара со значениями по умолчанию
product = { 
   "productId": 0, # идентификатор товара, по умолчанию: 0
	"description": "", # описание товара, по умолчанию: пусто
	"categoryId": 0, # категория товара, по умолчанию: 0
	"цена": 0,00 # цена, по умолчанию: 0,00
}
```

2. Комментируют все основные элементы кода:**  модули, функции, константы, глобальные переменные, интерфейсы, классы и их составные элементы (методы, свойства, константы).

3. Пишут коротко и по делу.**  Комментарии без смысловой нагрузки страшно раздражают. Не нужно писать комментарии типа «это гениальный код», «таблица1», «! №; %:? *» и подобные.

>«Опиши комментариями структуру кода». На примере кода программы, складывающей два числа, этот принцип будет выглядеть так:  
```c++
int main()
{
     // Принять от пользователя два числа
     // Завести переменную для результата сложения
     // Вернуть результат сложения

     return 0;
}
``` 
> И лишь когда готов каркас из комментариев, следует писать код который будет реализовывать то, что описано комментариями.  
```c++
int main()
{
     double a,b;
     // Принять от пользователя два числа
     cin>>a;
     cin>>b;
     //Завести переменную для результата сложения
     double sum = a+b;
     // Вернуть результат сложения
     cout<<sum;

     return 0;
}
```
### Функции
Функция — это блок кода, имеющего имя, которое указывает на исполняемый код, который выполняется при вызове функции. Функции `void setup()` и `void loop()` уже обсуждались, а другие встроенные функции будут рассмотрены позже.
Могут быть написаны различные пользовательские функции, для выполнения повторяющихся задач и уменьшения беспорядка в программе. При создании
функции, первым делом, указывается тип функции. Это тип значения, возвращаемого функцией, такой как `int` для целого (integer) типа функции. Если функция не возвращает значения, её тип должен быть `void`. За типом функции следует её имя, а в скобках параметры, передаваемые в функцию.
```c++
type functionName(parameters)
{
	// сделать что то
}
```
Следующая функция целого типа `delayVal()` используется для задания значения паузы в программе чтением значения с потенциометра. Вначале объявляется локальная переменная `v`, затем `v` устанавливается в значение потенциометра, определяемое числом между  `0 — 1023`, затем это значение делится на `4`, чтобы результирующее значение было между `0` и `255`, а затем это значение возвращается в основную программу.
```c++
int delayVal()
{
	int v; //Создаение локальной переменной
	v = analogRead(pin); // считывание значения 
	v /= 4; // конвертируем из 0 - 1023 в 0 - 255
	return v; // возвращаем полученное число
}
```
### `#include` 
Директива, позволяющая подключать в проект дополнительные файлы с кодом.
```c++
#include <Servo.h>  // подключает библиотеку Servo.h
#include "Servo.h"  // подключает библиотеку Servo.h
```
В чём отличие **<>** и **“”**? Когда указываем название **“в кавычках”**, компилятор сначала ищет файл в папке со скетчем, а затем в папке с библиотеками. При использовании **<галочек>** компилятор ищет файл только в папке с библиотеками
### `#define`
Директива, дающая команду препроцессору заменить указанное название на указанное значение. Чаще всего таким образом объявляют константы:
```c++
#define MOTOR_PIN 10 // пин мотора 10
#define LED_PIN 3 // пин светодиода 3
```
После компиляции все встречающиеся в тексте программы слова MOTOR_PIN будут заменены на цифру 10, а LED_PIN – на цифру 3. Такой способ хранения констант **не использует оперативную память микроконтроллера**. Также define позволяет делать т.н. макро функции. Например Ардуиновская функция **sq** (квадрат) является макро, который при компиляции превращается в умножение:
```c++
#define sq(x) ((x)*(x))
```
### `#if`, `#elif`, `#else`, `#endif`
Директивы препроцессору, позволяющие включать или исключать участки кода по условию
```c++
#define TEST 1    // определяем TEST как 1

#if (TEST == 1)   // если TEST 1
#define VALUE 10  // определить VALUE как 10
#elif (TEST == 0) // TEST 0
#define VALUE 20  // определить VALUE как 20
#else             // если нет
#define VALUE 30  // определить VALUE как 30
#endif            // конец условия
```
При помощи условной компиляции очень удобно собирать и настраивать сложные проекты с кучей настроек и библиотек, подключаемых “по условию”. Например:
```c++
#define DEBUG 1
void  setup()  {
#if (DEBUG == 1)
Serial.begin(9600);
Serial.println("Hello!");
#endif
}
```
Если параметру DEBUG установить 1, то будет подключена библиотека Serial, если 0 – то нет. Таким образом получаем универсальный оптимизированный проект с отладкой
### `#ifdef`, `#ifndef`
Условные директивы препроцессору, позволяют включать или исключать участки кода по условию: **ifdef** – определено ли? **ifndef** – не определено ли?
```c++
#define TEST      // определяем TEST 

#ifdef TEST       // если TEST определено 
#define VALUE 10  // определить VALUE как 10 
#else             // если закоммент. #define TEST
#define VALUE 20  // определить VALUE как 20 
#endif            // конец условия
```
### Условия
```c++
// при выполнения одного действия {} необязательны
if  (a > b) c = 10; // если a больше b, то c = 10
else c = 20; // если нет, то с = 20

// вместо сравнения можно использовать лог. переменную
boolean myFlag, myFlag2;
if  (myFlag) c = 10;
// сложные условия
if  (myflag && myFlag2) c = 10; // если оба флага true
// при выполнении двух и более {} обязательны
if  (myFlag)  {
	с = 10;
	b = c;
}  else  {
	с = 20;
	b = a;
}

byte buttonState;

if  (buttonState == 1) a = 10; // если buttonState 1
else  if  (buttonState == 2) a = 20; // если нет, но если buttonState 2
else a = 30; // если и это не верно, то вот
```
Укороченная запись условия:  **(логика) ? правда : ложь**.
```c++
int с = (a > b) ? 10 : -20; // если a > b, то с = 10. Если нет, то с = -20
boolean flag = true;
Serial.println(  (flag) ? ("флаг поднят") : ("флаг опущен")  );```
```
Оператор выбора, заменяет конструкцию с  **else if**.
```c++
switch  (val)  {
	case 1:
		// выполнить, если val == 1
	break;
	case 2:
		// выполнить, если val == 2
	break;
	default:
		// выполнить, если val ни 1 ни 2
		// default опционален
	break;
}
```
### Циклы
#### `for`
Конструкция `for` используется для повторения **блока** выражений, заключённых в фигурные скобки заданное число раз. Наращиваемый счётчик часто используется для увеличения и прекращения цикла. Есть три части, разделённые точкой с запятой, в заголовке цикла for:
```c++
for(инициализация; условие; выражение){
	doSomthing;
}
```
**Инициализация** локальной переменной, или счётчика, имеет место в самом начале и происходит только один раз. При каждом проходе цикла  роверяется **условие**. Если условие остаётся истинным, то следующее **выражение** и **блок** выполняются, а условие проверяется вновь. Когда условие становится ложным, цикл завершается.
```c++
for(int i = 0; i < 10; i++){
	digitalWrite(13, HIGH);
	delay(250);
	digitalWrite(13, LOW);
	delay(250);
}
```
#### `while`
Цикл `while` продолжается, и может продолжаться бесконечно, пока выражение в скобках не станет `false` (ложно). Что-то должно менять проверяемую переменную, иначе из цикла никогда не выйти. И это должно быть в вашем коде, как, скажем, увеличение переменной, или внешнее условие, как, например, проверяемый сенсор.
```c++
while(someVarible ?? value)
{
	doSomething;
}
```

#### `do while`
Цикл `do` управляемый «снизу» цикл, работающий на манер цикла `while`, с тем отличием, что условие проверки расположено в конце цикла, таким образом, цикл выполнится хотя бы один раз.
```c++
do{
	doSomething;
}while(someVarible ?? value)
```
### Переменные
Переменные — это способ именовать и хранить числовые значения для последующего использования программой. Само название - переменные, говорит
о том, что переменные - это числа, которые могут последовательно меняться, в отличие от констант, чьё значение никогда не меняется. Переменные нужно
декларировать (объявлять), и, что очень важно - им можно присваивать значения, которые нужно сохранить. Следующий код объявляет переменную `inputVariable`, а затем присваивает ей значение, полученное от 2-го аналогового порта:
```c++
int inputVarible = 0; // объяляется перменна и
					  // и ей присваи
inputVarible = analogRead(2) // переменная получает значения анологового вывода 2
```
`inputVariabl` — это наша переменная. Первая строка декларирует, что она будет содержать `int`, короткое целое. Вторая строка присваивает ей значение аналогового вывода 2. Это делает значение на выводе 2 доступным в любом месте программы.
Когда переменной присвоено значение, или переприсвоено, вы можете проверить это значение, если оно встречается в некотором условии, или использовать его непосредственно. Рассмотрим пример, иллюстрирующий три операции с переменными. Следующий код проверяет, не меньше ли 100 значение переменной, а если так, переменной `inputVariable` присваивается значение 100, а
затем задаётся пауза, определяемая переменной `inputVariable`, которая теперь, как минимум, равна 100:
```c++
if (inputVarible < 100) // Проверка, не меньше ли 100
{
	inputVarible = 100; // Если так присваем значение
}
delay(inputVarible);
```
#### Типы данных
Переменная – элементарная ячейка для хранения данных (цифр). Переменные разных типов имеют разный “размер ячейки” и имеют разный лимит на размер числа.


Существует еще несколько специальных типов данных для символов. Подробнее можно почитать  [здесь](https://docs.microsoft.com/ru-ru/cpp/cpp/char-wchar-t-char16-t-char32-t?view=vs-2019) и [здесь](https://learn.microsoft.com/ru-ru/cpp/c-runtime-library/standard-types?view=msvc-170).
|Название  | Альт.название  | Размер | Диапазон | Особенность|
|--|--|--|--|--|
|`boolean`  |`bool`  |1 байт| 0 или 1 |Логическая переменная|
|`char`| - | 1 байт| -128 ... 127| Хранит номер символа из таблицы символов ASCII|
|-|`int8_t`| 1 байт |-128 ... 127| Целые числа|
|`byte`|`uint8_t`|1 байт| 0 ... 255|Целые числа|
|`int`|`int16_t`. `short`| 2 байтаа |-32 768 ... 32 767| Целые числа|
|`unsigned int`| `uint16_t`, 'word'| 2 байта| 0 ... 65 535| Целые числа|
|`long`|`int32_t`|4 байта|-2 147 483 648… 2 147 483 647| Целые числа|
|`unsigned long`|`uint32_t`|4 байта|0… 4 294 967 295|Целые числа|
|`float`| - | 4 байта |-3.4E+38 3.4E+38| Числа с плавающей точкой (десятичные дроби). Точность: 6-7 знаков|
|`double`| -| 4 байта| -1.7E+308.. 1.7E+308|Число с плавающей запятой двойной точности|
|-|`int64_t`| 8 байт|-(2^64)/2… (2^64)/2-1|  Целые числа|
|-|`uint64_t`|8 байт|  2^64-1|  Целые числа|

-   `wchar_t`  – 16 битный символ
-   `char16_t`– 2-х байтный char
-   `char32_t`– 4-х байтный char

Также есть такое понятие, как переопределение типов данных (не создавая новых типов), для этого используется ключевое слово  **typedef**.  **Typedef**  работает следующим образом:  **typedef <тип> <имя>;**  – создать новый тип данных <имя> на основе типа <тип>. Пример:
`typedef byte color;`
Создаёт тип данных под названием  **color**, который будет абсолютно идентичен типу  **byte**  (то есть принимать 0-255). Теперь с этим типом можно создавать переменные:
`color R, G, B;`
Создали три переменные типа  **color**, который тот же  **byte**, только в профиль.
#### Массивы
Массив — это набор значений, к которым есть доступ через значение индекса. Любое значение в массиве может быть вызвано через вызов имени массива и
индекса значения. Индексы в массиве начинаются с нуля с первым значением, имеющим индекс 0. Массив нуждается в объявлении, а дополнительно может заполняться значениями до того, как будет использоваться. Схожим образом можно объявлять массив, указав его тип и размер, а позже присваивать значения по позиции индекса:
```c++
int myArray[5];
myArray[3] = 10;
x = myArray[3] // x = 10
```
Массивы часто используются в цикле `for`, где увеличивающийся счётчик применяется для индексации позиции каждого значения. Следующий пример использует массив для мерцания светодиода. Используемый цикл `for` со счётчиком, начинающимся с 0, записывает значение из позиции с индексом 0 массива `flicker[]`, в данном случае 180, на PWM-вывод (широтно-импульсная модуляция) 10; затем пауза в 200 ms, а затем переход к следующей  позиции индекса.
```c++
int ledPin = 10;
byte fliker[] = {180, 30, 255,
				 200, 10, 90,
				 150, 60};
void setup(){
	pinMode(ledPin, OUTPUT);
}

void loop(){
	for(int i = 0; i < 7; i ++){
		analogWrite(ledPin, flicker[i]);
		delay(200);
	}
}
```
#### Спецификаторы переменных 
-   `const`    – константа, такую переменную  **нельзя**  изменить (будет ошибка).  **const int val = 10;**
-  ` static`– позволяет объявить локальную переменную внутри функции, и эта переменная  **не будет заново переобъявляться**  при повторном вызове функции. Эдакая локальная глобальная переменная.  [Info](https://www.arduino.cc/reference/en/language/variables/variable-scope-qualifiers/static/)
-   `volatile`    – указывает компилятору, что переменную не нужно оптимизировать, что её значение может меняться извне. Такой спецификатор должен быть применён к переменным, которые меняют своё значение в прерывании.  [Info](https://www.arduino.cc/reference/en/language/variables/variable-scope-qualifiers/volatile/)
-   `extern` – указывает компилятору, что эта переменная объявлена  **в другом**  файле программы, но мы хотим пользоваться именно ей, а не создавать новую с таким же именем  **в этом**  файле программы. Позволяет читать/записывать в переменные, созданные в других файлах (библиотеках).
##### Структуры 
Структура в языке программирования Си представляет собой составной тип данных, который состоит из других компонентов. При этом в отличие от массива эти компоненты могут представлять различные типы данных. Для определения структуры применяется ключевое слово `struct`, а сам формат определения выглядит следующим образом:
```c++
struct <ярлык>{
<тип>  <имя переменной 1>;
<тип>  <имя переменной 2>;
<тип>  <имя переменной 3>;
};
```
Пример
```c++
// определение структуры person
struct person
{
    int age;
    char * name;
};
 
int main(void)
{
    // По позиции: значения передаются элементам структуры в том порядке, в котором они следуют в структуре:
    struct person tom = {23, "Tom"};
    // По имени: значения передаются элементам структуры по имени, независимо от порядка:
    struct person tom = {.name="Tom", .age=23};
	// Обращение к элементам структуры
	printf("Age: %d \t Name: %s", tom.age, tom.name);
}
```
#### Строки
**String** – очень мощный инструмент для работы со строками, т.е. текстовыми данными. Объявить строку можно несколькими способами:
```c++
String string0 = "Hello String";              // заполняем словами в кавычках
String string1 = String("Hello ") + String("String");  // сумма двух строк
String string2 = String('a');                 // строка из символа в одинарных кавычках
String string3 = String("This is string");    // конвертируем строку в String
String string4 = String(string3 + " more");   // складываем строку string3 с текстом в кавычках
String string5 = String(13);                  // конвертируем из числа в String
String string6 = String(20, DEC);             // конвертируем из числа с указанием базиса (десятичный)
String string7 = String(45, HEX);             // конвертируем из числа с указанием базиса (16-ричный)
String string8 = String(255, BIN);            // конвертируем из числа с указанием базиса (двоичный)
String string9 = String(5.698, 3);            // из float с указанием количества знаков после запятой (тут 3)

// можно формировать название из кусочков, например для работы с файлами
#define NAME "speed"
#define TYPE "-log"
#define EXT ".txt"

// при сложении достаточно указать String 1 раз для первой строки
String filename = String(NAME) + TYPE + EXT;  // filename будет равна speed-log.txt

// доступ к элементу строки работает по такому же механизму, как массив
string1[0] = "a";
// теперь вместо Hello String у нас aello String
```
### Цифровой ввод/вывод
### `pinMode(pin, mode)`
Используется в `void setup ()` для конфигурации заданного вывода, чтобы он работал на вход (`INPUT`) или на выход (`OUTPUT`).
```c++
pinMode(pin, OUTPUT);
```
Цифровые выводы в Arduino предустановлены на вход, так что их нет нужды явно объявлять как `INPUT` с помощью `pinMode()`. Выводы, сконфигурированные как `INPUT`, подразумеваются в состоянии с высоким импедансом (сопротивлением). В микроконтроллере Atmega, есть также удобные, программно доступные
подтягивающие резисторы 20 кОм. Эти встроенные подтягивающие резисторы доступны следующим образом:
```c++
pinMode(pin, INPUT);
digitalWrite(pin, HIGH);
```
Подтягивающие резисторы, как правило, используются при соединении входов с переключателями. Заметьте, что в примере выше нет преобразования `pin` на выход, это просто метод активизации встроенных подтягивающих резисторов. Выводы, сконфигурированные как `OUTPUT`, находятся в низкоимпедансном
состоянии и могут отдавать 40 мА в нагрузку (цепь, другое устройство). Это достаточный ток для яркого
включения светодиода (**не забудьте последовательный токоограничительный резистор!**), но не достаточный для включения реле, соленоидов или моторов. Короткое замыкание выводов **Arduino** или слишком большой ток могут повредить выходы или даже всю микросхему **Atmega**. Порой, не плохая идея — соединять `OUTPUT` вывод через последовательно включённый резистор в 470 Ом или 1 кОм.
### `digitalRead(pin)`
Считывает значение заданного цифрового вывода (`pin`) и возвращает результат `HIGH` или `LOW`. Вывод должен быть задан либо как переменная, либо как константа (0-13).
```c++
value = digitalRead(Pin);
```
### `digitalWrite(pin, value)`
Выводит либо логический уровень `HIGH`, либо `LOW` (включает или выключает) на заданном цифровом выводе pin. Вывод может быть задан либо как переменная, либо как константа (0-13).
```c++
digitalWrite(pin,HIGH);
```
Следующий пример читает состояние кнопки, соединённой с цифровым входом, и включает LED (светодиод), подключённый к цифровому выходу, когда кнопка нажата:
```c++
int led   = 13;
int pin   = 7;
int value = 0;

void setup(){
	pinMode(led, OUTPUT);
	pinMode(pin, INPUT);
}

void loop(){
	value = digitalRead(pin);
	digitalWrite(led, value);
}
```
### `analogRead(pin)`
Считывает значение из заданного аналогового входа (`pin`) с 10-битовым разрешением. Эта функция работает только на аналоговых портах (0-5). Результирующее целое значение находится в диапазоне от 0 до 1023.
```c++
value = analogRead(pin);
```
>Примечание: Аналоговые выводы не похожи на цифровые, и нет необходимости предварительно объявлять их как `INPUT` или `OUTPUT` (если только вы не планируете использовать их в качестве цифровых портов 14-18).
### `analogWrite(pin, value)`
Записывает псевдо-аналоговое значение, используя схему с широтно-импульсной модуляцией (`PWM`), на выходной вывод, помеченный как `PWM`. На новом модуле **Arduino** с **ATmega168 (328)**, эта функция работает на выводах 3, 5, 6, 9, 10 и 11. Старый модуль **Arduino** c **ATmega8** поддерживает только выводы 9, 10 и 11. Значение может быть задано как переменная или константа в диапазоне 0-255.
```c++
analogWrite(pin, value);
```
Значение 0 генерирует устойчивое напряжение 0 вольт на выходе заданного вывода; значение 255 генерирует 5 вольт на выходе заданного вывода. Для значений между 0 и 255 вывод быстро переходит от 0 к 5 вольтам — чем больше значение, тем чаще вывод в состоянии `HIGH` (5 вольт). Например, при значении 64 вывод будет в 0 три четверти времени, а в состоянии 5 вольт одну четверть; при значении 128 половину времени будет вывод будет в 0, а половину в 5 вольт; при значении 192 четверть времени вывод будет в 0 и три четверти в 5 вольт.
Поскольку эта функция схемная (встроенного модуля), вывод будет генерировать устойчивый сигнал после вызова `analogWrite` в фоновом режиме, пока не будет следующего вызова `analogWrite` (или вызова `digitalRead` или `digitalWrite` на тот же вывод).
> Примечание: Аналоговые выводы, не такие как цифровые, и не требуют
предварительной декларации их как `INPUT` или `OUTPUT`.

Следующий пример читает аналоговое значение с входного аналогового вывода,
конвертирует значение делением на 4 и выводит `PWM` сигнал на `PWM` вывод:

```c++
int led = 10;
int pin = 0;
int value;
void setup(){}
void loop(){
	value = analogRead(pin);
	value /=4;
	analogWrite(led, value);
}
```
## Приложение
### Цифровой выход
[picture]
Это базовая программа «`hello world`», используемая для включения и выключения чего-нибудь. В этом примере светодиод подключён к выводу 13 и мигает каждую секунду. Резистор в данном случае может быть опущен, поскольку на 13-м порту **Arduino** уже есть встроенный резистор.
```c++
int ledPin = 13;

void setup(){
	pinMode(ledPin, OUTPUT);
}
void loop{
	digitalWrite(ledPin, HIGH);
	delay(1000);
	digitalWrite(ledPin, LOW);
	delay(1000);
}
```
### Цифровой ввод
[picture]
Это простейшая форма ввода с двумя возможными состояниями: включено или выключено. В примере считывается простой переключатель или кнопка, подключённая к выводу 2. Когда выключатель замкнут, входной вывод читается как `HIGH` и включает светодиод.
```c++
int ledPin = 13; 
int inPin = 2;
void setup(){
	pinMode(ledPin, OUTPUT);
	pinMode(inPin, INPUT);
}
void loop(){
	if(digitalRead(inPin) == HIGH){
		digitalWrite(ledPin, HIGH);
		delay(1000);
		digitalWrite(ledPin, LOW);
		delay(1000);
	}
}
```
### Сильноточный выход
[picture]
Иногда возникает необходимость в управлении более, чем 40 мА от `Arduino`. В этом случае может использоваться транзистор **MOSFET** для коммутации сильноточной нагрузки. В следующем примере **MOSFET** быстро включается и выключается 5 раз в секунду.
> Примечание: Схема показывает мотор и диод защиты, но другие, не индуктивные,
нагрузки могут включаться без диода.
```c++
int outPin = 5;

void setup(){
	pinMode(outPin, OUTPUT);
}

void loop(){
	for(int i = 0; i <= 5; i++){
		digitalWrite(outPin, HIGH);
		delay(250); // 1/4 sec
		digitalWrite(outPin, HIGH);
		delay(250); // 1/4 sec
	}
	delay(1000); // 1 sec
}
```
### `PWM` выход
Широтно-импульсная модуляция (`PWM`) — это способ имитировать аналоговый выход с помощью импульсного сигнала. Это можно использовать для гашения и увеличения яркости светодиода или позже для управления сервомотором. Следующий пример медленно увеличивает яркость и гасит LED, используя цикл
`for`.
```c++
int ledPin = 9;
void setup(){}
void loop(){
	for(int i = 0; i <= 255; i++){
		analogWrite(ledPin, i);
		delay(100);
	}
	for(int i = 0; i <= 255; i--){
		analogWrite(ledPin, i);
		delay(100);
	}
}
```
### Вход с потенциометра
[picture]
Использование потенциометра и одного из аналоговых портов **Arduino** (аналого- цифрового преобразователя (`ADC`)) позволяет читать аналоговые значения в диапазоне 0-1023. Следующий пример показывает использование потенциометра для управления временем мигания светодиода LED.
```c++
int potPin = 0;
int ledPin = 13;

void setup(){
	pinMode(ledPin, OUTPUT);
}

void loop(){
	digitalWrite(ledPin, HIGH);
	delay(analogRead(potPin));
	digitalWrite(ledPin, LOW);
	delay(analogRead(potPin));
}
```
### Вход от переменного резистора
[picture]
Переменные резисторы включают фотоприёмники, термисторы, тензодатчики и т.д. Данный пример использует функцию чтения аналогового значения и задаёт время паузы. Этим управляется скорость, с которой меняется яркость светодиода LED.
```c++
int ledPin 	  = 9;
int analogPin = 0;

void setup(){}

void loop(){
	for(int i = 0; i <= 255; i++){
		analogWrite(ledPin, i);
		delay(delayVal());
	}
	for(int i = 0; i <= 255; i--){
		analogWrite(ledPin, i);
		delay(delayVal());
	}
}

int delayval(){
	int v = 0;
	v = analogRead(analogPin);
	v /= 8;
	return v;
}
```
### Cерво вывод
[picture]
Любительские сервомашинки — это разновидность полу-автономного мотор-редуктора, который может поворачиваться на 180. Всё, что нужно — это отправлять импульсы каждые 20 мС. В данном примере используется функция `servoPulse` для поворота мотора от 100 до 170 и обратно.
```c++
int servoPin   = 2;
int myAngle    = 0;
int pulseWidth = 0;

void setup(){
	pinMode(servoPin, OUTPUT);
}

void servoPulse(int servoPin, int myAngle){
	pulseWidth = (myAngle * 10) + 600;
	digitalWrite(servoPin, HIGH);
	delayMicroseconds(pulseWidth);
	digitalWrite(servoPin, LOW);
}

void loop(){
	for(myAngle = 10; myAngle <= 170; myAngle--){
		servoPulse(servoPin, myAngle);
		delay(20);
	}
}
```
### Дребезг контактов
Кнопка – один из самых популярных и простых видов датчиков. В основе работы любой кнопки лежит механический способ смыкания-размыкания контактов. Нажимая на любую, даже самую простую тактовую кнопку, мы формируем определенное давление на внутренние механизмы (пластины или пружины), в результате чего происходит сближение или расхождение металлических пластин.

[![Дребезг кнопки](https://arduinomaster.ru/wp-content/uploads/2017/11/68747470733a2f2f7261772e6769746875622e636f6d2f74686f6d617366726564657269636b732f426f756e63652d41726475696e6f2d576972696e672f6d61737465722f426f756e63795377697463685f6c6f636b6f75742e706e67-300x169.png "68747470733a2f2f7261772e6769746875622e636f6d2f74686f6d617366726564657269636b732f426f756e63652d41726475696e6f2d576972696e672f6d61737465722f426f756e63795377697463685f6c6f636b6f75742e706e67")](https://arduinomaster.ru/wp-content/uploads/2017/11/68747470733a2f2f7261772e6769746875622e636f6d2f74686f6d617366726564657269636b732f426f756e63652d41726475696e6f2d576972696e672f6d61737465722f426f756e63795377697463685f6c6f636b6f75742e706e67.png)

Мы люди взрослые и хорошо понимаем, что идеального в мире ничего не существует, в том числе идеально гладких поверхностей, контактов без неровностей, сопротивления и паразитной емкости. В нашем неидеальном мире в момент нажатия на кнопку в месте соединения контакты не соприкасаются мгновенно, микро-неровности на поверхности не позволяют пластинам мгновенно соединиться. Из-за этого в короткий промежуток времени на границе пластинок меняется и сопротивление, и взаимная емкость, из-за чего возникают масса разнообразных изменений уровня тока и напряжения. Другими словами, возникают очень интересные, хотя и не очень приятные процессы, которые в электротехнике называют переходными.

![Иллюстрация дребезга кнопки](https://arduinomaster.ru/wp-content/uploads/2017/11/Bounce_001.png "Bounce_001")

Переходные процессы протекают очень быстро и исчезают за доли миллисекунд. Поэтому мы редко их замечаем, например, когда включаем свет в комнате. Лампа накаливания не может менять свою яркость с такой скоростью, и тем более не может реагировать на изменения наш мозг. Но, обрабатывая сигал от кнопки на таком быстром устройстве, как Arduino, мы вполне можем столкнуться с такими переходными эффектами и должны их учитывать при программировании.

[![Дребезг контактов кнопки ардуино и его подавление и удаление](https://arduinomaster.ru/wp-content/uploads/2017/11/pic_6_1.gif "pic_6_1")](https://arduinomaster.ru/wp-content/uploads/2017/11/pic_6_1.gif)

В идеальном мире форма сигнала после нажатия на кнопку должна быть строго прямоугольная. В реальных же условиях вместе резкого перехода мы видим множество пиков и спадов. 
#### Как мы можем бороться с дребезгом?
Нужно, чтобы при любом состоянии кнопки, с неё считывалось однозначное значение. В этом нам помогут подтягивающие или стягивающие резисторы. Физически они ничем не отличаются друг от друга, главное чтобы они были большого номинала, например 10 кОм. Все различия заключаются в том, в какое именно место в схеме мы их подключаем. Итак, давайте рассмотрим каждый в отдельности. 

Итак, отсутствие подтяжки и дребезг — физически разные явления. Первое, или «висящий» контакт — случай, когда из-за отсутствия явного сигнала на входе состояние входа может интерпретироваться как угодно. Второе — когда при появлении сигнала на входе этот самый сигнал, прежде чем прийти к окончательному состоянию, какое-то время колеблется.

##### Висящий  контакт.

##### Аппаратно.

При  этом  подтяжка  может  быть  как  внешней, так  и  внутренней; например, в  Ардуино  она  включается  командой
```c++
pinMode (pin, INPUT_PULLUP);
```
В  целом  предпочительной  является  внешняя  подтяжка, однако  иногда  удобно  использовать  внутреннюю (для  экономии  деталей  либо  если  нужно  менять  функцию  вывода  МК  в  процессе  работы).

##### Дребезг контакта

С  дребезгом: либо  **аппаратно (конденсатор  параллельно  кнопке  либо  между  входом  и  полюсом  питания; триггер  Шмитта)**, либо  **программно (многократный  опрос  состояния  входа)**.

Пример 1.

Подтяжка  к  минусу, но  дребезг  не  остается.

![](https://lh4.googleusercontent.com/cCAj4XJbw8krYqwZ6FGNBxOpbbZTOPm4sdHpKe1WBhRT8EjcTaBfrcBs8EN6vaZLjaDA0qI4sIv9EaznuVjjXIB6GASdhqWusNaPSADtHs1b2vIGtWtqsI463hhj2SRlpF86n_OR8671Zh6yvs7c0kc)

Видно, что  без  конденсатора  кнопка, прежде  чем  подать  сигнал  на  вход, разок  проваливается  до  середины  напряжения  питания, потом  почти  до  нуля, и  лишь  затем  выдаёт  что-то  похожее  на  логическую  единицу. При  этом  МК  явно  увидит  два  нажатия  вместо  одного, и, если  по  нажатию  нам  нужно  переключать  состояние  лампочки, то  она  включится  меньше, чем  на  миллисекунду.

Пример 2.

Дребезг  гасится  конденсатором  параллельно  стягивающему  резистору

![](https://lh4.googleusercontent.com/CFirbFNkz1QLb63gIloYzIW4RX01wvtLFdKYy94kVy1y0ch9goBz9Dql9kuc-GkUD-q2QJzC2XpggHlRFOJCMmeYH6eb_gvnF7MaBn1-Wx6ogT7TJjSZgkCAp6BQ3Pt8kJq88BDpS2BQWZS-hoKsD8o)

Пример 3.

![](https://lh6.googleusercontent.com/gCRGggofsvILeLIbaaPRsVvrsVx-KwiaMP5g0XOYhSva1a5w1IolbhIYl9Fcfk1JVJAHiO-52tBtpfdWg8v7ikcbLPyOGwGXGfYNeeo-iHbq_-D92MyiUNEagr2olXYkMTFVqU3Nf-jZ0MKDwawXAiE)

Дребезг  гасится  конденсатором  параллельно  кнопке.

Как  это, pas de commentaires.

К  слову, величина  конденсатора  здесь  порядка  единиц  пикофарад.

К  слову  о  триггере  Шмитта

Так-то  он  уже  встроен  в  мк (и  теоретически  при `digitalRead` чтение  идёт  именно  с  него). Проблема  в  том, что  он  помогает  при  небольших  колебаниях  вокруг Vcc/2 (точного  значения  я  в  даташнике  на **Atmega** не  нашёл, только  указано  непонятно  к  чему  относящееся 0,05 В), то  есть  при  весомых  колебаниях (плохая  кнопка) он  не  очень  поможет. Ну, или  внешний  триггер  с  известными  параметрами.

##### Программные  способы  борьбы  с  дребезгом

В  целом  — многократный  опрос  с  целью  проверить, точно  ли  мы  получили  нажатие  кнопки  или  оно  где-то «в  процессе». В  примерах  предполагаю, что  подтяжка  к «+», а  кнопка  соединяет  пин  с  номером pin с  минусом.

Самый  простой  вариант
```c++
void loop(){
	uint8_t button_state_1 =  0, button_state_2 =  0;
	button_state_1 = digitalRead(pin);  /* Проверяем  состояние  входа */
	delay (300);  /* Выжидаем 300 мс */
	button_state_2 = digitalRead(pin);  /* Проверяем  ещё  разок */
	if(button_state_1 == button_state_2){
	//Два  раза  подряд  отсчёты  были  одинаковы, стало  быть, кнопка  точно  либо  нажата (0), либо  отпущена (1)
	}
}
```
##### Вариант  получше

Лучше, в  первую  очередь, тем, что  позволяет  различать  короткие  и  длинные  нажатия (скажем, если  взять uint16_t, то  вполне  удобно  использовать  маску 0x0ff0 для  короткого  нажатия; можно  и c восемью  битами, только  маску  правильно  написать). Идею  подглядел  у  сэнсэя.
```c++
enum  { button_read_period =  10  };  /* опрашивать  состояние  будем  каждые 10 мс */
void loop(){
	static  uint8_t button_state =  0;  /* Состояние  кнопки; каждый  бит  соответствует  состоянию  входа  в  очередной  момент  времени */
	static  uint32_t ts =  0;  /* здесь  храним  момент  последнего  отсчёта */
	if  ( millis()  - ts > button_read_period )  /* Если  с  момента  последнего  отсчёта  прошло  более button_read_period миллисекунд */{
		ts = millis();  /* Запоминам  этот  момент */
		button_state <<=  1;  /* сдвигаем  текущее  состояние  на  один  бит  влево, «забывая» самое  старое  значение*/
		button_state |= digitalRead(pin);  /* И  в  крайний  правый  бит  записываем  текущий  отсчёт*/
	}
	switch(button_state){
		case  0xff:  /*то  есть  все  биты «1» — последние 8 отсчётов  кнопка  была  отпущена*/
			/*Кнопка  отпущена  в  течение  минимум (button_read_period * 8) миллисекунд*/
			break;
		case  0:  // то  есть  все  биты «0» — последние 8 отсчётов  кнопка  была  нажата
			/*Кнопка  нажата  в  течение  минимум (button_read_period * 8) миллисекунд*/
			break;
		default:
		/*Кнопка  в  процессе  переключения;*/
			break;
		}
}
```
  
Тут  всё  немного  лучше, хотя  провал  тоже  есть (на  первом  развёртка  была 100мкс/дел, а  здесь  — 5мкс/ дел, то  есть  в  этом  случае  помеха  гасится  немного  быстрее, но  тоже  вполне  даёт  МК  шанс  уловить  ложное  срабатывание  кнопки).

Стягивающий резистор - резистор, который соединяет нужный нам участок цепи с землей(GND).

![](https://lh3.googleusercontent.com/sPMZ6NMNQU-yYy8z_CBbdtm7Ha5N_mf0cTZKnTNwvYO5eDOV09EEvNIsY-LebiH1mtd1NQden-VOdgI8SFK7Ihx2WG4YTrJd9mjjLqUJpmAUrGpd3Ufe8_B6Cjw7NJFVQk1MoNA6h5xbrqw4btmsBg)

Подключение стягивающего резистора к схеме 

Пока кнопка отжата, стягивающий резистор дает на пин стабильную землю. Но если нажать кнопку, ток пойдет по пути наименьшего сопротивления, и значение на пине станет HIGH. Этот резистор поэтому и называется стягивающим, потому что в неопределенном состоянии стягивает потенциал к GND.

По аналогии подтягивающий резистор подтягивает неопределенный потенциал ко входу с напряжением 5 В, делая его определенным - HIGH.
![](https://lh6.googleusercontent.com/sA16dgS4ZtsGhFMxnlTIxaPoy3s-Nv2apyOUteGhb5uaatKoFAJ1-EtfTEryfx0alMAZktuCic2yz7EhscL1LMVp5ecETvpiubq74dU8t0vGAGRtX7LQocWatDp6fz0omZrYLe-PrpaxQiIZisG9Rg)

Подключение подтягивающего резистора к схеме  

Пока кнопка не нажата, подтягивающий резистор дает стабильные 5 В.

Плата Arduino Uno на портах ввода/вывода имеет встроенные подтягивающие резисторы номиналом 20 КОм, которые можно включить программно, выглядит это так:

```c++
pinMode(pin, INPUT_PULLUP)
```
Добавим это к нашей программе, и забудем о дребезге!

Давайте сделаем так: лучше всего дребезг контактов можно показать на обычной механической кнопке. Подключим кнопку и светодиод, и напишем небольшой код.

![](https://lh4.googleusercontent.com/W0D6VdWuoHCEkuksV3KPerwMKTKJiDjRSrAyWdbP2KBT_Djq0Tt1ofOeO37EsbMT3iZCEGaQFM05hB2LYtpMFsmcOu06yonjEB5GrkzwE2UYS9_ngWJ0vf6Zi6kwBa3h4cKdK0HjRHc4floy4IKKyA)

Подключение тактовой кнопки к схеме
```c++
int buttonState = 0;
void setup() {
	pinMode(2, INPUT);
	pinMode(13, OUTPUT);
}
void loop() {
	buttonState = digitalRead(2);
	if (!buttonState == HIGH) {
		digitalWrite(13, HIGH);
	}
	else {
		digitalWrite(13, LOW);
	}
}
```
### Список дополнительных источников информации по программированию на С/С++ и Arduino
1) Русскоязычный справочный ресурс содержит переведенные примеры с официального сайта и
справочную документацию http://arduino.ru/
2) Официальный сайт компании Arduino https://www.arduino.cc/
3) Уроки по Ардуино https://lesson.iarduino.ru/
4) Уроки по Ардуино http://mypractic.ru/uroki-programmirovaniya-arduino-navigaciya-po-urokam
5) Уроки по Ардуино https://all-arduino.ru/category/uroki/
6) Уроки по Ардуино https://arduinomaster.ru/program/
7) Лекции и примеры программирования на С/С++ https://prog-cpp.ru/c/
8) Лекции и примеры программирования на С/С++ http://www.codenet.ru/progr/cpp/1/
9) Лекции и примеры программирования на С/С++ http://www.c-cpp.ru/
10) Исходнйы код **Arduino** https://github.com/arduino/ArduinoCore-avr


<!--stackedit_data:
eyJoaXN0b3J5IjpbMTgwNTYxNzU2MywxODA3NDM4MDcxLDEzMT
YwMjQ0MzksOTkyNTc1ODY3LDE1NjU1MTIzMzcsMTcxNjYzMDc2
OSw1MTQ1MDAyMzZdfQ==
-->