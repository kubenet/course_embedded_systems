# Структура команд и синтакс языка программирования контроллера Arduino
Для сохранения простоты, были сделаны некоторые
исключения, что улучшает руководство при использовании начинающими в качестве дополнительного источника информации - наряду с другими web-сайтами, книгами, семинарами и классами. Подобное решение, призвано акцентировать внимание на использовании Arduino для автономных задач и, например, исключает более сложное использование массивов или использование
последовательного соединения.
Начиная с описания структуры программы для Arduino на языке C, этот блокнот содержит описание синтаксиса наиболее общих элементов языка и иллюстрирует их использование в примерах и фрагментах кода. Блокнот содержит примеры функций ядра библиотеки Arduino, а в приложении приводятся примеры схем и начальных программ.
## Мотивация
1.  **Практическое применение**: Arduino - это платформа, которая имеет широкое применение в реальных проектах и приложениях. Студенты, изучающие Arduino, могут создавать функциональные устройства и системы, такие как умные дома, роботы, системы автоматизации и другие интересные проекты. Это позволяет студентам увидеть практическое применение своих навыков программирования и электроники, что может быть очень мотивирующим.
    
2.  **Исследование и экспериментирование**: Arduino предоставляет студентам возможность исследовать и экспериментировать с различными аспектами программирования и электроники. Студенты могут создавать свои собственные проекты, тестировать различные идеи и решать реальные проблемы. Это позволяет студентам развивать свою творческую мысль и получать ценный опыт в области исследования.
    
3.  **Универсальность и доступность**: Arduino является доступной и широко используемой платформой, которую можно легко получить и использовать. Это делает Arduino привлекательным выбором для студентов, не имеющих опыта в программировании или электронике. Arduino также поддерживается большим сообществом разработчиков и энтузиастов, что позволяет студентам обмениваться идеями, задавать вопросы и получать поддержку.
4. **Arduino Uno**  контроллер построен на  **ATmega328**  ([техническое описание](http://out.arduino.ru/?redirect=http%3A%2F%2Fwww.atmel.com%2Fdyn%2Fresources%2Fprod_documents%2Fdoc8161.pdf&baseU=https%3A%2F%2Farduino.ru%2FHardware%2FArduinoBoardUno), pdf). Платформа имеет 14 цифровых вход/выходов (6 из которых могут использоваться как выходы ШИМ), 6 аналоговых входов, кварцевый генератор 16 МГц, разъем USB, силовой разъем, разъем ICSP и кнопку перезагрузки. Для работы необходимо подключить платформу к компьютеру посредством кабеля USB, либо подать питание при помощи адаптера AC/DC или батареи.
![enter image description here](https://store.arduino.cc/cdn/shop/products/A000066_03.front_934x700.jpg?v=1629815860)

В отличие от всех плат, использовавших FTDI USB микроконтроллер для связи по USB, новый  **Ардуино Uno**  использует микроконтроллер  **ATmega8U2**  ([техническое описание, pdf](http://out.arduino.ru/?redirect=http%3A%2F%2Fwww.atmel.com%2Fdyn%2Fresources%2Fprod_documents%2Fdoc7799.pdf&baseU=https%3A%2F%2Farduino.ru%2FHardware%2FArduinoBoardUno)).

"Uno" переводится как один с итальянского и разработчики тем самым намекают на грядущий выход Arduino 1.0. Новая плата стала флагманом линейки плат Ардуино. Для сравнения с предыдущими версиями можно обратиться к  [полному списку плат Arduino](https://arduino.ru/Hardware).

### Характеристики
| | |
|--|--|
| Микроконтроллер | ATmega328 |
|Рабочее напряжение| 5 В|
|Входное напряжение (рекомендуемое) | 7-12 В |
|Входное напряжение (предельное)|6-20 В|
|Цифровые Входы/Выходы|14 (6 из которых могут использоваться как выходы  [ШИМ](https://arduino.ru/Tutorial/PWM))|
|Аналоговые входы|6|
|Постоянный ток через вход/выход|40 мА|
|Постоянный ток для вывода 3.3 В|50 мА|
|Флеш-память|32 Кб (ATmega328) из которых 0.5 Кб используются для загрузчика|
|ОЗУ|2 Кб (ATmega328)|
|EEPROM|1 Кб (ATmega328)|
|Тактовая частота|16 МГц|
###### Схема и исходные данные

Файлы EAGLE:  [arduino-duemilanove-reference-design.zip](https://arduino.ru/Schematic/arduino-uno-reference-design.zip)

Принципиальная схема:  [arduino-duemilanove-schematic.pdf](https://arduino.ru/Schematic/arduino-uno-schematic.pdf)

### Питание

**Arduino Uno**  может получать питание через подключение USB или от внешнего источника питания. Источник питания выбирается автоматически.

Внешнее питание (не USB) может подаваться через преобразователь напряжения AC/DC (блок питания) или аккумуляторной батареей. Преобразователь напряжения подключается посредством разъема 2.1 мм с центральным положительным полюсом. Провода от батареи подключаются к выводам Gnd и Vin разъема питания.

Платформа может работать при внешнем питании от 6 В до 20 В. При напряжении питания ниже 7 В, вывод 5V может выдавать менее 5 В, при этом платформа может работать нестабильно. При использовании напряжения выше 12 В регулятор напряжения может перегреться и повредить плату. Рекомендуемый диапазон от 7 В до 12 В.

Выводы питания:

-   **VIN**. Вход используется для подачи питания от внешнего источника (в отсутствие 5 В от разъема USB или другого регулируемого источника питания). Подача напряжения питания происходит через данный вывод.
-   **5V**. Регулируемый источник напряжения, используемый для питания микроконтроллера и компонентов на плате. Питание может подаваться от вывода VIN через регулятор напряжения, или от разъема USB, или другого регулируемого источника напряжения 5 В.
-   **3V3**. Напряжение на выводе 3.3 В генерируемое встроенным регулятором на плате. Максимальное потребление тока 50 мА.
-   **GND**. Выводы заземления.

### Память

Микроконтроллер ATmega328 располагает 32 кБ флэш памяти, из которых 0.5 кБ используется для хранения загрузчика, а также 2 кБ ОЗУ (SRAM) и 1 Кб EEPROM.(которая читается и записывается с помощью  [библиотеки EEPROM](https://arduino.ru/Reference/Library/EERPOM)).

###  Входы и Выходы

Каждый из 14 цифровых выводов Uno может настроен как вход или выход, используя функции [pinMode()](https://arduino.ru/Reference/PinMode),  [digitalWrite()](https://arduino.ru/Reference/DigitalWrite), и  [digitalRead()](https://arduino.ru/Reference/DigitalRead), . Выводы работают при напряжении 5 В. Каждый вывод имеет нагрузочный резистор (по умолчанию отключен) 20-50 кОм и может пропускать до 40 мА. Некоторые выводы имеют особые функции:

-   **Последовательная шина: 0 (RX) и 1 (TX)**. Выводы используются для получения (RX) и передачи (TX) данных TTL. Данные выводы подключены к соответствующим выводам микросхемы последовательной шины ATmega8U2 USB-to-TTL.
-   **Внешнее прерывание: 2 и 3**. Данные выводы могут быть сконфигурированы на вызов прерывания либо на младшем значении, либо на переднем или заднем фронте, или при изменении значения. Подробная информация находится в описании функции  [attachInterrupt()](https://arduino.ru/Reference/AttachInterrupt).
-   **ШИМ: 3, 5, 6, 9, 10, и 11.**  Любой из выводов обеспечивает  [ШИМ](https://arduino.ru/Tutorial/PWM)  с разрешением 8 бит при помощи функции  [analogWrite()](https://arduino.ru/Reference/AnalogWrite).
-   **SPI: 10 (SS), 11 (MOSI), 12 (MISO), 13 (SCK).** Посредством данных выводов осуществляется связь SPI, для чего используется  [библиотека SPI](https://arduino.ru/Reference/Library/SPI).
-   **LED: 13.** Встроенный светодиод, подключенный к цифровому выводу 13. Если значение на выводе имеет высокий потенциал, то светодиод горит.

На платформе Uno установлены 6 аналоговых входов (обозначенных как A0 .. A5), каждый разрешением 10 бит (т.е. может принимать 1024 различных значения). Стандартно выводы имеют диапазон измерения до 5 В относительно земли, тем не менее имеется возможность изменить верхний предел посредством вывода AREF и функции  [analogReference()](https://arduino.ru/Reference/AnalogReference). Некоторые выводы имеют дополнительные функции:

-   **I2C: 4 (SDA) и 5 (SCL).**  Посредством выводов осуществляется связь I2C (TWI), для создания которой используется  [библиотека Wire.](http://out.arduino.ru/?redirect=http%3A%2F%2Farduino.cc%2Fen%2FReference%2FWire&baseU=https%3A%2F%2Farduino.ru%2FHardware%2FArduinoBoardUno)

Дополнительная пара выводов платформы:

-   **AREF.**  Опорное напряжение для аналоговых входов. Используется с функцией  [analogReference()](https://arduino.ru/Reference/AnalogReference).
-   **Reset.** Низкий уровень сигнала на выводе перезагружает микроконтроллер. Обычно применяется для подключения кнопки перезагрузки на плате расширения, закрывающей доступ к кнопке на самой плате Arduino.

Обратите внимание на соединение между выводами  [Arduino и портами ATmega328](https://arduino.ru/Hardware/ATMega168pins).

### Связь

На платформе  **Arduino Uno**  установлено несколько устройств для осуществления связи с компьютером, другими устройствами Arduino или микроконтроллерами. ATmega328 поддерживают последовательный интерфейс UART TTL (5 В), осуществляемый выводами 0 (RX) и 1 (TX). Установленная на плате микросхема ATmega8U2 направляет данный интерфейс через USB, программы на стороне компьютера "общаются" с платой через виртуальный COM порт. Прошивка ATmega8U2 использует стандартные драйвера USB COM, никаких стороних драйверов не требуется, но на Windows для подключения потребуется файл ArduinoUNO.inf. Мониторинг последовательной шины (Serial Monitor) программы Arduino позволяет посылать и получать текстовые данные при подключении к платформе. Светодиоды RX и TX на платформе будут мигать при передаче данных через микросхему FTDI или USB подключение (но не при использовании последовательной передачи через выводы 0 и 1).

Библиотекой SoftwareSerial возможно создать последовательную передачу данных через любой из цифровых выводов Uno.

ATmega328 поддерживает интерфейсы I2C (TWI) и SPI. В Arduino включена библиотека Wire для удобства использования шины I2C.

### Программирование

Платформа программируется посредством ПО Arduino. Из меню **Tools > Board**  выбирается «Arduino Uno» (согласно установленному микроконтроллеру). Подробная информация находится в  [справочнике](https://arduino.ru/Reference)  и  [инструкциях](https://arduino.ru/Arduino_environment).

Микроконтроллер ATmega328 поставляется с записанным загрузчиком, облегчающим запись новых программ без использования внешних программаторов. Связь осуществляется оригинальным протоколом STK500.

Имеется возможность не использовать загрузчик и запрограммировать микроконтроллер через выводы ICSP (внутрисхемное программирование). Подробная информация находится в  [данной инструкции](http://out.arduino.ru/?redirect=http%3A%2F%2Farduino.cc%2Fen%2FHacking%2FProgrammer&baseU=https%3A%2F%2Farduino.ru%2FHardware%2FArduinoBoardUno).

### Автоматическая (программная) перезагрузка

**Uno**  разработана таким образом, чтобы перед записью нового кода перезагрузка осуществлялась самой программой Arduino на компьютере, а не нажатием кнопки на платформе. Одна из линий DTR микросхемы ATmega8U2, управляющих потоком данных (DTR), подключена к выводу перезагрузки микроконтроллеру ATmega328 через 100 нФ конденсатор. Активация данной линии, т.е. подача сигнала низкого уровня, перезагружает микроконтроллер. Программа Arduino, используя данную функцию, загружает код одним нажатием кнопки Upload в самой среде программирования. Подача сигнала низкого уровня по линии DTR скоординирована с началом записи кода, что сокращает таймаут загрузчика.

Функция имеет еще одно применение. Перезагрузка Uno происходит каждый раз при подключении к программе Arduino на компьютере с ОС Mac X или Linux (через USB). Следующие полсекунды после перезагрузки работает загрузчик. Во время программирования происходит задержка нескольких первых байтов кода во избежание получения платформой некорректных данных (всех, кроме кода новой программы). Если производится разовая отладка скетча, записанного в платформу, или ввод каких-либо других данных при первом запуске, необходимо убедиться, что программа на компьютере ожидает в течение секунды перед передачей данных.

На Uno имеется возможность отключить линию автоматической перезагрузки разрывом соответствующей линии. Контакты микросхем с обоих концов линии могут быть соединены с целью восстановления. Линия маркирована «RESET-EN». Отключить автоматическую перезагрузку также возможно подключив резистор 110 Ом между источником 5 В и данной линией.

### Токовая защита разъема USB

В  **Arduino Uno**  встроен самовостанавливающийся предохранитель (автомат), защищающий порт USB компьютера от токов короткого замыкания и сверхтоков. Хотя практически все компьютеры имеют подобную защиту, тем не менее, данный предохранитель обеспечивает дополнительный барьер. Предохранитель срабатыват при прохождении тока более 500 мА через USB порт и размыкает цепь до тех пока нормальные значения токов не будут востановлены.

## Средства разработки
### Arduino IDE

Программа, написанная в среде Arduino, называется скетч. Скетч пишется в текстовом редакторе, имеющем инструменты вырезки/вставки, поиска/замены текста. Во время сохранения и экспорта проекта в области сообщений появляются пояснения, также могут отображаться возникшие ошибки. Окно вывода текста(консоль) показывает сообщения Arduino, включающие полные отчеты об ошибках и другую информацию. Кнопки панели инструментов позволяют проверить и записать программу, создать, открыть и сохранить скетч, открыть мониторинг последовательной шины:

![компиляция кода](https://arduino.ru/sites/default/files/aruino_environment/play.gif)_Verify/Compile_  
Проверка программного кода на ошибки, компиляция.

![остановка мониторинга](https://arduino.ru/sites/default/files/aruino_environment/stop.gif)_Stop_  
Остановка мониторинга последовательной шины(Serial monitor) или затемнение других кнопок.

[![создание нового скетча](https://arduino.ru/sites/default/files/resize/aruino_environment/new-23x23.gif)](https://arduino.ru/sites/default/files/aruino_environment/new.gif)_New_  
Создание нового скетча.

[![открыть файл скетча](https://arduino.ru/sites/default/files/resize/aruino_environment/open-23x23.gif)](https://arduino.ru/sites/default/files/aruino_environment/open.gif)_Open_  
Открытие меню доступа ко всем скетчам в блокноте. Открывается нажатием в текущем окне.

_Примечание_: из-за наличия ошибки в Java данное меню не может прокручиваться; при необходимости открыть скетч из этого списка проследуйте в меню File | Sketchbook.

[![сохранение скетча](https://arduino.ru/sites/default/files/resize/aruino_environment/save-23x23.gif)](https://arduino.ru/sites/default/files/aruino_environment/save.gif)_Save_  
Сохранение скетча.

[![загрузка скетча в контроллер](https://arduino.ru/sites/default/files/resize/aruino_environment/export-23x23.gif)](https://arduino.ru/sites/default/files/aruino_environment/export.gif)_Upload to I/O Board_  
Компилирует программный код и загружает его в устройство Arduino. Описание загрузки приведено ниже.

[![Serial monitor](https://arduino.ru/sites/default/files/resize/aruino_environment/serial_monitor-23x23.gif)](https://arduino.ru/sites/default/files/aruino_environment/serial_monitor.gif)_Serial Monitor_  
Открытие мониторинга последовательной шины (Serial monitor).

Дополнительные команды сгруппированы в пять меню: File, Edit, Sketch, Tools, Help. Доступность меню определяется работой, выполняемой в данный момент.

**Edit**

-   _Copy for Discourse_  
    Копирует в буфер обмена подходящий для размещения на форуме код скетча с выделением синтаксиса.

-   _Copy as HTML_  
    Копирует код скетча в буфер обмена как HTML код, для размещения на веб-страницах.

**Sketch**

-   _Verify/Compile_  
    Проверка скетча на ошибки.

-   _Import Library_  
    Добавляет библиотеку в текущий скетч, вставляя директиву #include в код скетча. Подробная информация в описании библиотек ниже (Libraries).

-   _Show Sketch Folder_  
    Открывает папку, содержащую файл скетча, на рабочем столе.

-   _Add File..._  
    Добавляет файл в скетч (файл будет скопирован из текущего места расположения). Новый файл появляется в новой закладке в окне скетча. Файл может быть удален из скетча при помощи меню закладок.

**Tools**

-   _Auto Format_  
    Данная опция оптимизирует код, например, выстраивает в одну линию по вертикали открывающую и закрывающую скобки и помещает между ними утверждение.

-   _Board_  
    Выбор используемой платформы. Список с описанием платформ приводится ниже.

-   Serial Port  
    Меню содержит список последовательных устройств передачи данных (реальных и виртуальных) на компьютере. Список обновляется автоматически каждый раз при открытии меню Tools.

-   _Burn Bootloader_  
    Пункты данного меню позволяют записать Загрузчик (Bootloader) в микроконтроллер на платформе Arduino. Данное действие не требуется в текущей работе с Arduino, но пригодится, если имеется новый ATmega (без загрузчика). Перед записью рекомендуется проверить правильность выбора платформы из меню. При использовании AVR ISP необходимо выбрать соответствующий программатору порт из меню Serial Port.

#### Блокнот (Sketchbook)

Средой Arduino используется принцип блокнота: стандартное место для хранения программ (скетчей). Скетчи из блокнота открываются через меню File > Sketchbook или кнопкой Open на панели инструментов. При первом запуске программы Arduino автоматически создается директория для блокнота. Расположение блокнота меняется через диалоговое окно Preferences.

#### Закладки, Файлы и Компиляция

Позволяют работать с несколькими файлами скетчей (каждый открывается в отдельной закладке). Файлы кода могут быть стандартными Arduino (без расширения), файлами С (расширение *.с), файлами С++ (*.срр) или головными файлами (.h).

#### Загрузка скетча в Arduino

Перед загрузкой скетча требуется задать необходимые параметры в меню  **Tools > Board** и  **Tools > Serial Port**. Платформы описываются далее по тексту. В ОС Mac последовательный порт может обозначаться как dev/tty.usbserial-1B1 (для платы USB) или /dev/tty.USA19QW1b1P1.1 (для платы последовательной шины, подключенной через адаптер Keyspan USB-to-Serial). В ОС Windows порты могут обозначаться как COM1 или COM2 (для платы последовательной шины) или COM4, COM5, COM7 и выше (для платы USB). Определение порта USB производится в поле Последовательной шины USB Диспетчера устройств Windows. В ОС Linux порты могут обозначаться как /dev/ttyUSB0, /dev/ttyUSB1.

После выбора порта и платформы необходимо нажать кнопку загрузки на панели инструментов или выбрать пункт меню File > Upload to I/O Board. Современные платформы Arduino перезагружаются автоматически перед загрузкой. На старых платформах необходимо нажать кнопку перезагрузки. На большинстве плат во время процесса будут мигать светодиоды RX и TX. Среда разработки Arduino выведет сообщение об окончании загрузки или об ошибках.

При загрузке скетча используется Загрузчик (Bootloader) Arduino, небольшая программа, загружаемая в микроконтроллер на плате. Она позволяет загружать программный код без использования дополнительных аппаратных средств. Загрузчик (Bootloader) активен в течении нескольких секунд при перезагрузке платформы и при загрузке любого из скетчей в микроконтроллер. Работа Загрузчика (Bootloader) распознается по миганию светодиода (13 пин) (напр.: при перезагрузке платы).

#### Библиотеки

Библиотеки добавляют дополнительную функциональность скетчам, например, при работе с аппаратной частью или при обработке данных. Для использования библиотеки необходимо выбрать меню  **Sketch > Import Library**. Одна или несколько директив  **#include**  будут размещены в начале кода скетча с последующей компиляцией библиотек и вместе со скетчем. Загрузка библиотек требует дополнительного места в памяти Arduino. Неиспользуемые библиотеки можно удалить из скетча убрав директиву  **#include**.

На Arduino.cc имеется  [список библиотек](http://out.arduino.ru/?redirect=http%3A%2F%2Farduino.cc%2Fen%2FReference%2FLibraries&baseU=https%3A%2F%2Farduino.ru%2FArduino_environment "список библиотек для Ардуино"). Некоторые библиотеки включены в среду разработки Arduino. Другие могут быть загружены с различных ресурсов. Для установки скачанных библиотек необходимо создать директорию «libraries» в папке блокнота и затем распаковать архив. Например, для установки библиотеки DateTime ее файлы должны находится в подпапке  **/libraries/DateTime**  папки блокнота.

Смотрите  [данную инструкцию](http://out.arduino.ru/?redirect=http%3A%2F%2Farduino.cc%2Fen%2FHacking%2FLibraryTutorial&baseU=https%3A%2F%2Farduino.ru%2FArduino_environment "написание библиотек")  для написания собственной библиотеки.

#### Аппаратные средства других разработчиков

Поддерживаемые аппаратные средства других производителей добавляются в соответствующую подпапку папки блокнота. Устанавливаемые платформы могут включать собственные характеристики (в меню платформы), корневые библиотеки, загрузчик(Bootloader) и характеристики программатора. Для установки требуется распаковать архив в созданную папку. (Запрещено использовать наименование папки "arduino", т.к. могут быть перезаписаны встроенные данные платформы Arduino.) Для деинсталляции данных удаляется соответствующая директория.

Подробная информация по созданию сборок описаний аппаратных средств других производителей находится на  [страницах сайта Google Code](http://out.arduino.ru/?redirect=https%3A%2F%2Fcode.google.com%2Fp%2Farduino%2Fwiki%2FPlatforms&baseU=https%3A%2F%2Farduino.ru%2FArduino_environment "создание сборок аппартных средств").

#### Мониторинг последовательной шины (Serial Monitor)

Отображает данные посылаемые в платформу Arduino (плата USB или плата последовательной шины). Для отправки данных необходимо ввести текст и нажать кнопку Send или Enter. Затем выбирается скорость передачи из выпадающего списка, соответствующая значению  **Serial.begin**  в скетче. На ОС Mac или Linux платформа Arduino будет перезагружена (скетч начнется сначала) при подключении мониторинга последовательной шины.

Имеется возможность обмена информацией с платформой через программы Processing, Flash, MaxMSP и т.д. (см. подробности на странице описаний интерфейсов).

#### Настройки
Некоторые настройки изменяются в окне  **Preferences**  (меню Arduino в ОС Mac или File в ОС Windows и Linux). Остальные настройки находятся в файле, месторасположение которого указано в окне Preferences.

### ThinkerCAD
[ThinkerCAD](https://www.tinkercad.com/) – это онлайн-среда моделирования, позволяющая создавать и тестировать различные электрические схемы без необходимости использования физических компонентов. Это мощный инструмент, который дает возможность разработчикам и электронным инженерам собирать, тестировать и отлаживать схемы, используя виртуальные компоненты и программное обеспечение Arduino.

Один из наиболее популярных применений ThinkerCAD - моделирование работы Arduino. С его помощью можно создавать виртуальные прототипы устройств, создавать алгоритмы и проверять их работоспособность до начала физической реализации проекта. Это позволяет сэкономить время и ресурсы, а также производить быструю отладку и исправление ошибок.
С использованием ThinkerCAD вы можете создавать различные электрические схемы, начиная от базовых, таких как соединение резисторов и светодиодов, до более сложных, включающих микроконтроллеры, датчики и другие электронные компоненты. Программа предлагает широкий спектр оригинальных компонентов, которые можно просто перетащить и разместить на виртуальной плате для создания схемы. В основном окне можно производить сборку схемы из существующих в библиотеке компонентов.
ThinkerCAD также предоставляет возможность программировать микроконтроллеры, такие как Arduino, используя встроенный визуальный инструмент для кодирования. С помощью этого инструмента вы можете создавать скрипты и алгоритмы для контроля и взаимодействия с подключенными компонентами вашей схемы. Визуальное программирование гарантирует простоту использования и позволяет вам сразу же видеть результаты своей работы.

![enter image description here](https://ampermarket.kz/images/tinkercad_inst_5.png)

### Wokwi
[Wokwi](https://wokwi.com/) – это онлайн-симулятор для плат Arduino, Raspberry Pi Pico и ESP32 или даже вашей собственной платы микроконтроллера, предназначенный для изучения программирования без реального оборудования. Wokwi предлагает удобный и интуитивно понятный интерфейс, который позволяет быстро создавать и собирать схемы, а также программировать различные контроллеры, включая Arduino и другие популярные микроконтроллеры.
#### Возможности Wokwi

-   Над микроконтроллерными проектами можно работать прямо из браузера, аппаратные компоненты не нужны.
-   Wokwi имитирует основные платы для прототипирования: Arduino, ESP32 DevKit, Raspberry Pi Pico и другие.
-   Смоделированный проект можно подключить к интернету через MQTT, HTTP, NTP и другиепротоколы.
-   Через встроенный визуальный логический анализатор можно захватить цифровые сигналы в моделировании (например, UART, I2C, SPI) и проанализировать их на своём компьютере.
-   Для прошаренных пользователей есть функция расширенной отладки через GDB и возможность моделирования SD-карты. Код можно сразу запустить в исполнение или внести правки.
-   В сервисе есть огромная база готовых стартовых проектов, где можно посмотреть всё — вплоть до кода с комментариями и описаниями разработчиков.

[![](https://blog.themarfa.name/content/images/2022/09/image-45.png)](https://blog.themarfa.name/content/images/2022/09/image-45.png)

Одной из главных особенностей Wokwi является возможность моделирования и программирования Arduino. С его помощью вы можете создавать виртуальные прототипы устройств, разрабатывать и отлаживать программы и алгоритмы, а также тестировать и проверять работоспособность проектов до их физической реализации. Это не только экономит время и ресурсы, но и позволяет быстро исправлять ошибки и оптимизировать свои проекты. Слева - текстовый редактор, где можно работать с файлами программы(и не только), а справа - непосредственно поле симулятора. Сейчас там только базовая плата. Для того что бы добавить какой-либо элемент необходимо нажать на кнопку "+" и откроется выпадающий список элементов. Wokwi предлагает широкий спектр компонентов, которые можно использовать для создания электронных схем. С его помощью вы можете соединять различные элементы, такие как резисторы, светодиоды, конденсаторы, микроконтроллеры и другие, для создания электрических цепей. Интерфейс Wokwi интуитивно понятен и позволяет легко перемещать и подключать компоненты, а также настраивать их свойства.
И действительно, нам прислали представленный ниже скриншот вместе с размытым видео, показывающим, как светодиодный дисплей обновляется по мере запуска программы в веб-браузере.


![ESP32 MicroPython Simulator](https://cnx-software.ru/wp-content/uploads/2023/04/esp32-micropython-simulator-1024x576.jpg)

Учитывая низкую стоимость плат ESP32 и необходимость в использовании внешних модулей или макетных плат для создания проектов, эмуляторы для данного типа плат не являются необходимостью. 

Следовательно, это может объяснить популярность  [Wokwi](https://wokwi.com/), которая представляет собой отличную платформу для обучения, поддерживающую несколько плат Arduino (Uno, Mega, Nano), Raspberry Pi Pico и универсальную плату ESP32, программированные как на Arduino, так и на MicroPython.

![Wokwi Arduino and Raspberry Pi Pico](https://cnx-software.ru/wp-content/uploads/2023/04/wokwi-arduino-raspberry-pi-pico.png)

Также возможно добавление  [пользовательских плат](https://github.com/wokwi/wokwi-boards), чтобы не ограничиваться официально поддерживаемыми платами. Пользователи могут начинать свои проекты с нуля, выбирая только плату, добавляя компоненты и создавая код самостоятельно, либо использовать существующие проекты, например, проект датчика температуры и влажности ESP32 + DHT22.

![Wokwi ESP32 Simulator](https://cnx-software.ru/wp-content/uploads/2023/04/wokwi-esp32-simulator-1024x731.png)

Доступно графическое представление Arduino, и для запуска моделирования необходимо нажать зеленую кнопку. Результаты температуры и влажности отображаются в виртуальной последовательной консоли.

Также можно добавлять дополнительные компоненты, такие как светодиоды, потенциометры, кнопки, датчики, VCC, GND и другие. Диаграмма также доступна в исходном коде в формате JSON.

![Диаграмма и компоненты в Wokwi](https://cnx-software.ru/wp-content/uploads/2023/04/wokwi-add-components-1024x731.png)

Wokwi предоставляет бесплатные возможности использования, но также доступна  [платная программа Wokwi Club](https://docs.wokwi.com/getting-started/wokwi-club), предлагающая членам возможности, такие как добавление библиотек Arduino, загрузка пользовательских двоичных файлов, подключение к Wi-Fi ESP32 и сохранение проектов в приватном режиме. Участники также могут принимать участие в голосовании за новые функции Wokwi.
### Структура программы 
Базовая структура программы для Arduino довольно проста и состоит, по меньшей мере, из двух частей. В этих двух обязательных частях, или функциях, заключён выполняемый код.
~~~ c++
void setup()
{
	// подготовка
}

void loop()
{
	// выполнение
}
~~~
``
Перед функцией `setup` - в самом начале программы, обычно, идёт, объявление всех переменных. `setup` - это первая функция, выполняемая программой, и выполняемая только один раз, поэтому она используется для установки режима работы портов `(pinMode())` или инициализации последовательного соединения. Следующая функция `loop` содержит код, который выполняется постоянно — читаются входы, переключаются выходы и т.д. Эта функция — ядро всех программ Arduino и выполняет основную работу.
#### `setup()`
Функция `setup()` вызывается один раз, когда программа стартует. Используйте её для установки режима выводов или инициализации последовательного соединения. Она должна быть включена в программу, даже если в ней нет никакого содержания.
```c++
void setup()
{
	pinMode(pin, OUTPUT); // устанавливает пин как выход
}
```
#### `loop()`
После вызова функции `setup()` – управление переходит к функции `loop()` , которая делает в точности то, что означает её имя — непрерывно выполняется, позволяя.
```c++
void loop()
{
	digitalWrite(pin, HIGH);
	delay(1000);
	digitalWrite(pin, LOW);
	delay(1000);
}
```
#### Комментарии
##### `/*` ... `*/` блок комментария
Блок комментария или однострочный комментарий — это область текста, которая
игнорируется программой и используется для добавления текста с описанием кода
или примечаний. Комментарий помогают другим понять эту часть программы. Он
начинается с `/*` и заканчивается `*/` и может содержать множество строк.

Поскольку комментарии игнорируются программой, а, следовательно, не занимают места в памяти, они могут быть достаточно ёмкими, но кроме того, они
могут использоваться для «пометки» блоков кода с отладочной целью.

**Примечание**: Хотя допускается вставка однострочного комментария в блоке
комментария, второй блок комментария не допускается.

##### `//`однострочный комментарий
Однострочный комментарий начинается с `//` и заканчивается (внутренним) кодом перехода на другую строку. Как и блок комментария, он игнорируется программой и не занимает места в памяти.
`//` вот так выглядит однострочный комментарий
Однострочный комментарий часто используется после действенного выражения, чтобы дать больше информации о том, что выражение выполняет или в качестве напоминания на будущее.
 
1. Комментарии помещаются прямо над кодом**, к которому они относятся. Так проще понять, о чём речь, не вникая в содержание каждой строчки. Совсем короткие пояснения можно писать справа.
```
# определяем общую структуру товара со значениями по умолчанию
product = { 
   "productId": 0, # идентификатор товара, по умолчанию: 0
	"description": "", # описание товара, по умолчанию: пусто
	"categoryId": 0, # категория товара, по умолчанию: 0
	"цена": 0,00 # цена, по умолчанию: 0,00
}
```

2. Комментируют все основные элементы кода:**  модули, функции, константы, глобальные переменные, интерфейсы, классы и их составные элементы (методы, свойства, константы).

3. Пишут коротко и по делу.**  Комментарии без смысловой нагрузки страшно раздражают. Не нужно писать комментарии типа «это гениальный код», «таблица1», «! №; %:? *» и подобные.

**«Опиши комментариями структуру кода»**. На примере кода программы, складывающей два числа, этот принцип будет выглядеть так:  

```
int main()
{
     // Принять от пользователя два числа
     // Завести переменную для результата сложения
     // Вернуть результат сложения

     return 0;
}

``` 
И лишь когда готов каркас из комментариев, следует писать код который будет реализовывать то, что описано комментариями.  
```
int main()
{
     double a,b;
     // Принять от пользователя два числа
     cin>>a;
     cin>>b;
     //Завести переменную для результата сложения
     double sum = a+b;
     // Вернуть результат сложения
     cout<<sum;

     return 0;
}
```
#### Функции
Функция — это блок кода, имеющего имя, которое указывает на исполняемый код, который выполняется при вызове функции. Функции `void setup()` и `void loop()` уже обсуждались, а другие встроенные функции будут рассмотрены позже.
Могут быть написаны различные пользовательские функции, для выполнения повторяющихся задач и уменьшения беспорядка в программе. При создании
функции, первым делом, указывается тип функции. Это тип значения, возвращаемого функцией, такой как `int` для целого (integer) типа функции. Если функция не возвращает значения, её тип должен быть `void`. За типом функции следует её имя, а в скобках параметры, передаваемые в функцию.
```c++
type functionName(parameters)
{
	// сделать что то
}
```
Следующая функция целого типа `delayVal()` используется для задания значения паузы в программе чтением значения с потенциометра. Вначале объявляется локальная переменная `v`, затем `v` устанавливается в значение потенциометра, определяемое числом между  `0 — 1023`, затем это значение делится на `4`, чтобы результирующее значение было между `0` и `255`, а затем это значение возвращается в основную программу.
```c++
int delayVal()
{
	int v; //Создаение локальной переменной
	v = analogRead(pin); // считывание значения 
	v /= 4; // конвертируем из 0 - 1023 в 0 - 255
	return v; // возвращаем полученное число
}
```
#### `#include` 
Директива, позволяющая подключать в проект дополнительные файлы с кодом.
```c++
#include <Servo.h>  // подключает библиотеку Servo.h
#include "Servo.h"  // подключает библиотеку Servo.h
```
В чём отличие **<>** и **“”**? Когда указываем название **“в кавычках”**, компилятор сначала ищет файл в папке со скетчем, а затем в папке с библиотеками. При использовании **<галочек>** компилятор ищет файл только в папке с библиотеками
### `#define`
Директива, дающая команду препроцессору заменить указанное название на указанное значение. Чаще всего таким образом объявляют константы:
```c++
#define MOTOR_PIN 10 // пин мотора 10
#define LED_PIN 3 // пин светодиода 3
```
После компиляции все встречающиеся в тексте программы слова MOTOR_PIN будут заменены на цифру 10, а LED_PIN – на цифру 3. Такой способ хранения констант **не использует оперативную память микроконтроллера**. Также define позволяет делать т.н. макро функции. Например Ардуиновская функция **sq** (квадрат) является макро, который при компиляции превращается в умножение:
```c++
#define sq(x) ((x)*(x))
```
### `#if`, `#elif`, `#else`, `#endif`
Директивы препроцессору, позволяющие включать или исключать участки кода по условию
```c++
#define TEST 1    // определяем TEST как 1

#if (TEST == 1)   // если TEST 1
#define VALUE 10  // определить VALUE как 10
#elif (TEST == 0) // TEST 0
#define VALUE 20  // определить VALUE как 20
#else             // если нет
#define VALUE 30  // определить VALUE как 30
#endif            // конец условия
```
При помощи условной компиляции очень удобно собирать и настраивать сложные проекты с кучей настроек и библиотек, подключаемых “по условию”. Например:
```c++
#define DEBUG 1
void  setup()  {
#if (DEBUG == 1)
Serial.begin(9600);
Serial.println("Hello!");
#endif
}
```
Если параметру DEBUG установить 1, то будет подключена библиотека Serial, если 0 – то нет. Таким образом получаем универсальный оптимизированный проект с отладкой
### `#ifdef`, `#ifndef`
Условные директивы препроцессору, позволяют включать или исключать участки кода по условию: **ifdef** – определено ли? **ifndef** – не определено ли?
```c++
#define TEST      // определяем TEST 

#ifdef TEST       // если TEST определено 
#define VALUE 10  // определить VALUE как 10 
#else             // если закоммент. #define TEST
#define VALUE 20  // определить VALUE как 20 
#endif            // конец условия
```
#### Переменные
Переменные — это способ именовать и хранить числовые значения для последующего использования программой. Само название - переменные, говорит
о том, что переменные - это числа, которые могут последовательно меняться, в отличие от констант, чьё значение никогда не меняется. Переменные нужно
декларировать (объявлять), и, что очень важно - им можно присваивать значения, которые нужно сохранить. Следующий код объявляет переменную `inputVariable`, а затем присваивает ей значение, полученное от 2-го аналогового порта:
```c++
int inputVarible = 0; // объяляется перменна и
					  // и ей присваи
inputVarible = analogRead(2)
```

