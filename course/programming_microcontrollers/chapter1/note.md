# Курс: Программирование микроконтроллеров
## Контроллер

1.  **Практическое применение**: **Arduino** - это платформа, которая имеет широкое применение в реальных проектах и приложениях. Студенты, изучающие **Arduino**, могут создавать функциональные устройства и системы, такие как умные дома, роботы, системы автоматизации и другие интересные проекты. Это позволяет студентам увидеть практическое применение своих навыков программирования и электроники, что может быть очень мотивирующим.
    
2.  **Исследование и экспериментирование**: **Arduino** предоставляет студентам возможность исследовать и экспериментировать с различными аспектами программирования и электроники. Студенты могут создавать свои собственные проекты, тестировать различные идеи и решать реальные проблемы. Это позволяет студентам развивать свою творческую мысль и получать ценный опыт в области исследования.
    
3.  **Универсальность и доступность**: **Arduino** является доступной и широко используемой платформой, которую можно легко получить и использовать. Это делает **Arduino** привлекательным выбором для студентов, не имеющих опыта в программировании или электронике. **Arduino** также поддерживается большим сообществом разработчиков и энтузиастов, что позволяет студентам обмениваться идеями, задавать вопросы и получать поддержку.
4. **Arduino Uno**  контроллер построен на  **ATmega328**  ([техническое описание](http://out.arduino.ru/?redirect=http%3A%2F%2Fwww.atmel.com%2Fdyn%2Fresources%2Fprod_documents%2Fdoc8161.pdf&baseU=https%3A%2F%2Farduino.ru%2FHardware%2FArduinoBoardUno)). Платформа имеет 14 цифровых вход/выходов (6 из которых могут использоваться как выходы ШИМ), 6 аналоговых входов, кварцевый генератор 16 МГц, разъем USB, силовой разъем, разъем ICSP и кнопку перезагрузки. Для работы необходимо подключить платформу к компьютеру посредством кабеля USB, либо подать питание при помощи адаптера AC/DC или батареи.
![enter image description here](https://store.arduino.cc/cdn/shop/products/A000066_03.front_934x700.jpg?v=1629815860)

В отличие от всех плат, использовавших FTDI USB микроконтроллер для связи по USB, новый  **Ардуино Uno**  использует микроконтроллер  **ATmega8U2**  ([техническое описание, pdf](http://out.arduino.ru/?redirect=http%3A%2F%2Fwww.atmel.com%2Fdyn%2Fresources%2Fprod_documents%2Fdoc7799.pdf&baseU=https%3A%2F%2Farduino.ru%2FHardware%2FArduinoBoardUno)).

"Uno" переводится как один с итальянского и разработчики тем самым намекают на грядущий выход **Arduino** 1.0. Новая плата стала флагманом линейки плат Ардуино. Для сравнения с предыдущими версиями можно обратиться к  [полному списку плат **Arduino**](https://arduino.ru/Hardware).

### Характеристики
| | |
|--|--|
| Микроконтроллер | ATmega328 |
|Рабочее напряжение| 5 В|
|Входное напряжение (рекомендуемое) | 7-12 В |
|Входное напряжение (предельное)|6-20 В|
|Цифровые Входы/Выходы|14 (6 из которых могут использоваться как выходы  [ШИМ](https://arduino.ru/Tutorial/PWM))|
|Аналоговые входы|6|
|Постоянный ток через вход/выход|40 мА|
|Постоянный ток для вывода 3.3 В|50 мА|
|Флеш-память|32 Кб (ATmega328) из которых 0.5 Кб используются для загрузчика|
|ОЗУ|2 Кб (ATmega328)|
|EEPROM|1 Кб (ATmega328)|
|Тактовая частота|16 МГц|
### Схема

Файлы EAGLE:  [arduino-duemilanove-reference-design.zip](https://arduino.ru/Schematic/arduino-uno-reference-design.zip)
Принципиальная схема:  [arduino-duemilanove-schematic.pdf](https://arduino.ru/Schematic/arduino-uno-schematic.pdf)

### Питание

**Arduino Uno**  может получать питание через подключение USB или от внешнего источника питания. Источник питания выбирается автоматически.

Внешнее питание (не USB) может подаваться через преобразователь напряжения AC/DC (блок питания) или аккумуляторной батареей. Преобразователь напряжения подключается посредством разъема 2.1 мм с центральным положительным полюсом. Провода от батареи подключаются к выводам Gnd и Vin разъема питания.

Платформа может работать при внешнем питании от 6 В до 20 В. При напряжении питания ниже 7 В, вывод 5V может выдавать менее 5 В, при этом платформа может работать нестабильно. При использовании напряжения выше 12 В регулятор напряжения может перегреться и повредить плату. Рекомендуемый диапазон от 7 В до 12 В.

Выводы питания:

-   **VIN**. Вход используется для подачи питания от внешнего источника (в отсутствие 5 В от разъема USB или другого регулируемого источника питания). Подача напряжения питания происходит через данный вывод.
-   **5V**. Регулируемый источник напряжения, используемый для питания микроконтроллера и компонентов на плате. Питание может подаваться от вывода VIN через регулятор напряжения, или от разъема USB, или другого регулируемого источника напряжения 5 В.
-   **3V3**. Напряжение на выводе 3.3 В генерируемое встроенным регулятором на плате. Максимальное потребление тока 50 мА.
-   **GND**. Выводы заземления.

### Память

Микроконтроллер ATmega328 располагает 32 кБ флэш памяти, из которых 0.5 кБ используется для хранения загрузчика, а также 2 кБ ОЗУ (SRAM) и 1 Кб EEPROM.(которая читается и записывается с помощью  [библиотеки EEPROM](https://arduino.ru/Reference/Library/EERPOM)).

###  Входы и Выходы

Каждый из 14 цифровых выводов Uno может настроен как вход или выход, используя функции [pinMode()](https://arduino.ru/Reference/PinMode),  [digitalWrite()](https://arduino.ru/Reference/DigitalWrite), и  [digitalRead()](https://arduino.ru/Reference/DigitalRead), . Выводы работают при напряжении 5 В. Каждый вывод имеет нагрузочный резистор (по умолчанию отключен) 20-50 кОм и может пропускать до 40 мА. Некоторые выводы имеют особые функции:

-   **Последовательная шина: 0 (RX) и 1 (TX)**. Выводы используются для получения (RX) и передачи (TX) данных TTL. Данные выводы подключены к соответствующим выводам микросхемы последовательной шины ATmega8U2 USB-to-TTL.
-   **Внешнее прерывание: 2 и 3**. Данные выводы могут быть сконфигурированы на вызов прерывания либо на младшем значении, либо на переднем или заднем фронте, или при изменении значения. Подробная информация находится в описании функции  [attachInterrupt()](https://arduino.ru/Reference/AttachInterrupt).
-   **ШИМ: 3, 5, 6, 9, 10, и 11.**  Любой из выводов обеспечивает  [ШИМ](https://arduino.ru/Tutorial/PWM)  с разрешением 8 бит при помощи функции  [analogWrite()](https://arduino.ru/Reference/AnalogWrite).
-   **SPI: 10 (SS), 11 (MOSI), 12 (MISO), 13 (SCK).** Посредством данных выводов осуществляется связь SPI, для чего используется  [библиотека SPI](https://arduino.ru/Reference/Library/SPI).
-   **LED: 13.** Встроенный светодиод, подключенный к цифровому выводу 13. Если значение на выводе имеет высокий потенциал, то светодиод горит.

На платформе Uno установлены 6 аналоговых входов (обозначенных как A0 .. A5), каждый разрешением 10 бит (т.е. может принимать 1024 различных значения). Стандартно выводы имеют диапазон измерения до 5 В относительно земли, тем не менее имеется возможность изменить верхний предел посредством вывода AREF и функции  [analogReference()](https://arduino.ru/Reference/AnalogReference). Некоторые выводы имеют дополнительные функции:

-   **I2C: 4 (SDA) и 5 (SCL).**  Посредством выводов осуществляется связь I2C (TWI), для создания которой используется  [библиотека Wire.](http://out.arduino.ru/?redirect=http%3A%2F%2Farduino.cc%2Fen%2FReference%2FWire&baseU=https%3A%2F%2Farduino.ru%2FHardware%2FArduinoBoardUno)

Дополнительная пара выводов платформы:

-   **AREF.**  Опорное напряжение для аналоговых входов. Используется с функцией  [analogReference()](https://arduino.ru/Reference/AnalogReference).
-   **Reset.** Низкий уровень сигнала на выводе перезагружает микроконтроллер. Обычно применяется для подключения кнопки перезагрузки на плате расширения, закрывающей доступ к кнопке на самой плате Arduino.

Обратите внимание на соединение между выводами  [Arduino и портами ATmega328](https://arduino.ru/Hardware/ATMega168pins).

### Связь

На платформе  **Arduino Uno**  установлено несколько устройств для осуществления связи с компьютером, другими устройствами Arduino или микроконтроллерами. ATmega328 поддерживают последовательный интерфейс UART TTL (5 В), осуществляемый выводами 0 (RX) и 1 (TX). Установленная на плате микросхема ATmega8U2 направляет данный интерфейс через USB, программы на стороне компьютера "общаются" с платой через виртуальный COM порт. Прошивка ATmega8U2 использует стандартные драйвера USB COM, никаких стороних драйверов не требуется, но на Windows для подключения потребуется файл ArduinoUNO.inf. Мониторинг последовательной шины (Serial Monitor) программы Arduino позволяет посылать и получать текстовые данные при подключении к платформе. Светодиоды RX и TX на платформе будут мигать при передаче данных через микросхему FTDI или USB подключение (но не при использовании последовательной передачи через выводы 0 и 1).

Библиотекой SoftwareSerial возможно создать последовательную передачу данных через любой из цифровых выводов Uno.

ATmega328 поддерживает интерфейсы I2C (TWI) и SPI. В Arduino включена библиотека Wire для удобства использования шины I2C.

### Программирование

Платформа программируется посредством ПО Arduino. Из меню **Tools > Board**  выбирается «Arduino Uno» (согласно установленному микроконтроллеру). Подробная информация находится в  [справочнике](https://arduino.ru/Reference)  и  [инструкциях](https://arduino.ru/Arduino_environment).

Микроконтроллер ATmega328 поставляется с записанным загрузчиком, облегчающим запись новых программ без использования внешних программаторов. Связь осуществляется оригинальным протоколом STK500.

Имеется возможность не использовать загрузчик и запрограммировать микроконтроллер через выводы ICSP (внутрисхемное программирование). Подробная информация находится в  [данной инструкции](http://out.arduino.ru/?redirect=http%3A%2F%2Farduino.cc%2Fen%2FHacking%2FProgrammer&baseU=https%3A%2F%2Farduino.ru%2FHardware%2FArduinoBoardUno).

### Автоматическая (программная) перезагрузка

**Uno**  разработана таким образом, чтобы перед записью нового кода перезагрузка осуществлялась самой программой Arduino на компьютере, а не нажатием кнопки на платформе. Одна из линий DTR микросхемы ATmega8U2, управляющих потоком данных (DTR), подключена к выводу перезагрузки микроконтроллеру ATmega328 через 100 нФ конденсатор. Активация данной линии, т.е. подача сигнала низкого уровня, перезагружает микроконтроллер. Программа Arduino, используя данную функцию, загружает код одним нажатием кнопки Upload в самой среде программирования. Подача сигнала низкого уровня по линии DTR скоординирована с началом записи кода, что сокращает таймаут загрузчика.

Функция имеет еще одно применение. Перезагрузка Uno происходит каждый раз при подключении к программе Arduino на компьютере с ОС Mac X или Linux (через USB). Следующие полсекунды после перезагрузки работает загрузчик. Во время программирования происходит задержка нескольких первых байтов кода во избежание получения платформой некорректных данных (всех, кроме кода новой программы). Если производится разовая отладка скетча, записанного в платформу, или ввод каких-либо других данных при первом запуске, необходимо убедиться, что программа на компьютере ожидает в течение секунды перед передачей данных.

На Uno имеется возможность отключить линию автоматической перезагрузки разрывом соответствующей линии. Контакты микросхем с обоих концов линии могут быть соединены с целью восстановления. Линия маркирована «RESET-EN». Отключить автоматическую перезагрузку также возможно подключив резистор 110 Ом между источником 5 В и данной линией.


## Средства разработки
### Arduino IDE

Программа, написанная в среде Arduino, называется скетч. Скетч пишется в текстовом редакторе, имеющем инструменты вырезки/вставки, поиска/замены текста. Во время сохранения и экспорта проекта в области сообщений появляются пояснения, также могут отображаться возникшие ошибки. Окно вывода текста(консоль) показывает сообщения Arduino, включающие полные отчеты об ошибках и другую информацию. Кнопки панели инструментов позволяют проверить и записать программу, создать, открыть и сохранить скетч, открыть мониторинг последовательной шины:

#### Блокнот (Sketchbook)

Средой Arduino используется принцип блокнота: стандартное место для хранения программ (скетчей). Скетчи из блокнота открываются через меню File > Sketchbook или кнопкой Open на панели инструментов. При первом запуске программы Arduino автоматически создается директория для блокнота. Расположение блокнота меняется через диалоговое окно Preferences.

#### Закладки, Файлы и Компиляция

Позволяют работать с несколькими файлами скетчей (каждый открывается в отдельной закладке). Файлы кода могут быть стандартными Arduino (без расширения), файлами С (расширение *.с), файлами С++ (*.срр) или головными файлами (.h).

#### Загрузка скетча в Arduino

Перед загрузкой скетча требуется задать необходимые параметры в меню  **Tools > Board** и  **Tools > Serial Port**. Платформы описываются далее по тексту. В ОС Mac последовательный порт может обозначаться как dev/tty.usbserial-1B1 (для платы USB) или /dev/tty.USA19QW1b1P1.1 (для платы последовательной шины, подключенной через адаптер Keyspan USB-to-Serial). В ОС Windows порты могут обозначаться как COM1 или COM2 (для платы последовательной шины) или COM4, COM5, COM7 и выше (для платы USB). Определение порта USB производится в поле Последовательной шины USB Диспетчера устройств Windows. В ОС Linux порты могут обозначаться как /dev/ttyUSB0, /dev/ttyUSB1.

После выбора порта и платформы необходимо нажать кнопку загрузки на панели инструментов или выбрать пункт меню File > Upload to I/O Board. Современные платформы Arduino перезагружаются автоматически перед загрузкой. На старых платформах необходимо нажать кнопку перезагрузки. На большинстве плат во время процесса будут мигать светодиоды RX и TX. Среда разработки Arduino выведет сообщение об окончании загрузки или об ошибках.

При загрузке скетча используется Загрузчик (Bootloader) Arduino, небольшая программа, загружаемая в микроконтроллер на плате. Она позволяет загружать программный код без использования дополнительных аппаратных средств. Загрузчик (Bootloader) активен в течении нескольких секунд при перезагрузке платформы и при загрузке любого из скетчей в микроконтроллер. Работа Загрузчика (Bootloader) распознается по миганию светодиода (13 пин) (напр.: при перезагрузке платы).

#### Библиотеки

Библиотеки добавляют дополнительную функциональность скетчам, например, при работе с аппаратной частью или при обработке данных. Для использования библиотеки необходимо выбрать меню  **Sketch > Import Library**. Одна или несколько директив  **#include**  будут размещены в начале кода скетча с последующей компиляцией библиотек и вместе со скетчем. Загрузка библиотек требует дополнительного места в памяти Arduino. Неиспользуемые библиотеки можно удалить из скетча убрав директиву  **#include**.

На Arduino.cc имеется  [список библиотек](http://out.arduino.ru/?redirect=http%3A%2F%2Farduino.cc%2Fen%2FReference%2FLibraries&baseU=https%3A%2F%2Farduino.ru%2FArduino_environment "список библиотек для Ардуино"). Некоторые библиотеки включены в среду разработки Arduino. Другие могут быть загружены с различных ресурсов. Для установки скачанных библиотек необходимо создать директорию «libraries» в папке блокнота и затем распаковать архив. Например, для установки библиотеки DateTime ее файлы должны находится в подпапке  **/libraries/DateTime**  папки блокнота.

Смотрите  [данную инструкцию](http://out.arduino.ru/?redirect=http%3A%2F%2Farduino.cc%2Fen%2FHacking%2FLibraryTutorial&baseU=https%3A%2F%2Farduino.ru%2FArduino_environment "написание библиотек")  для написания собственной библиотеки.

#### Аппаратные средства других разработчиков

Поддерживаемые аппаратные средства других производителей добавляются в соответствующую подпапку папки блокнота. Устанавливаемые платформы могут включать собственные характеристики (в меню платформы), корневые библиотеки, загрузчик(Bootloader) и характеристики программатора. Для установки требуется распаковать архив в созданную папку. (Запрещено использовать наименование папки "arduino", т.к. могут быть перезаписаны встроенные данные платформы Arduino.) Для деинсталляции данных удаляется соответствующая директория.

Подробная информация по созданию сборок описаний аппаратных средств других производителей находится на  [страницах сайта Google Code](http://out.arduino.ru/?redirect=https%3A%2F%2Fcode.google.com%2Fp%2Farduino%2Fwiki%2FPlatforms&baseU=https%3A%2F%2Farduino.ru%2FArduino_environment "создание сборок аппартных средств").

#### Мониторинг последовательной шины (Serial Monitor)

Отображает данные посылаемые в платформу Arduino (плата USB или плата последовательной шины). Для отправки данных необходимо ввести текст и нажать кнопку Send или Enter. Затем выбирается скорость передачи из выпадающего списка, соответствующая значению  **Serial.begin**  в скетче. На ОС Mac или Linux платформа Arduino будет перезагружена (скетч начнется сначала) при подключении мониторинга последовательной шины.

Имеется возможность обмена информацией с платформой через программы Processing, Flash, MaxMSP и т.д. (см. подробности на странице описаний интерфейсов).

#### Настройки
Некоторые настройки изменяются в окне  **Preferences**  (меню Arduino в ОС Mac или File в ОС Windows и Linux). Остальные настройки находятся в файле, месторасположение которого указано в окне Preferences.

### ThinkerCAD
[ThinkerCAD](https://www.tinkercad.com/) – это онлайн-среда моделирования, позволяющая создавать и тестировать различные электрические схемы без необходимости использования физических компонентов. Это мощный инструмент, который дает возможность разработчикам и электронным инженерам собирать, тестировать и отлаживать схемы, используя виртуальные компоненты и программное обеспечение Arduino.

Один из наиболее популярных применений ThinkerCAD - моделирование работы Arduino. С его помощью можно создавать виртуальные прототипы устройств, создавать алгоритмы и проверять их работоспособность до начала физической реализации проекта. Это позволяет сэкономить время и ресурсы, а также производить быструю отладку и исправление ошибок.
С использованием ThinkerCAD вы можете создавать различные электрические схемы, начиная от базовых, таких как соединение резисторов и светодиодов, до более сложных, включающих микроконтроллеры, датчики и другие электронные компоненты. Программа предлагает широкий спектр оригинальных компонентов, которые можно просто перетащить и разместить на виртуальной плате для создания схемы. В основном окне можно производить сборку схемы из существующих в библиотеке компонентов.
ThinkerCAD также предоставляет возможность программировать микроконтроллеры, такие как Arduino, используя встроенный визуальный инструмент для кодирования. С помощью этого инструмента вы можете создавать скрипты и алгоритмы для контроля и взаимодействия с подключенными компонентами вашей схемы. Визуальное программирование гарантирует простоту использования и позволяет вам сразу же видеть результаты своей работы.

![enter image description here](https://ampermarket.kz/images/tinkercad_inst_5.png)

### Wokwi
[Wokwi](https://wokwi.com/) – это онлайн-симулятор для плат Arduino, Raspberry Pi Pico и ESP32 или даже вашей собственной платы микроконтроллера, предназначенный для изучения программирования без реального оборудования. Wokwi предлагает удобный и интуитивно понятный интерфейс, который позволяет быстро создавать и собирать схемы, а также программировать различные контроллеры, включая Arduino и другие популярные микроконтроллеры.
#### Возможности Wokwi

-   Над микроконтроллерными проектами можно работать прямо из браузера, аппаратные компоненты не нужны.
-   Wokwi имитирует основные платы для прототипирования: Arduino, ESP32 DevKit, Raspberry Pi Pico и другие.
-   Смоделированный проект можно подключить к интернету через MQTT, HTTP, NTP и другиепротоколы.
-   Через встроенный визуальный логический анализатор можно захватить цифровые сигналы в моделировании (например, UART, I2C, SPI) и проанализировать их на своём компьютере.
-   Для прошаренных пользователей есть функция расширенной отладки через GDB и возможность моделирования SD-карты. Код можно сразу запустить в исполнение или внести правки.
-   В сервисе есть огромная база готовых стартовых проектов, где можно посмотреть всё — вплоть до кода с комментариями и описаниями разработчиков.

[![](https://blog.themarfa.name/content/images/2022/09/image-45.png)](https://blog.themarfa.name/content/images/2022/09/image-45.png)

Одной из главных особенностей Wokwi является возможность моделирования и программирования Arduino. С его помощью вы можете создавать виртуальные прототипы устройств, разрабатывать и отлаживать программы и алгоритмы, а также тестировать и проверять работоспособность проектов до их физической реализации. Это не только экономит время и ресурсы, но и позволяет быстро исправлять ошибки и оптимизировать свои проекты. Слева - текстовый редактор, где можно работать с файлами программы(и не только), а справа - непосредственно поле симулятора. Сейчас там только базовая плата. Для того что бы добавить какой-либо элемент необходимо нажать на кнопку "+" и откроется выпадающий список элементов. Wokwi предлагает широкий спектр компонентов, которые можно использовать для создания электронных схем. С его помощью вы можете соединять различные элементы, такие как резисторы, светодиоды, конденсаторы, микроконтроллеры и другие, для создания электрических цепей. Интерфейс Wokwi интуитивно понятен и позволяет легко перемещать и подключать компоненты, а также настраивать их свойства.
И действительно, нам прислали представленный ниже скриншот вместе с размытым видео, показывающим, как светодиодный дисплей обновляется по мере запуска программы в веб-браузере.


![ESP32 MicroPython Simulator](https://cnx-software.ru/wp-content/uploads/2023/04/esp32-micropython-simulator-1024x576.jpg)

Учитывая низкую стоимость плат ESP32 и необходимость в использовании внешних модулей или макетных плат для создания проектов, эмуляторы для данного типа плат не являются необходимостью. 

Следовательно, это может объяснить популярность  [Wokwi](https://wokwi.com/), которая представляет собой отличную платформу для обучения, поддерживающую несколько плат Arduino (Uno, Mega, Nano), Raspberry Pi Pico и универсальную плату ESP32, программированные как на Arduino, так и на MicroPython.

![Wokwi Arduino and Raspberry Pi Pico](https://cnx-software.ru/wp-content/uploads/2023/04/wokwi-arduino-raspberry-pi-pico.png)

Также возможно добавление  [пользовательских плат](https://github.com/wokwi/wokwi-boards), чтобы не ограничиваться официально поддерживаемыми платами. Пользователи могут начинать свои проекты с нуля, выбирая только плату, добавляя компоненты и создавая код самостоятельно, либо использовать существующие проекты, например, проект датчика температуры и влажности ESP32 + DHT22.

![Wokwi ESP32 Simulator](https://cnx-software.ru/wp-content/uploads/2023/04/wokwi-esp32-simulator-1024x731.png)

Доступно графическое представление Arduino, и для запуска моделирования необходимо нажать зеленую кнопку. Результаты температуры и влажности отображаются в виртуальной последовательной консоли.

Также можно добавлять дополнительные компоненты, такие как светодиоды, потенциометры, кнопки, датчики, VCC, GND и другие. Диаграмма также доступна в исходном коде в формате JSON.

![Диаграмма и компоненты в Wokwi](https://cnx-software.ru/wp-content/uploads/2023/04/wokwi-add-components-1024x731.png)

Wokwi предоставляет бесплатные возможности использования, но также доступна  [платная программа Wokwi Club](https://docs.wokwi.com/getting-started/wokwi-club), предлагающая членам возможности, такие как добавление библиотек Arduino, загрузка пользовательских двоичных файлов, подключение к Wi-Fi ESP32 и сохранение проектов в приватном режиме. Участники также могут принимать участие в голосовании за новые функции Wokwi.
## Структура программы 
Базовая структура программы для Arduino довольно проста и состоит, по меньшей мере, из двух частей. В этих двух обязательных частях, или функциях, заключён выполняемый код.
~~~ c++
void setup()
{
	// подготовка
}

void loop()
{
	// выполнение
}
~~~

Перед функцией `setup` - в самом начале программы, обычно, идёт, объявление всех переменных. `setup` - это первая функция, выполняемая программой, и выполняемая только один раз, поэтому она используется для установки режима работы портов `(pinMode())` или инициализации последовательного соединения. Следующая функция `loop` содержит код, который выполняется постоянно — читаются входы, переключаются выходы и т.д. Эта функция — ядро всех программ Arduino и выполняет основную работу.
### `setup()`
Функция `setup()` вызывается один раз, когда программа стартует. Используйте её для установки режима выводов или инициализации последовательного соединения. Она должна быть включена в программу, даже если в ней нет никакого содержания.
```c++
void setup()
{
	pinMode(pin, OUTPUT); // устанавливает пин как выход
}
```
### `loop()`
После вызова функции `setup()` – управление переходит к функции `loop()` , которая делает в точности то, что означает её имя — непрерывно выполняется, позволяя.
```c++
void loop()
{
	digitalWrite(pin, HIGH);
	delay(1000);
	digitalWrite(pin, LOW);
	delay(1000);
}
```
### Комментарии
#### `/*` ... `*/` блок комментария
Блок комментария или однострочный комментарий — это область текста, которая
игнорируется программой и используется для добавления текста с описанием кода
или примечаний. Комментарий помогают другим понять эту часть программы. Он
начинается с `/*` и заканчивается `*/` и может содержать множество строк.

Поскольку комментарии игнорируются программой, а, следовательно, не занимают места в памяти, они могут быть достаточно ёмкими, но кроме того, они
могут использоваться для «пометки» блоков кода с отладочной целью.

**Примечание**: Хотя допускается вставка однострочного комментария в блоке
комментария, второй блок комментария не допускается.

#### `//`однострочный комментарий
Однострочный комментарий начинается с `//` и заканчивается (внутренним) кодом перехода на другую строку. Как и блок комментария, он игнорируется программой и не занимает места в памяти.
`//` вот так выглядит однострочный комментарий
Однострочный комментарий часто используется после действенного выражения, чтобы дать больше информации о том, что выражение выполняет или в качестве напоминания на будущее.
 
1. Комментарии помещаются прямо над кодом**, к которому они относятся. Так проще понять, о чём речь, не вникая в содержание каждой строчки. Совсем короткие пояснения можно писать справа.
```
# определяем общую структуру товара со значениями по умолчанию
product = { 
   "productId": 0, # идентификатор товара, по умолчанию: 0
	"description": "", # описание товара, по умолчанию: пусто
	"categoryId": 0, # категория товара, по умолчанию: 0
	"цена": 0,00 # цена, по умолчанию: 0,00
}
```

2. Комментируют все основные элементы кода:**  модули, функции, константы, глобальные переменные, интерфейсы, классы и их составные элементы (методы, свойства, константы).

3. Пишут коротко и по делу.**  Комментарии без смысловой нагрузки страшно раздражают. Не нужно писать комментарии типа «это гениальный код», «таблица1», «! №; %:? *» и подобные.

>«Опиши комментариями структуру кода». На примере кода программы, складывающей два числа, этот принцип будет выглядеть так:  
```c++
int main()
{
     // Принять от пользователя два числа
     // Завести переменную для результата сложения
     // Вернуть результат сложения

     return 0;
}
``` 
> И лишь когда готов каркас из комментариев, следует писать код который будет реализовывать то, что описано комментариями.  
```c++
int main()
{
     double a,b;
     // Принять от пользователя два числа
     cin>>a;
     cin>>b;
     //Завести переменную для результата сложения
     double sum = a+b;
     // Вернуть результат сложения
     cout<<sum;

     return 0;
}
```
### Функции
Функция — это блок кода, имеющего имя, которое указывает на исполняемый код, который выполняется при вызове функции. Функции `void setup()` и `void loop()` уже обсуждались, а другие встроенные функции будут рассмотрены позже.
Могут быть написаны различные пользовательские функции, для выполнения повторяющихся задач и уменьшения беспорядка в программе. При создании
функции, первым делом, указывается тип функции. Это тип значения, возвращаемого функцией, такой как `int` для целого (integer) типа функции. Если функция не возвращает значения, её тип должен быть `void`. За типом функции следует её имя, а в скобках параметры, передаваемые в функцию.
```c++
type functionName(parameters)
{
	// сделать что то
}
```
Следующая функция целого типа `delayVal()` используется для задания значения паузы в программе чтением значения с потенциометра. Вначале объявляется локальная переменная `v`, затем `v` устанавливается в значение потенциометра, определяемое числом между  `0 — 1023`, затем это значение делится на `4`, чтобы результирующее значение было между `0` и `255`, а затем это значение возвращается в основную программу.
```c++
int delayVal()
{
	int v; //Создаение локальной переменной
	v = analogRead(pin); // считывание значения 
	v /= 4; // конвертируем из 0 - 1023 в 0 - 255
	return v; // возвращаем полученное число
}
```
### `#include` 
Директива, позволяющая подключать в проект дополнительные файлы с кодом.
```c++
#include <Servo.h>  // подключает библиотеку Servo.h
#include "Servo.h"  // подключает библиотеку Servo.h
```
В чём отличие **<>** и **“”**? Когда указываем название **“в кавычках”**, компилятор сначала ищет файл в папке со скетчем, а затем в папке с библиотеками. При использовании **<галочек>** компилятор ищет файл только в папке с библиотеками
### `#define`
Директива, дающая команду препроцессору заменить указанное название на указанное значение. Чаще всего таким образом объявляют константы:
```c++
#define MOTOR_PIN 10 // пин мотора 10
#define LED_PIN 3 // пин светодиода 3
```
После компиляции все встречающиеся в тексте программы слова MOTOR_PIN будут заменены на цифру 10, а LED_PIN – на цифру 3. Такой способ хранения констант **не использует оперативную память микроконтроллера**. Также define позволяет делать т.н. макро функции. Например Ардуиновская функция **sq** (квадрат) является макро, который при компиляции превращается в умножение:
```c++
#define sq(x) ((x)*(x))
```
### `#if`, `#elif`, `#else`, `#endif`
Директивы препроцессору, позволяющие включать или исключать участки кода по условию
```c++
#define TEST 1    // определяем TEST как 1

#if (TEST == 1)   // если TEST 1
#define VALUE 10  // определить VALUE как 10
#elif (TEST == 0) // TEST 0
#define VALUE 20  // определить VALUE как 20
#else             // если нет
#define VALUE 30  // определить VALUE как 30
#endif            // конец условия
```
При помощи условной компиляции очень удобно собирать и настраивать сложные проекты с кучей настроек и библиотек, подключаемых “по условию”. Например:
```c++
#define DEBUG 1
void  setup()  {
#if (DEBUG == 1)
Serial.begin(9600);
Serial.println("Hello!");
#endif
}
```
Если параметру DEBUG установить 1, то будет подключена библиотека Serial, если 0 – то нет. Таким образом получаем универсальный оптимизированный проект с отладкой
### `#ifdef`, `#ifndef`
Условные директивы препроцессору, позволяют включать или исключать участки кода по условию: **ifdef** – определено ли? **ifndef** – не определено ли?
```c++
#define TEST      // определяем TEST 

#ifdef TEST       // если TEST определено 
#define VALUE 10  // определить VALUE как 10 
#else             // если закоммент. #define TEST
#define VALUE 20  // определить VALUE как 20 
#endif            // конец условия
```
### Условия
```c++
// при выполнения одного действия {} необязательны
if  (a > b) c = 10; // если a больше b, то c = 10
else c = 20; // если нет, то с = 20

// вместо сравнения можно использовать лог. переменную
boolean myFlag, myFlag2;
if  (myFlag) c = 10;
// сложные условия
if  (myflag && myFlag2) c = 10; // если оба флага true
// при выполнении двух и более {} обязательны
if  (myFlag)  {
	с = 10;
	b = c;
}  else  {
	с = 20;
	b = a;
}

byte buttonState;

if  (buttonState == 1) a = 10; // если buttonState 1
else  if  (buttonState == 2) a = 20; // если нет, но если buttonState 2
else a = 30; // если и это не верно, то вот
```
Укороченная запись условия:  **(логика) ? правда : ложь**.
```c++
int с = (a > b) ? 10 : -20; // если a > b, то с = 10. Если нет, то с = -20
boolean flag = true;
Serial.println(  (flag) ? ("флаг поднят") : ("флаг опущен")  );```
```
Оператор выбора, заменяет конструкцию с  **else if**.
```c++
switch  (val)  {
	case 1:
		// выполнить, если val == 1
	break;
	case 2:
		// выполнить, если val == 2
	break;
	default:
		// выполнить, если val ни 1 ни 2
		// default опционален
	break;
}
```
### Циклы
#### `for`
Конструкция `for` используется для повторения **блока** выражений, заключённых в фигурные скобки заданное число раз. Наращиваемый счётчик часто используется для увеличения и прекращения цикла. Есть три части, разделённые точкой с запятой, в заголовке цикла for:
```c++
for(инициализация; условие; выражение){
	doSomthing;
}
```
**Инициализация** локальной переменной, или счётчика, имеет место в самом начале и происходит только один раз. При каждом проходе цикла  роверяется **условие**. Если условие остаётся истинным, то следующее **выражение** и **блок** выполняются, а условие проверяется вновь. Когда условие становится ложным, цикл завершается.
```c++
for(int i = 0; i < 10; i++){
	digitalWrite(13, HIGH);
	delay(250);
	digitalWrite(13, LOW);
	delay(250);
}
```
#### `while`
Цикл `while` продолжается, и может продолжаться бесконечно, пока выражение в скобках не станет `false` (ложно). Что-то должно менять проверяемую переменную, иначе из цикла никогда не выйти. И это должно быть в вашем коде, как, скажем, увеличение переменной, или внешнее условие, как, например, проверяемый сенсор.
```c++
while(someVarible ?? value)
{
	doSomething;
}
```

#### `do while`
Цикл `do` управляемый «снизу» цикл, работающий на манер цикла `while`, с тем отличием, что условие проверки расположено в конце цикла, таким образом, цикл выполнится хотя бы один раз.
```c++
do{
	doSomething;
}while(someVarible ?? value)
```
### Переменные
Переменные — это способ именовать и хранить числовые значения для последующего использования программой. Само название - переменные, говорит
о том, что переменные - это числа, которые могут последовательно меняться, в отличие от констант, чьё значение никогда не меняется. Переменные нужно
декларировать (объявлять), и, что очень важно - им можно присваивать значения, которые нужно сохранить. Следующий код объявляет переменную `inputVariable`, а затем присваивает ей значение, полученное от 2-го аналогового порта:
```c++
int inputVarible = 0; // объяляется перменна и
					  // и ей присваи
inputVarible = analogRead(2) // переменная получает значения анологового вывода 2
```
`inputVariabl` — это наша переменная. Первая строка декларирует, что она будет содержать `int`, короткое целое. Вторая строка присваивает ей значение аналогового вывода 2. Это делает значение на выводе 2 доступным в любом месте программы.
Когда переменной присвоено значение, или переприсвоено, вы можете проверить это значение, если оно встречается в некотором условии, или использовать его непосредственно. Рассмотрим пример, иллюстрирующий три операции с переменными. Следующий код проверяет, не меньше ли 100 значение переменной, а если так, переменной `inputVariable` присваивается значение 100, а
затем задаётся пауза, определяемая переменной `inputVariable`, которая теперь, как минимум, равна 100:
```c++
if (inputVarible < 100) // Проверка, не меньше ли 100
{
	inputVarible = 100; // Если так присваем значение
}
delay(inputVarible);
```
#### Типы данных
Переменная – элементарная ячейка для хранения данных (цифр). Переменные разных типов имеют разный “размер ячейки” и имеют разный лимит на размер числа.


Существует еще несколько специальных типов данных для символов. Подробнее можно почитать  [здесь](https://docs.microsoft.com/ru-ru/cpp/cpp/char-wchar-t-char16-t-char32-t?view=vs-2019) и [здесь](https://learn.microsoft.com/ru-ru/cpp/c-runtime-library/standard-types?view=msvc-170).

|Название  | Альт.название  | Размер | Диапазон | Особенность|
|--|--|--|--|--|
|`boolean`  |`bool`  |1 байт| 0 или 1 |Логическая переменная|
|`char`| - | 1 байт| -128 ... 127| Хранит номер символа из таблицы символов ASCII|
|-|`int8_t`| 1 байт |-128 ... 127| Целые числа|
|`byte`|`uint8_t`|1 байт| 0 ... 255|Целые числа|
|`int`|`int16_t`. `short`| 2 байтаа |-32 768 ... 32 767| Целые числа|
|`unsigned int`| `uint16_t`, 'word'| 2 байта| 0 ... 65 535| Целые числа|
|`long`|`int32_t`|4 байта|-2 147 483 648… 2 147 483 647| Целые числа|
|`unsigned long`|`uint32_t`|4 байта|0… 4 294 967 295|Целые числа|
|`float`| - | 4 байта |-3.4E+38 3.4E+38| Числа с плавающей точкой (десятичные дроби). Точность: 6-7 знаков|
|`double`| -| 4 байта| -1.7E+308.. 1.7E+308|Число с плавающей запятой двойной точности|
|-|`int64_t`| 8 байт|-(2^64)/2… (2^64)/2-1|  Целые числа|
|-|`uint64_t`|8 байт|  2^64-1|  Целые числа|

-   `wchar_t`  – 16 битный символ
-   `char16_t`– 2-х байтный char
-   `char32_t`– 4-х байтный char

Также есть такое понятие, как переопределение типов данных (не создавая новых типов), для этого используется ключевое слово  **typedef**.  **Typedef**  работает следующим образом:  **typedef <тип> <имя>;**  – создать новый тип данных <имя> на основе типа <тип>. Пример:
`typedef byte color;`
Создаёт тип данных под названием  **color**, который будет абсолютно идентичен типу  **byte**  (то есть принимать 0-255). Теперь с этим типом можно создавать переменные:
`color R, G, B;`
Создали три переменные типа  **color**, который тот же  **byte**, только в профиль.
#### Массивы
Массив — это набор значений, к которым есть доступ через значение индекса. Любое значение в массиве может быть вызвано через вызов имени массива и
индекса значения. Индексы в массиве начинаются с нуля с первым значением, имеющим индекс 0. Массив нуждается в объявлении, а дополнительно может заполняться значениями до того, как будет использоваться. Схожим образом можно объявлять массив, указав его тип и размер, а позже присваивать значения по позиции индекса:
```c++
int myArray[5];
myArray[3] = 10;
x = myArray[3] // x = 10
```
Массивы часто используются в цикле `for`, где увеличивающийся счётчик применяется для индексации позиции каждого значения. Следующий пример использует массив для мерцания светодиода. Используемый цикл `for` со счётчиком, начинающимся с 0, записывает значение из позиции с индексом 0 массива `flicker[]`, в данном случае 180, на PWM-вывод (широтно-импульсная модуляция) 10; затем пауза в 200 ms, а затем переход к следующей  позиции индекса.
```c++
int ledPin = 10;
byte fliker[] = {180, 30, 255,
				 200, 10, 90,
				 150, 60};
void setup(){
	pinMode(ledPin, OUTPUT);
}

void loop(){
	for(int i = 0; i < 7; i ++){
		analogWrite(ledPin, flicker[i]);
		delay(200);
	}
}
```
#### Спецификаторы переменных 
-   `const`    – константа, такую переменную  **нельзя**  изменить (будет ошибка).  **const int val = 10;**
-  ` static`– позволяет объявить локальную переменную внутри функции, и эта переменная  **не будет заново переобъявляться**  при повторном вызове функции. Эдакая локальная глобальная переменная.  [Info](https://www.arduino.cc/reference/en/language/variables/variable-scope-qualifiers/static/)
-   `volatile`    – указывает компилятору, что переменную не нужно оптимизировать, что её значение может меняться извне. Такой спецификатор должен быть применён к переменным, которые меняют своё значение в прерывании.  [Info](https://www.arduino.cc/reference/en/language/variables/variable-scope-qualifiers/volatile/)
-   `extern` – указывает компилятору, что эта переменная объявлена  **в другом**  файле программы, но мы хотим пользоваться именно ей, а не создавать новую с таким же именем  **в этом**  файле программы. Позволяет читать/записывать в переменные, созданные в других файлах (библиотеках).
##### Структуры 
Структура в языке программирования Си представляет собой составной тип данных, который состоит из других компонентов. При этом в отличие от массива эти компоненты могут представлять различные типы данных. Для определения структуры применяется ключевое слово `struct`, а сам формат определения выглядит следующим образом:
```c++
struct <ярлык>{
<тип>  <имя переменной 1>;
<тип>  <имя переменной 2>;
<тип>  <имя переменной 3>;
};
```
Пример
```c++
// определение структуры person
struct person
{
    int age;
    char * name;
};
 
int main(void)
{
    // По позиции: значения передаются элементам структуры в том порядке, в котором они следуют в структуре:
    struct person tom = {23, "Tom"};
    // По имени: значения передаются элементам структуры по имени, независимо от порядка:
    struct person tom = {.name="Tom", .age=23};
	// Обращение к элементам структуры
	printf("Age: %d \t Name: %s", tom.age, tom.name);
}
```
#### Строки
**String** – очень мощный инструмент для работы со строками, т.е. текстовыми данными. Объявить строку можно несколькими способами:
```c++
String string0 = "Hello String";              // заполняем словами в кавычках
String string1 = String("Hello ") + String("String");  // сумма двух строк
String string2 = String('a');                 // строка из символа в одинарных кавычках
String string3 = String("This is string");    // конвертируем строку в String
String string4 = String(string3 + " more");   // складываем строку string3 с текстом в кавычках
String string5 = String(13);                  // конвертируем из числа в String
String string6 = String(20, DEC);             // конвертируем из числа с указанием базиса (десятичный)
String string7 = String(45, HEX);             // конвертируем из числа с указанием базиса (16-ричный)
String string8 = String(255, BIN);            // конвертируем из числа с указанием базиса (двоичный)
String string9 = String(5.698, 3);            // из float с указанием количества знаков после запятой (тут 3)

// можно формировать название из кусочков, например для работы с файлами
#define NAME "speed"
#define TYPE "-log"
#define EXT ".txt"

// при сложении достаточно указать String 1 раз для первой строки
String filename = String(NAME) + TYPE + EXT;  // filename будет равна speed-log.txt

// доступ к элементу строки работает по такому же механизму, как массив
string1[0] = "a";
// теперь вместо Hello String у нас aello String
```
### Цифровой ввод/вывод
### `pinMode(pin, mode)`
Используется в `void setup ()` для конфигурации заданного вывода, чтобы он работал на вход (`INPUT`) или на выход (`OUTPUT`).
```c++
pinMode(pin, OUTPUT);
```
Цифровые выводы в Arduino предустановлены на вход, так что их нет нужды явно объявлять как `INPUT` с помощью `pinMode()`. Выводы, сконфигурированные как `INPUT`, подразумеваются в состоянии с высоким импедансом (сопротивлением). В микроконтроллере Atmega, есть также удобные, программно доступные
подтягивающие резисторы 20 кОм. Эти встроенные подтягивающие резисторы доступны следующим образом:
```c++
pinMode(pin, INPUT);
digitalWrite(pin, HIGH);
```
Подтягивающие резисторы, как правило, используются при соединении входов с переключателями. Заметьте, что в примере выше нет преобразования `pin` на выход, это просто метод активизации встроенных подтягивающих резисторов. Выводы, сконфигурированные как `OUTPUT`, находятся в низкоимпедансном
состоянии и могут отдавать 40 мА в нагрузку (цепь, другое устройство). Это достаточный ток для яркого
включения светодиода (**не забудьте последовательный токоограничительный резистор!**), но не достаточный для включения реле, соленоидов или моторов. Короткое замыкание выводов **Arduino** или слишком большой ток могут повредить выходы или даже всю микросхему **Atmega**. Порой, не плохая идея — соединять `OUTPUT` вывод через последовательно включённый резистор в 470 Ом или 1 кОм.
### `digitalRead(pin)`
Считывает значение заданного цифрового вывода (`pin`) и возвращает результат `HIGH` или `LOW`. Вывод должен быть задан либо как переменная, либо как константа (0-13).
```c++
value = digitalRead(Pin);
```
### `digitalWrite(pin, value)`
Выводит либо логический уровень `HIGH`, либо `LOW` (включает или выключает) на заданном цифровом выводе pin. Вывод может быть задан либо как переменная, либо как константа (0-13).
```c++
digitalWrite(pin,HIGH);
```
Следующий пример читает состояние кнопки, соединённой с цифровым входом, и включает LED (светодиод), подключённый к цифровому выходу, когда кнопка нажата:
```c++
int led   = 13;
int pin   = 7;
int value = 0;

void setup(){
	pinMode(led, OUTPUT);
	pinMode(pin, INPUT);
}

void loop(){
	value = digitalRead(pin);
	digitalWrite(led, value);
}
```
### `analogRead(pin)`
Считывает значение из заданного аналогового входа (`pin`) с 10-битовым разрешением. Эта функция работает только на аналоговых портах (0-5). Результирующее целое значение находится в диапазоне от 0 до 1023.
```c++
value = analogRead(pin);
```
>Примечание: Аналоговые выводы не похожи на цифровые, и нет необходимости предварительно объявлять их как `INPUT` или `OUTPUT` (если только вы не планируете использовать их в качестве цифровых портов 14-18).
### `analogWrite(pin, value)`
Записывает псевдо-аналоговое значение, используя схему с широтно-импульсной модуляцией (`PWM`), на выходной вывод, помеченный как `PWM`. На новом модуле **Arduino** с **ATmega168 (328)**, эта функция работает на выводах 3, 5, 6, 9, 10 и 11. Старый модуль **Arduino** c **ATmega8** поддерживает только выводы 9, 10 и 11. Значение может быть задано как переменная или константа в диапазоне 0-255.
```c++
analogWrite(pin, value);
```
Значение 0 генерирует устойчивое напряжение 0 вольт на выходе заданного вывода; значение 255 генерирует 5 вольт на выходе заданного вывода. Для значений между 0 и 255 вывод быстро переходит от 0 к 5 вольтам — чем больше значение, тем чаще вывод в состоянии `HIGH` (5 вольт). Например, при значении 64 вывод будет в 0 три четверти времени, а в состоянии 5 вольт одну четверть; при значении 128 половину времени будет вывод будет в 0, а половину в 5 вольт; при значении 192 четверть времени вывод будет в 0 и три четверти в 5 вольт.
Поскольку эта функция схемная (встроенного модуля), вывод будет генерировать устойчивый сигнал после вызова `analogWrite` в фоновом режиме, пока не будет следующего вызова `analogWrite` (или вызова `digitalRead` или `digitalWrite` на тот же вывод).
> Примечание: Аналоговые выводы, не такие как цифровые, и не требуют
предварительной декларации их как `INPUT` или `OUTPUT`.

Следующий пример читает аналоговое значение с входного аналогового вывода,
конвертирует значение делением на 4 и выводит `PWM` сигнал на `PWM` вывод:

```c++
int led = 10;
int pin = 0;
int value;
void setup(){}
void loop(){
	value = analogRead(pin);
	value /=4;
	analogWrite(led, value);
}
```
## Приложение
### Цифровой выход

Это базовая программа «`hello world`», используемая для включения и выключения чего-нибудь. В этом примере светодиод подключён к выводу 13 и мигает каждую секунду. Резистор в данном случае может быть опущен, поскольку на 13-м порту **Arduino** уже есть встроенный резистор.
```c++
int ledPin = 13;

void setup(){
	pinMode(ledPin, OUTPUT);
}
void loop{
	digitalWrite(ledPin, HIGH);
	delay(1000);
	digitalWrite(ledPin, LOW);
	delay(1000);
}
```
### Цифровой ввод

Это простейшая форма ввода с двумя возможными состояниями: включено или выключено. В примере считывается простой переключатель или кнопка, подключённая к выводу 2. Когда выключатель замкнут, входной вывод читается как `HIGH` и включает светодиод.
```c++
int ledPin = 13; 
int inPin = 2;
void setup(){
	pinMode(ledPin, OUTPUT);
	pinMode(inPin, INPUT);
}
void loop(){
	if(digitalRead(inPin) == HIGH){
		digitalWrite(ledPin, HIGH);
		delay(1000);
		digitalWrite(ledPin, LOW);
		delay(1000);
	}
}
```
### Сильноточный выход

Иногда возникает необходимость в управлении более, чем 40 мА от `Arduino`. В этом случае может использоваться транзистор **MOSFET** для коммутации сильноточной нагрузки. В следующем примере **MOSFET** быстро включается и выключается 5 раз в секунду.
> Примечание: Схема показывает мотор и диод защиты, но другие, не индуктивные,
нагрузки могут включаться без диода.
```c++
int outPin = 5;

void setup(){
	pinMode(outPin, OUTPUT);
}

void loop(){
	for(int i = 0; i <= 5; i++){
		digitalWrite(outPin, HIGH);
		delay(250); // 1/4 sec
		digitalWrite(outPin, HIGH);
		delay(250); // 1/4 sec
	}
	delay(1000); // 1 sec
}
```
### `PWM` выход
Широтно-импульсная модуляция (`PWM`) — это способ имитировать аналоговый выход с помощью импульсного сигнала. Это можно использовать для гашения и увеличения яркости светодиода или позже для управления сервомотором. Следующий пример медленно увеличивает яркость и гасит LED, используя цикл `for`.
```c++
int ledPin = 9;
void setup(){}
void loop(){
	for(int i = 0; i <= 255; i++){
		analogWrite(ledPin, i);
		delay(100);
	}
	for(int i = 0; i <= 255; i--){
		analogWrite(ledPin, i);
		delay(100);
	}
}
```
### Вход с потенциометра

Использование потенциометра и одного из аналоговых портов **Arduino** (аналого- цифрового преобразователя (`ADC`) позволяет читать аналоговые значения в диапазоне 0-1023. Следующий пример показывает использование потенциометра для управления временем мигания светодиода LED.
```c++
int potPin = 0;
int ledPin = 13;

void setup(){
	pinMode(ledPin, OUTPUT);
}

void loop(){
	digitalWrite(ledPin, HIGH);
	delay(analogRead(potPin));
	digitalWrite(ledPin, LOW);
	delay(analogRead(potPin));
}
```
### Вход от переменного резистора

Переменные резисторы включают фотоприёмники, термисторы, тензодатчики и т.д. Данный пример использует функцию чтения аналогового значения и задаёт время паузы. Этим управляется скорость, с которой меняется яркость светодиода LED.
```c++
int ledPin 	  = 9;
int analogPin = 0;

void setup(){}

void loop(){
	for(int i = 0; i <= 255; i++){
		analogWrite(ledPin, i);
		delay(delayVal());
	}
	for(int i = 0; i <= 255; i--){
		analogWrite(ledPin, i);
		delay(delayVal());
	}
}

int delayval(){
	int v = 0;
	v = analogRead(analogPin);
	v /= 8;
	return v;
}
```
### Cерво вывод

Любительские сервомашинки — это разновидность полу-автономного мотор-редуктора, который может поворачиваться на 180. Всё, что нужно — это отправлять импульсы каждые 20 мС. В данном примере используется функция `servoPulse` для поворота мотора от 100 до 170 и обратно.
```c++
int servoPin   = 2;
int myAngle    = 0;
int pulseWidth = 0;

void setup(){
	pinMode(servoPin, OUTPUT);
}

void servoPulse(int servoPin, int myAngle){
	pulseWidth = (myAngle * 10) + 600;
	digitalWrite(servoPin, HIGH);
	delayMicroseconds(pulseWidth);
	digitalWrite(servoPin, LOW);
}

void loop(){
	for(myAngle = 10; myAngle <= 170; myAngle--){
		servoPulse(servoPin, myAngle);
		delay(20);
	}
}
```

### Дребезг контактов
Кнопка – один из самых популярных и простых видов датчиков. В основе работы любой кнопки лежит механический способ смыкания-размыкания контактов. Нажимая на любую, даже самую простую тактовую кнопку, мы формируем определенное давление на внутренние механизмы (пластины или пружины), в результате чего происходит сближение или расхождение металлических пластин.

[![Дребезг кнопки](https://arduinomaster.ru/wp-content/uploads/2017/11/68747470733a2f2f7261772e6769746875622e636f6d2f74686f6d617366726564657269636b732f426f756e63652d41726475696e6f2d576972696e672f6d61737465722f426f756e63795377697463685f6c6f636b6f75742e706e67-300x169.png "68747470733a2f2f7261772e6769746875622e636f6d2f74686f6d617366726564657269636b732f426f756e63652d41726475696e6f2d576972696e672f6d61737465722f426f756e63795377697463685f6c6f636b6f75742e706e67")](https://arduinomaster.ru/wp-content/uploads/2017/11/68747470733a2f2f7261772e6769746875622e636f6d2f74686f6d617366726564657269636b732f426f756e63652d41726475696e6f2d576972696e672f6d61737465722f426f756e63795377697463685f6c6f636b6f75742e706e67.png)

Мы люди взрослые и хорошо понимаем, что идеального в мире ничего не существует, в том числе идеально гладких поверхностей, контактов без неровностей, сопротивления и паразитной емкости. В нашем неидеальном мире в момент нажатия на кнопку в месте соединения контакты не соприкасаются мгновенно, микро-неровности на поверхности не позволяют пластинам мгновенно соединиться. Из-за этого в короткий промежуток времени на границе пластинок меняется и сопротивление, и взаимная емкость, из-за чего возникают масса разнообразных изменений уровня тока и напряжения. Другими словами, возникают очень интересные, хотя и не очень приятные процессы, которые в электротехнике называют переходными.

![Иллюстрация дребезга кнопки](https://arduinomaster.ru/wp-content/uploads/2017/11/Bounce_001.png "Bounce_001")

Переходные процессы протекают очень быстро и исчезают за доли миллисекунд. Поэтому мы редко их замечаем, например, когда включаем свет в комнате. Лампа накаливания не может менять свою яркость с такой скоростью, и тем более не может реагировать на изменения наш мозг. Но, обрабатывая сигал от кнопки на таком быстром устройстве, как Arduino, мы вполне можем столкнуться с такими переходными эффектами и должны их учитывать при программировании.

[![Дребезг контактов кнопки ардуино и его подавление и удаление](https://arduinomaster.ru/wp-content/uploads/2017/11/pic_6_1.gif "pic_6_1")](https://arduinomaster.ru/wp-content/uploads/2017/11/pic_6_1.gif)

В идеальном мире форма сигнала после нажатия на кнопку должна быть строго прямоугольная. В реальных же условиях вместе резкого перехода мы видим множество пиков и спадов. 
#### Как мы можем бороться с дребезгом?
Нужно, чтобы при любом состоянии кнопки, с неё считывалось однозначное значение. В этом нам помогут подтягивающие или стягивающие резисторы. Физически они ничем не отличаются друг от друга, главное чтобы они были большого номинала, например 10 кОм. Все различия заключаются в том, в какое именно место в схеме мы их подключаем. Итак, давайте рассмотрим каждый в отдельности. 

Итак, отсутствие подтяжки и дребезг — физически разные явления. Первое, или «висящий» контакт — случай, когда из-за отсутствия явного сигнала на входе состояние входа может интерпретироваться как угодно. Второе — когда при появлении сигнала на входе этот самый сигнал, прежде чем прийти к окончательному состоянию, какое-то время колеблется.

##### Висящий  контакт.

##### Аппаратно.

При  этом  подтяжка  может  быть  как  внешней, так  и  внутренней; например, в  **Arduino**  она  включается  командой
```c++
pinMode (pin, INPUT_PULLUP);
```
В  целом  предпочительной  является  внешняя  подтяжка, однако  иногда  удобно  использовать  внутреннюю (для  экономии  деталей  либо  если  нужно  менять  функцию  вывода  МК  в  процессе  работы).

##### Дребезг контакта

С  дребезгом: либо  **аппаратно (конденсатор  параллельно  кнопке  либо  между  входом  и  полюсом  питания; триггер  Шмитта)**, либо  **программно (многократный  опрос  состояния  входа)**.

Пример 1.

Подтяжка  к  минусу, но  дребезг  не  остается.

![](https://lh4.googleusercontent.com/cCAj4XJbw8krYqwZ6FGNBxOpbbZTOPm4sdHpKe1WBhRT8EjcTaBfrcBs8EN6vaZLjaDA0qI4sIv9EaznuVjjXIB6GASdhqWusNaPSADtHs1b2vIGtWtqsI463hhj2SRlpF86n_OR8671Zh6yvs7c0kc)

Видно, что  без  конденсатора  кнопка, прежде  чем  подать  сигнал  на  вход, разок  проваливается  до  середины  напряжения  питания, потом  почти  до  нуля, и  лишь  затем  выдаёт  что-то  похожее  на  логическую  единицу. При  этом  МК  явно  увидит  два  нажатия  вместо  одного, и, если  по  нажатию  нам  нужно  переключать  состояние  лампочки, то  она  включится  меньше, чем  на  миллисекунду.

Пример 2.

Дребезг  гасится  конденсатором  параллельно  стягивающему  резистору

![](https://lh4.googleusercontent.com/CFirbFNkz1QLb63gIloYzIW4RX01wvtLFdKYy94kVy1y0ch9goBz9Dql9kuc-GkUD-q2QJzC2XpggHlRFOJCMmeYH6eb_gvnF7MaBn1-Wx6ogT7TJjSZgkCAp6BQ3Pt8kJq88BDpS2BQWZS-hoKsD8o)

Пример 3.

![](https://lh6.googleusercontent.com/gCRGggofsvILeLIbaaPRsVvrsVx-KwiaMP5g0XOYhSva1a5w1IolbhIYl9Fcfk1JVJAHiO-52tBtpfdWg8v7ikcbLPyOGwGXGfYNeeo-iHbq_-D92MyiUNEagr2olXYkMTFVqU3Nf-jZ0MKDwawXAiE)

Дребезг  гасится  конденсатором  параллельно  кнопке. К  слову, величина  конденсатора  здесь  порядка  единиц  пикофарад.

К  слову  о  триггере  Шмитта. Так-то  он  уже  встроен  в  МК (и  теоретически  при `digitalRead` чтение  идёт  именно  с  него). Проблема  в  том, что  он  помогает  при  небольших  колебаниях  вокруг Vcc/2, то  есть  при  весомых  колебаниях (плохая  кнопка) он  не  очень  поможет. Ну, или  внешний  триггер  с  известными  параметрами.

##### Программные  способы  борьбы  с  дребезгом

В  целом  — многократный  опрос  с  целью  проверить, точно  ли  мы  получили  нажатие  кнопки  или  оно  где-то `в  процессе`. В  примерах  предполагаю, что  подтяжка  к `+`, а  кнопка  соединяет  `pin`  с  номером `pin` с  минусом.

Самый  простой  вариант
```c++
void loop(){
	uint8_t button_state_1 =  0, button_state_2 =  0;
	button_state_1 = digitalRead(pin);  /* Проверяем  состояние  входа */
	delay (300);  /* Выжидаем 300 мс */
	button_state_2 = digitalRead(pin);  /* Проверяем  ещё  разок */
	if(button_state_1 == button_state_2){
	//Два  раза  подряд  отсчёты  были  одинаковы, стало  быть, кнопка  точно  либо  нажата (0), либо  отпущена (1)
	}
}
```
##### Вариант  получше

Лучше, в  первую  очередь, тем, что  позволяет  различать  короткие  и  длинные  нажатия (скажем, если  взять `uint16_t`, то  вполне  удобно  использовать  маску `0x0ff0` для  короткого  нажатия; можно  и c восемью  битами, только  маску  правильно  написать).
```c++
enum  { button_read_period =  10  };  /* опрашивать  состояние  будем  каждые 10 мс */
void loop(){
	static  uint8_t button_state =  0;  /* Состояние  кнопки; каждый  бит  соответствует  состоянию  входа  в  очередной  момент  времени */
	static  uint32_t ts =  0;  /* здесь  храним  момент  последнего  отсчёта */
	if  ( millis()  - ts > button_read_period )  /* Если  с  момента  последнего  отсчёта  прошло  более button_read_period миллисекунд */{
		ts = millis();  /* Запоминам  этот  момент */
		button_state <<=  1;  /* сдвигаем  текущее  состояние  на  один  бит  влево, «забывая» самое  старое  значение*/
		button_state |= digitalRead(pin);  /* И  в  крайний  правый  бит  записываем  текущий  отсчёт*/
	}
	switch(button_state){
		case  0xff:  /*то  есть  все  биты «1» — последние 8 отсчётов  кнопка  была  отпущена*/
			/*Кнопка  отпущена  в  течение  минимум (button_read_period * 8) миллисекунд*/
			break;
		case  0:  // то  есть  все  биты «0» — последние 8 отсчётов  кнопка  была  нажата
			/*Кнопка  нажата  в  течение  минимум (button_read_period * 8) миллисекунд*/
			break;
		default:
		/*Кнопка  в  процессе  переключения;*/
			break;
		}
}
```
  
Тут  всё  немного  лучше, хотя  провал  тоже  есть (на  первом  развёртка  была 100мкс/дел, а  здесь  — 5мкс/ дел, то  есть  в  этом  случае  помеха  гасится  немного  быстрее, но  тоже  вполне  даёт  МК  шанс  уловить  ложное  срабатывание  кнопки).

Стягивающий резистор - резистор, который соединяет нужный нам участок цепи с землей.

![](https://lh3.googleusercontent.com/sPMZ6NMNQU-yYy8z_CBbdtm7Ha5N_mf0cTZKnTNwvYO5eDOV09EEvNIsY-LebiH1mtd1NQden-VOdgI8SFK7Ihx2WG4YTrJd9mjjLqUJpmAUrGpd3Ufe8_B6Cjw7NJFVQk1MoNA6h5xbrqw4btmsBg)

Подключение стягивающего резистора к схеме 

Пока кнопка отжата, стягивающий резистор дает на `pin` стабильную землю. Но если нажать кнопку, ток пойдет по пути наименьшего сопротивления, и значение на `pin` станет `HIGH`. Этот резистор поэтому и называется стягивающим, потому что в неопределенном состоянии стягивает потенциал к `GND`.

По аналогии подтягивающий резистор подтягивает неопределенный потенциал ко входу с напряжением 5 В, делая его определенным - `HIGH`.
![](https://lh6.googleusercontent.com/sA16dgS4ZtsGhFMxnlTIxaPoy3s-Nv2apyOUteGhb5uaatKoFAJ1-EtfTEryfx0alMAZktuCic2yz7EhscL1LMVp5ecETvpiubq74dU8t0vGAGRtX7LQocWatDp6fz0omZrYLe-PrpaxQiIZisG9Rg)

Подключение подтягивающего резистора к схеме  

Пока кнопка не нажата, подтягивающий резистор дает стабильные 5 В.

Плата **Arduino Uno** на портах ввода/вывода имеет встроенные подтягивающие резисторы номиналом 20 КОм, которые можно включить программно, выглядит это так:

```c++
pinMode(pin, INPUT_PULLUP)
```

Давайте сделаем так: лучше всего дребезг контактов можно показать на обычной механической кнопке. Подключим кнопку и светодиод, и напишем небольшой код.

![](https://lh4.googleusercontent.com/W0D6VdWuoHCEkuksV3KPerwMKTKJiDjRSrAyWdbP2KBT_Djq0Tt1ofOeO37EsbMT3iZCEGaQFM05hB2LYtpMFsmcOu06yonjEB5GrkzwE2UYS9_ngWJ0vf6Zi6kwBa3h4cKdK0HjRHc4floy4IKKyA)

Подключение тактовой кнопки к схеме
```c++
int buttonState = 0;
void setup() {
	pinMode(2, INPUT);
	pinMode(13, OUTPUT);
}
void loop() {
	buttonState = digitalRead(2);
	if (!buttonState == HIGH) {
		digitalWrite(13, HIGH);
	}
	else {
		digitalWrite(13, LOW);
	}
}
```

## Введение в АЦП
![Принцип работы АЦП](https://www.lcard.ru/sites/default/files/styles/termin_style_image/public/TERMINS/adc_termin_0.png?itok=UauFjZLk)
Аналого-цифровой преобразователь (АЦП, Analog-to-digital converter, ADC) — устройство, преобразующее входной аналоговый сигнал в  _цифровой сигнал_  (в цифровой  _двоичный код_). Для задач измерения значения сигнала в произвольный момент времени используют  _асинхронный режим_  работы с АЦП с жестко не привязанными по времени одиночными аналого-цифровыми преобразованиями. Для задач измерения функциональной зависимости изменения аналогового сигнала используют  _синхронный режим_  работы АЦП. Синхронный режим работы АЦП без пропусков данных на сколь угодно большом интервале времени называют также  _потоковым режимом_. Синхронные АЦП, как правило, поддерживают  _покадровый принцип сбора данных_, когда оцифрованные отчёты измерения образуют условные кадры с заданным количеством отсчётов, соответствующих заданным каналам измерения.

АЦП является неотъемлемой частью  [системы сбора данных](https://www.lcard.ru/lexicon/data_acquisition_system).

**Основные параметры АЦП:**

-   Входной _диапазон сигнала ([диапазон измерения](https://www.lcard.ru/lexicon/spec_meas_range))_.
-   _Частота преобразования_ [Гц] – частота следования аналого-цифровых преобразований. В терминологии  [ЦОС](https://www.lcard.ru/lexicon/dig_sig_processing)  частота преобразования АЦП называется частотой дискретизации сигнала в его цифровом представлении.
-   _Период преобразования_ [c] = [1/Гц] – величина, обратная частоте преобразования. В терминологии ЦОС период преобразования АЦП является периодом преобразования сигнала в его цифровом представлении. Для  [асинхронных](https://www.lcard.ru/lexicon/sync_async_io)  АЦП нормируется время преобразования.
-   _[Полоса частот](https://www.lcard.ru/lexicon/freq_band)  пропускания_  АЦП [Гц]…[Гц]. Это диапазон частот сигнала, который пропускает преобразователь по уровню сигнала -3 дБ.
-   _Разрядность АЦП_  – количество N двоичных разрядов преобразователя, при этом количество _уровней квантования_ сигнала в цифровом представлении АЦП равно 2N.
-   _Соотношение сигнал/шум_ канала преобразования АЦП [дБ]
-   Технология АЦП. Типичные представители: _АЦП последовательного приближения, сигма-дельта АЦП_.
-   _Межканальное прохождение_ [дБ].

Верхняя частота полосы частот пропускания _АЦП последовательного приближения_ может быть значительно больше _частоты преобразования АЦП_, а верхняя частота _полосы частот пропускания_ сигма-дельта АЦП не превышает половины частота преобразования АЦП.

АЦП различаются типами входов. Чаще встречаются АЦП с  [входом напряжения](https://www.lcard.ru/lexicon/voltage_input), реже – с  [входом тока](https://www.lcard.ru/lexicon/current_input)  или  [входом заряда](https://www.lcard.ru/lexicon/charge_input).

Многоканальные АЦП строятся по принципу независимых параллельных каналов АЦП или по принципу АЦП с коммутацией каналов.

АЦП с коммутацией каналов разделяются на  [АЦП с входным коммутатором каналов](https://www.lcard.ru/lexicon/d16_se32)  (у которых коммутационный процесс происходит непосредственно в  _измерительной цепи_) и на АЦП с внутренним коммутатором, например, как у  [E20-10](https://www.lcard.ru/products/external/e20-10) (у которых  _коммутационный процесс_  происходит внутри и  _измерительную цепь_  не затрагивает).

Важной характеристикой АЦП является наличие [_гальванической изоляции_](https://www.lcard.ru/lexicon/galvanic_isolation) входной сигнальной цепи. Для АЦП с  _входом напряжения_  важной характеристикой является тип входа напряжения: _[дифференциальный вход](https://www.lcard.ru/lexicon/diff_input),  [вход с общей землёй](https://www.lcard.ru/lexicon/com_gnd_input)_.

По потребительским свойствам все АЦП можно разделить на  _АЦП общего применения_  и  _специализированные АЦП_. Для общего применения больше всего подходят АЦП, имеющие дифференциальные входы напряжения и гальваноразвязку ([LTR11](https://www.lcard.ru/products/ltr/ltr11),  [LTR24-1](https://www.lcard.ru/products/ltr/ltr24)). К специализированным АЦП можно отнести преобразователи, имеющие специальный вход специфического датчика (например, тензометрического – [LTR212](https://www.lcard.ru/products/ltr/ltr212),  [LTR216](https://www.lcard.ru/products/ltr/ltr216), или ICP-датчика – [LTR25](https://www.lcard.ru/products/ltr/ltr25)), либо предназначенные для выполнения специальных функций (например, измерение частоты – [LTR51](https://www.lcard.ru/products/ltr/ltr51)). В то же время, у  _АЦП общего применения_  могут присутствовать специализированные режимы (каналы) измерения (например, измерение сопротивления модулем  [LTR114](https://www.lcard.ru/products/ltr/ltr114)).
### Функции
`AnalogRead(<номер порта>)`
-   номер порта – номер аналогового порта, с которого мы будем считывать значение
Возвращаемое значение: число типа int в диапазоне от 0 до 1023, так как у `Arduino Uno` 10-битный АЦП
```c++
analogRead(A0); // считать сигнал с аналогового порта A0
analogRead(15); // аналогично, порт 15 и A0 – это одно и то же
```
### Примеры

#### Преобразование значения с помощью функции map()

В `Arduino` есть специальная функция, упрощающая преобразование диапазонов значений. Вы передаете ей значение и два диапазона (исходный и требуемый), а функция возвращает новое значение, которое будет также относиться к границам требуемого диапазона как и к границам исходного. Например, значение 5 в диапазоне от 0 до 10 преобразуется в значение 10 в диапазоне от 0 до 20. Значение 500 из диапазона от 0 до 1000 преобразуется в значение 5 из диапазона от 0 до 10.

Пример использования функции `map` совместно с функцией `analogRead ()`:

`int val = map(analogRead(A0), 0, 1023, 1, 10);` Вернет значение аналогового порта в диапазоне от 0 до 10. При этом 0 будет соответствовать 0, а 10 – 1023.

1.  Пример чтения значения с АЦП и вывод его в Serial Monitor:

```cpp
const int adcPin = A0; // Пин, к которому подключен сигнал АЦП

void setup() {
  Serial.begin(9600); // Инициализация Serial Monitor
}

void loop() {
  int adcValue = analogRead(adcPin); // Чтение значения с АЦП
  Serial.println(adcValue); // Вывод значения в Serial Monitor
  delay(500); // Задержка 0.5 секунды
}

```

2.  Пример использования АЦП для управления светодиодом:

```cpp
const int adcPin = A0; // Пин, к которому подключен сигнал АЦП
const int ledPin = 9; // Пин, к которому подключен светодиод

void setup() {
  pinMode(ledPin, OUTPUT); // Устанавливаем пин светодиода в режим OUTPUT
}

void loop() {
  int adcValue = analogRead(adcPin); // Чтение значения с АЦП
  int brightness = map(adcValue, 0, 1023, 0, 255); // Преобразование значения в диапазон яркости светодиода (0-255)
  analogWrite(ledPin, brightness); // Установка яркости светодиода
}

```

3.  Пример использования АЦП для контроля температуры с помощью термистора:

```cpp
const int adcPin = A0; // Пин, к которому подключен сигнал АЦП

void setup() {
  Serial.begin(9600); // Инициализация Serial Monitor
}

void loop() {
  int adcValue = analogRead(adcPin); // Чтение значения с АЦП
  float voltage = adcValue * (5.0 / 1023.0); // Преобразование значения в напряжение
  float temperature = (voltage - 0.5) * 100; // Расчет температуры по формуле
  Serial.println(temperature); // Вывод значения температуры в Serial Monitor
  delay(1000); // Задержка 1 секунда
}

```

4.  Пример использования АЦП для измерения освещенности с помощью фоторезистора:

```cpp
const int adcPin = A0; // Пин, к которому подключен сигнал АЦП

void setup() {
  Serial.begin(9600); // Инициализация Serial Monitor
}

void loop() {
  int adcValue = analogRead(adcPin); // Чтение значения с АЦП
  Serial.println(adcValue); // Вывод значения освещенности в Serial Monitor
  delay(1000); // Задержка 1 секунда
}
```
### Простая фильтрация
По разным причинам (например, некачественный источник питания, наводки и т. д.) мы можем наблюдать шум. То есть, когда мы считываем положение потенциометра, показания колеблются в каких то пределах. Этого можно избежать, фильтруя входной сигнал, и для этого есть несколько способов.

#### Среднее арифметическое

Один из самых простых способов. Суммируем значения, делим на количество измерений, тем самым добиваясь усреднения значений
```c++
const int NUMS = 30; // кол-во значений, которое мы будем суммировать, “сила фильтра”
int srArif() {
	long sum = 0;
	for (int i = 0; i<NUMS; i++)
	sum += analogRead(A0);
	return ((float)sum/NUMS);
}
```
#### Бегущее среднее

Работает по принципу буфера, в котором хранит несколько предыдущих значений. При каждом вызове буфера самое старое значение стирается, а самое новое добавляется, а после происходит усреднение по принципу среднего арифметического. Один из наиболее часто используемых фильтров.
```c++
void setup() {
	Serial.begin(9600);
}

float val = 0;

void loop() {
	int newVal = analogRead(A0);
	val += (newVal - val)*0.1;
	Serial.print(newVal);
	Serial.print(‘ , ’);
	Serial.println(val);
}
```
1.  Пример фильтра скользящего среднего для сглаживания значений АЦП:

```cpp
const int adcPin = A0; // Пин, к которому подключен сигнал АЦП

const int numReadings = 10; // Количество считываемых значений АЦП для фильтрации
int readings[numReadings]; // Массив для хранения считанных значений
int index = 0; // Индекс текущего считываемого значения

void setup() {
  Serial.begin(9600); // Инициализация Serial Monitor

  for (int i = 0; i < numReadings; i++) {
    readings[i] = 0; // Инициализация массива значений
  }
}

void loop() {
  int adcValue = analogRead(adcPin); // Чтение значения с АЦП
  // Удаление старого значения
  int total = 0;
  for (int i = 0; i < numReadings - 1; i++) {
    readings[i] = readings[i + 1];
    total += readings[i];
  }

  // Добавление нового значения
  readings[numReadings - 1] = adcValue;
  total += readings[numReadings - 1];

  // Вычисление среднего значения
  int average = total / numReadings;

  Serial.println(average); // Вывод среднего значения в Serial Monitor
  delay(1000); // Задержка 1 секунда
}
```

2.  Пример фильтра экспоненциального сглаживания для сглаживания значений АЦП:

```cpp
const int adcPin = A0; // Пин, к которому подключен сигнал АЦП
float smoothedValue = 0; // Сглаженное значение

void setup() {
  Serial.begin(9600); // Инициализация Serial Monitor
}

void loop() {
  int adcValue = analogRead(adcPin); // Чтение значения с АЦП
  // Вычисление сглаженного значения
  smoothedValue = (0.9 * smoothedValue) + (0.1 * adcValue);
  Serial.println(smoothedValue); // Вывод сглаженного значения в Serial Monitor
  delay(1000); // Задержка 1 секунда
}

```

3.  Пример фильтра нижних частот (RC-фильтр) для сглаживания значений АЦП:

```cpp
const int adcPin = A0; // Пин, к которому подключен сигнал АЦП
const float alpha = 0.1; // Коэффициент сглаживания
float smoothedValue = 0; // Сглаженное значение

void setup() {
  Serial.begin(9600); // Инициализация Serial Monitor
}

void loop() {
  int adcValue = analogRead(adcPin); // Чтение значения с АЦП
  // Вычисление сглаженного значения
  smoothedValue = (alpha * adcValue) + ((1 - alpha) * smoothedValue);
  Serial.println(smoothedValue); // Вывод сглаженного значения в Serial Monitor
  delay(1000); // Задержка 1 секунда
}

```

4.  Пример фильтра Медианного фильтра для сглаживания значений АЦП:

```cpp
const int adcPin = A0; // Пин, к которому подключен сигнал АЦП

const int numReadings = 5; // Количество считываемых значений АЦП для фильтрации
int readings[numReadings]; // Массив для хранения считанных значений
int index = 0; // Индекс текущего считываемого значения

void setup() {
  Serial.begin(9600); // Инициализация Serial Monitor

  for (int i = 0; i < numReadings; i++) {
    readings[i] = 0; // Инициализация массива значений
  }
}

void loop() {
  int adcValue = analogRead(adcPin); // Чтение значения с АЦП

  // Заполняем массив считанными значениями
  readings[index] = adcValue;
  index = (index + 1) % numReadings;

  // Сортируем массив значений
  for (int i = 0; i < numReadings - 1; i++) {
    for (int j = i + 1; j < numReadings; j++) {
      if (readings[i] > readings[j]) {
        int temp = readings[i];
        readings[i] = readings[j];
        readings[j] = temp;
      }
    }
  }

  // Вычисляем медиану массива значений
  int medianIndex = numReadings / 2;
  int medianValue = readings[medianIndex];

  Serial.println(medianValue); // Вывод медианного значения в Serial Monitor
  delay(1000); // Задержка 1 секунда
}
```
5. Фильтр [Каламана](https://en.wikipedia.org/wiki/Kalman_filter)
```c++
// ADC pin
const int adcPin = A0;

// Kalman Filter variables
float currentEstimate = 0;     // Filtered state variable
float errorEstimate = errorMeasure;
float lastEstimate = 0;
// Process noise
const float q = 0.1;
// Measurement noise
const float r = 10;

void setup() {
  Serial.begin(9600); 
  // Set ADC pin as input
  pinMode(adcPin, INPUT);
}

void loop() {
  // Read ADC value
  int rawValue = analogRead(adcPin);
  
  // Apply the simpleKalman function
  float filteredValue = simpleKalman(rawValue);
  // Print filtered value to Serial monitor
  Serial.println(filteredValue);
  // Delay for visualization purposes
  delay(100);
}

float simpleKalman(float newVal) {
  // Calculate the Kalman gain
  float kalmanGain = errorEstimate / (errorEstimate + errorMeasure);
  // Update the current estimate
  float updatedEstimate = lastEstimate + kalmanGain * (newVal - lastEstimate);
  // Update the error estimate
  errorEstimate = (1.0 - kalmanGain) * errorEstimate + fabs(lastEstimate - updatedEstimate) * q;
  // Update the last estimate
  lastEstimate = updatedEstimate;
  return updatedEstimate;
}
```

6. Альфа фильтр
```c++
// ADC pin
const int adcPin = A0;

// Alpha value
const float alpha = 0.2;

// Previous estimate
float prevEstimate = 0;

float alphaFilter(float newVal) {
  // Calculate the current estimate
  float currentEstimate = alpha * newVal + (1 - alpha) * prevEstimate;

  // Update the previous estimate
  prevEstimate = currentEstimate;

  return currentEstimate;
}

void setup() {
  Serial.begin(9600);
  
  // Set ADC pin as input
  pinMode(adcPin, INPUT);
}

void loop() {
  // Read ADC value
  int rawValue = analogRead(adcPin);
  
  // Apply the alphaFilter function
  float filteredValue = alphaFilter(rawValue);
  
  // Print filtered value to Serial monitor
  Serial.println(filteredValue);
  
  // Delay for visualization purposes
  delay(100);
}

```
7.  [Альфа-Бета фильтр](https://en.wikipedia.org/wiki/Alpha_beta_filter)
```c++
// ADC pin
const int adcPin = A0;

// Alpha and Beta values
const float alpha = 0.5;
const float beta = 0.2;

// Previous estimates
float prevEstimate = 0;
float prevRate = 0;

float alphaBetaFilter(float newVal) {
  // Calculate the current estimate
  float currentEstimate = alpha * newVal + (1 - alpha) * (prevEstimate + prevRate);

  // Calculate the current rate
  float currentRate = beta * (currentEstimate - prevEstimate) + (1 - beta) * prevRate;

  // Update the previous estimates
  prevEstimate = currentEstimate;
  prevRate = currentRate;

  return currentEstimate;
}

void setup() {
  Serial.begin(9600);
  
  // Set ADC pin as input
  pinMode(adcPin, INPUT);
}

void loop() {
  // Read ADC value
  int rawValue = analogRead(adcPin);
  
  // Apply the alphaBetaFilter function
  float filteredValue = alphaBetaFilter(rawValue);
  
  // Print filtered value to Serial monitor
  Serial.println(filteredValue);
  
  // Delay for visualization purposes
  delay(100);
}
```
8. Альфа-бета-гамма фильтр
```c++
// ADC pin
const int adcPin = A0;

// Filter coefficients
const float alpha = 0.2;
const float beta = 0.1;
const float gamma = 0.05;

// Previous estimates and rates
float prevEstimate = 0;
float prevRate = 0;

float abgFilter(float newVal) {
  // Calculate rate of change
  float currentRate = (newVal - prevEstimate) / (1.0 / millis());

  // Calculate current estimates
  float currentEstimate = prevEstimate + prevRate * (1.0 / millis()) + alpha * (newVal - prevEstimate);
  float currentRateEstimate = prevRate + beta * (newVal - prevEstimate) / (1.0 / millis());
  float currentAccelerationEstimate = gamma * (newVal - prevEstimate) / (1.0 / millis());

  // Update previous estimates and rates
  prevEstimate = currentEstimate;
  prevRate = currentRate;

  // Combine estimates to obtain final filtered value
  float filteredValue = currentEstimate + currentRateEstimate + currentAccelerationEstimate;

  return filteredValue;
}

void setup() {
  Serial.begin(9600);
  
  // Set ADC pin as input
  pinMode(adcPin, INPUT);
}

void loop() {
  // Read ADC value
  int rawValue = analogRead(adcPin);
  
  // Apply the abgFilter function
  float filteredValue = abgFilter(rawValue);
  
  // Print filtered value to Serial monitor
  Serial.println(filteredValue);
  
  // Delay for visualization purposes
  delay(100);
}

```

## Средства индикации

Пришло время поговорить про различные средства индикации. Конечно, работа с микроконтроллерами - это работы с датчиками, работа с выходами и входами, шинами и т.д. И это, конечно же, какие-то отладочные работы. А что, как не индикация, наглядно покажет нам где ошибка? Поэтому на этом занятии мы рассмотрим основные средства индикации.

Начнем конечно же со светодиодов и их производных. `LED` - `light emitting diode` - `светодиод`. Самый простой и универсальный способ проверить работу программы, первое что мы подключаем при знакомстве и один из самых популярных компонентов. Также, существуют светодиодные матрицы, объединенные общим катодом или анодом.

Светодиодные ленты - ленты, в которых светодиоды соединены последовательно. Самые простые - светят каким-то одним цветом, `RGB` ленты - могут светиться тремя цветами, и, наконец, самый вариативный вариант - адресная светодиодная лента. В ней мы можем управлять конкретными светодиодами и их цветом. Как правило, для подключения ленты требуется источник питания, так как такие ленты требуют большого тока из-за количества светодиодов.

Сегментные индикаторы - индикаторы, в которых светодиоды расположены в виде цифр, или шкалы. Можно подключать каждый светодиод отдельно, но тем самым займем много пинов `Arduino`. Существуют специальные сдвиговые регистры, разгружающие выводы нашей платы.

Дисплеи, и в частности `tft` дисплеи - дисплеи с матрицей, которая состоит из транзисторов в виде тонкой пленки. Бывают монохромные и цветные.

Не стоит забывать про звуковую индикацию - в качестве примера можно сделать сигнализацию для обнаружения предметов, реакции на движение, детектировании утечек газа.  

### ШИМ

На прошлом занятии мы познакомились с типами сигналов (цифровые и аналоговые). И проговорили, что наша плата не может генерировать аналоговый сигнал, только цифровой - вкл и выкл. Но как же быть? Ведь нам порой очень важно менять какое-то значение во времени, будь то плавное нарастание свечения светодиода или скорость мотора. Напомню, что в `Arduino` нет цифро - аналогового преобразователя. Но мы все-таки можем добиться плавного управления цифровым сигналом. Для этих целей существует широтно-импульсная модуляция. Сокращенно `ШИМ`, на английском - `PWM`(можете увидеть в datasheet’ах). Как это работает? Представьте себе вентилятор, работающий в полную мощность, с постоянным напряжением. Теперь давайте включать вентилятор на секунду, а затем на секунду выключать, и повторять это по кругу. Вентилятор начнет крутиться в два раза медленнее. Но мы, скорее всего, будем видеть моменты включения и выключения, особенно если вентилятор маленький. Давайте возьмем большой вентилятор, обладающий большей инертность, и здесь уже почти незаметны моменты включения и выключения. Заставим его работать в 4 раза медленнее, будем подавать напряжение на 0,5 секунд, а затем на 1,5 секунды выключать. Это и есть ШИМ сигнал.

Основные характеристики ШИМ `Arduino`: частота, скважность, период заполнения.

![](https://lh3.googleusercontent.com/X3bPJBWuMg_uBR3V_QIWgiBraAcvyuGKdRKreyZpFC3tzJHeKmkgKyJV6D1kP6j52Yhw3BavEfvGJVQDvZkQzvgp0PkE1BPImpZ8yKYgBI3RGWcWzGcb4pC5v3gRegs38YJWJNt-CF1WIhNw-zS6Xw)

Пример ШИМ по отношению к напряжению
Коэффициент заполнения - отношение длительности периода к периоду импульса.

![](https://lh5.googleusercontent.com/bHyYJ19S0WwZSwC7x1EEWf3_dEVZ_pfvYOhoRX0hEcR8HsxckDr-gTBzyYrQsSqO9_CjZQAj_NxJuHbPdZvLvyTmFYbenQjAchl3d1L656ObAzFBkolYgqXoWQC687segPL7svN7PcQ46rZF2y2vPA)

Примеры желаемого напряжения и соответствующего ШИМ сигнала(в % указан коэффициент заполнения)
Скважность - величина, обратная коэффициенту заполнения.
> [Пример 1: Светодиод с потенцилометром](https://wokwi.com/projects/376357059222770689)
> [Пример 2: Светодиод с датчиком температуры](https://wokwi.com/projects/376357149151807489)
#### Примеры

Давайте перейдем к практике, и попробуем управлять яркостью светодиода посредством ШИМ. Если мотор, вентилятор из примера или, например лампочка, имеют инертность, то как быть со светодиодом, ведь он практически не имеет задержки включения. Но выход есть. В примере с вентилятором у нас был период 2 секунды, то есть 0,5 Гц. А теперь давайте представим, если наша частота будет 1000Гц, или вообще 25000 Гц! Тут будет задействована уже инертность глаза, он не заметит включение и выключение светодиода, для него это будет изменением яркости. Давайте посмотрим как это работает. Частота ШИМ сигнала Arduino - 488,28 Гц.

Для того, чтобы воспользоваться ШИМ сигналом, надо найти на плате цифровой пин со специальной пометкой ~ (тильда). Чтобы сгенерировать ШИМ сигнал, есть специальная функция - `analogWrite()`, которая принимает два аргумента - номер пина и так называемое заполнение ШИМ сигнала. По умолчанию все выходы ШИМ у нас 8-битные, поэтому максимальное значение 0-255.

![Подключения светодиода](https://lh4.googleusercontent.com/eBHj1boupG5ZU_UnL5kamFGwJGETbtdNKkcX27XBRlPaYeu9V8eXQlxTJS5hc6g_4UvFJ2u0PADgBunLbAj1iYwdM2oyKK5r2Yj05AEg6dMmqfwmXayi-rFR7YM-0LJyumz9aGqRP1ICvESs5A0_NQ)

Давайте сделаем так, чтобы цвет плавно нарастал а потом убывал.
```c++

void setup() {
	pinMode(5, OUTPUT);
} 

void loop() {
	for (int i = 0; i<255; i++) {
		analogWrite(5, i);
		delay (20);
	}
	for (int i=255; i>=0; i--){
		analogWrite(5, i);
		delay(20);
	}
}
```
##### RGB светодиод
> [Пример 1: RGB с потенцилометром](https://wokwi.com/projects/376357270455290881)
> 
![Подключение RGB светодиода](https://lh4.googleusercontent.com/ynThHfcJmNsawDLbhpdeqCnJDEnR1W63L-_mqO-y-7BmVu83Ruk72GWRb3hMm_yrk2taB5kA-zdwEQOwFzv4fiC7fZMCjPhYaermGFcVbsapI1G8msLcJbZ8xd1jl4JvXcILfaUPhOAnhyOLUcqsDA)
Программа для создания плавного переливания цвета(пример с несколькими цветами)
```c++
#define RED_LED 11
#define GREEN_LED 3
#define BLUE_LED 6
int t = 7; // задержка в переменной, чтобы каждый раз не писать

void setup() {
	pinMode(RED_LED, OUTPUT);
	pinMode(GREEN_LED, OUTPUT);
	pinMode(BLUE_LED, OUTPUT);
}

void loop() {
	//от красного к желтому
	for (int value = 0; value <= 255; value++)// нам необходимо ввести переменную в цикле, которая бы увеличивалась, в зависимости от нужного цвета(или уменьшалась)
	{
		analogWrite(RED_LED, 255); // красный горит
		analogWrite(GREEN_LED, value); // за каждый проход по циклу мы плавно добавляем зеленый цвет к красному, чтобы получился желтый
		analogWrite(BLUE_LED, LOW); // синий выключен, так как он не используется ни в красном ни в желтом цвете
		delay(t);
	}

	//от желтого к зеленому
	for (int value = 0; value <= 255; value++) // помните, что мы начинаем от цвета, на котором закончили, то есть на желтом
	{
		analogWrite(RED_LED, 255 - value); // чтобы плавно перейти к зеленому, теперь нам нужно вычитать нашу переменную value из 255
		analogWrite(GREEN_LED, 255); // то есть в сочетании цветов красный медленно угасает, а тем временем зеленый горит постоянно
		analogWrite(BLUE_LED, LOW);
		delay(t);
	}
}
```
#### Матрицы
>[Пример 1: max7219](https://wokwi.com/projects/376357324045920257)
ак мы уже знаем, сегментные индикаторы, будь то шкалы или цифры, состоят из отдельных светодиодов, соединенных вместе. Например, у группы светодиодов могут быть соединены все катоды. Такой индикатор имеет приписку «с общим катодом», в противном случае — «с общим анодом».

А что будет, если мы разместим светодиоды не в виде цифры или шкалы, а в виде сетки? Получится уже вполне себе графический индикатор. То есть такой, на котором можно отобразить не только число, но и какое-то изображение.

Такая сетка называется матричным индикатором, а в случае использования светодиодов — светодиодной матрицей. Разрешение матричного индикатора — это количество точек по горизонтали и вертикали. Например, самые распространенные индикаторы имеют разрешение 8×8 точек.

[![Светодиодная матрица на Ардуино](https://robotclass.ru/wp-content/uploads/2016/12/led-matrix-8x8-1024x768.jpg)](https://robotclass.ru/wp-content/uploads/2016/12/led-matrix-8x8.jpg)

Если требуется светодиодная матрица с большим разрешением, то её просто-напросто составляют из нескольких 8×8 индикаторов. Как это делать, мы увидим позже. А пока разберемся как соединяются все 64 светодиода внутри матрицы.

Конечно, можно бы было как и в случае семисегментного индикатора соединить все светодиоды общим катодом или анодом. В этом случае нам бы потребовалось либо 64 вывода контроллера, либо 8 сдвиговых регистров. Оба варианта весьма расточительны.

Более правильный вариант — объединить светодиоды в группы по 8 штук с общим катодом. Пусть это будут столбцы матрицы. Затем, параллельные светодиоды в этих столбцах объединить снова в группы по 8 штук уже с общим анодом. Получится вот такая схема:

[![Светодиодная матрица на Ардуино, схема](https://robotclass.ru/wp-content/uploads/2016/12/led-matrix-8x8-schema.png)](https://robotclass.ru/wp-content/uploads/2016/12/led-matrix-8x8-schema.png)

Предположим, стоит задача зажечь светодиод R6C3. Для этого нам потребуется подать высокий уровень сигнала на вывод R6, а вывод C3 соединить с землей.

[![Светодиодная матрица на Ардуино, схема](https://robotclass.ru/wp-content/uploads/2016/12/led_8x8_R6C3.png)](https://robotclass.ru/wp-content/uploads/2016/12/led_8x8_R6C3.png)

Не выключая эту точку, попробуем зажечь другую — R3C7. Положительный контакт питания соединим с R3 и землю с C7. Но в таком случае строки R6 и R3 будут пересекаться с колонками C3 и C7 не в двух, а в четырех местах! Следовательно и зажжется не две, а четыре точки. Проблема!

[![Светодиодная матрица на Ардуино, схема](https://robotclass.ru/wp-content/uploads/2016/12/led_8x8_R6C3_R3C7.png)](https://robotclass.ru/wp-content/uploads/2016/12/led_8x8_R6C3_R3C7.png)

Очевидно, что помочь сможет всё та же  [динамическая индикация](http://robotclass.ru/tutorials/arduino-dynamic-led-indication/). Если мы будем включать точки R6C3 и R3C7 по-очереди очень быстро, то сможем использовать персистентность зрения — способность интерпретировать быстро сменяющиеся изображения как одно целое.





##### Оценка применимости
Давайте теперь поговорим про большую нагрузку. Как вы уже поняли, микроконтроллеры отвечают за логику, и управлять большими мощностями с них не получится. `Arduino` в этом плане дает чуть больше свободы, но следующие микроконтроллеры, которые вы будете изучать, будут отвечать исключительно за логику. Поэтому сейчас мы познакомимся со средствами управления большой нагрузкой.

1.  Транзистор
    
2.  Электромагнитное реле
    
3.  Твердотельное реле
    
4.  Оптопара
    
### Сдвиговые регистры
> [Пример 1: Один сдвиговый регистр](https://wokwi.com/projects/376357505861682177)
> [Пример 2: Два сдвиговых регистра](https://wokwi.com/projects/376357857072826369)
#### Что такое сдвиговые регистры ?

Как только мы захотим подключить, например, семисегментные индикаторы, мы сразу столкнемся с проблемой - они занимают очень много места на плате. Другими словами чтобы подключить один семисегментный индикатор, нужно занять восемь выходов на плате. А что делать, если мы захотим подключить два таких индикатора, или вообще сделать часы - четыре индикатора? Плюс несколько моторов, реле и пару датчиков. Даже просто четыре индикатора будут выглядеть так:

  

![](https://lh3.googleusercontent.com/l-7iMM8EhRzsUTMrchD2bY3WNlkBtGlhZlEK9bifGaPoQJxIy_MA33pYRlSB0dMGO20OcrxaYnQ7UdpcLHqtrh3otOA3z2fNy7SCGy5jVCUBHB2Dq8em4wGd7D_ub91ekUItN508473iDH0bEhvqTQ)

Можно взять плату с большим количеством выводов, но гораздо проще и быстрее подключить сдвиговый регистр. Когда вычислительных мощностей хватает, и проблема только в выводах, это будет дешевле и компактнее.

Итак, сдвиговый регистр - это устройство, которое принимает поток последовательных битов и одновременно выводит их значения на параллельных контактах ввода вывода. Регистры сдвига часто применяются для управления большим количеством светодиодов.

Напомню, что существует два типа передачи данных, последовательный и параллельный. До этого занятия мы работали в параллельном режиме, когда писали `digitalWrite()` для нескольких светодиодов. Сдвиговые регистры позволяют легко конвертировать последовательные и параллельные методы передачи данных. Мы будем пользоваться последовательно - параллельным регистром сдвига, с его помощью принимать данные последовательно, а выводить параллельно. Так же, можно каскадировать регистры, и управлять множеством цифровых выходов, используя всего три контакта Arduino.

#### Регистр 74HC595

![](https://lh5.googleusercontent.com/F_iyfbws9Gj8alPUiqTX6_dipeFYon_AWxTfRyWDphZybq3gVNuukB3YfCJt7Lmuwowq7icJsojhJXEIFZoC7jtDKFJXkCAPIquE1kOoVTL05vhdAotRvYDGhO6M4ETkKmcMryyziK-xIMjwPG8rNA)

- `Qa` - `Qh` - восемь параллельных выходов сдвигового регистра

- `GND` - соединяется с GND на плате

- `SER(DATA)` - выход данных, по нему передается восемь последовательных битов данных для установки значений на параллельных выходах

- `SRCLK(CLOCK)` - тактовый вход. Когда мы подаем высокое напряжение(HIGH) на этот вход, происходит считывание, происходит считывание одного бита данных с входа DATA в сдвиговый регистр. Чтобы получить все восемь битов данных, необходимо подать восемь импульсов.

- `RCLK(LATCH)` - так называемая защелка, благодаря этому входу мы выводим последовательные данные на параллельные выходы.

Осталось еще два контакта, которые в данный момент мы не будем использовать, но если вы будете соединять несколько сдвиговых регистров, то есть, делать каскад, вам понадобится эта информация.

- `QE` - разрешение вывода данных на параллельные выходы. Обратите внимание, что над этими буквами стоит черта, это значит что активный уровень для этого входа - низкий. Когда на этом входе низкий уровень, параллельные выходы будут включены, когда высокий - выключены. У нас этот контакт подключен к GND, соответственно все выходы постоянно включены. Его можно соединить с пином ардуино, и тогда можно управлять этим процессом.

- `SRCRL` - контакт сброса. При подаче напряжения низкого уровня очищает содержимое сдвигового регистра. У нас подключен к 5В.
#### Принцип работы

Каждый раз, когда сигнал на входе `SRCLK(CLOCK)` меняется с низкого на высокий, все значения, хранящиеся в восьми выходных ячейках, сдвигаются на одну позицию. Данные из последней ячейки либо сбрасываются, либо передаются на выход `Qh`(при каскадном подключении). Одновременно последовательные данные на входе `SER(DATA)` сдвигаются на одну позицию. За восемь тактов - импульсов предыдущие значения сбрасываются, а новые загружаются. Подача высокого сигнала на вход `RCLK(LATCH)` выводит значения, хранящиеся в ячейках, на выходы регистра.

Допустим мы хотим зажечь несколько светодиодов, подключенных к выходам `Qa`, `Qc`, `Qe`, `Qg`. В двоичном представлении это выглядит так: `10101010`.

  

![](https://lh3.googleusercontent.com/axkxGwyioD4_cTS5arQp0OW6jOd_5re4QRpz_X3nGy27KbG2jfcFyNVmeHhM8Nrw1ABJ5FObDniNFkryimEs438HyYziLNt_6MWS07MOtjwUMnudllPSzlKfHlV2Z1KSn-CFBYBPKQQMrOVbjJ1puQ)
##### Пример
![](https://lh3.googleusercontent.com/2qF4G0bQIl33phQlXOe0P53LQi129LKfbC3blFiECKEsPD7GAKreEZ7JScUhPFnAJWJvyg98mEsHv47KihHRmeOZOFihAVVcAQ9brVMOe0eI5pARdWCzBMGMyi4HsLPEahy5uhwBaySyIS6iKMpppw)

  
```c++
const int SER = 8;
const int LATCH = 9;
const int CLK = 10; 

void setup() { 
	pinMode(SER, OUTPUT);
	pinMode(LATCH, OUTPUT);
	pinMode(CLK, OUTPUT);
	digitalWrite(LATCH, LOW);
	shiftOut(SER, CLK, MSBFIRST, B10101010);
	digitalWrite(LATCH, HIGH);
}

void loop() {}
```
#### Функция shiftOut()

Функция `shiftOut` используется для поразрядной выдачи данных. Эта функция принимает четыре аргумента:

-   номер контакта `DATA`
    
-   номер контакта `CLOCK`
    
-   порядок выдачи битов
    
-   значение, выдаваемое на выход
    

Аргумент `MSBFIRST` показывает, что самый старший бит(крайний левый) будет отправлен первым. Если написать `LSBFIRST`, то мы отправим крайний правый бит - самый младший.

`shiftOut()` это функция, которая и генерирует тот самый импульс, о котором мы говорили в начале, тем самым сообщая внешнему устройству о поступлении нового бита. Интересное замечание: функция является программной реализацией `SPI`, но работает медленнее, так как аппаратная версия реализована в отдельной библиотеке.

#### Преобразование между форматами

Мы написали программу, в которой передавали биты в двоичном виде. Но так же можно передавать сигналы в сдвиговый регистр в десятичном формате. В некоторых проектах удобнее представлять информацию в таком виде. Каждый разряд двоичного числа представляет следующую ступень числа 2(начиная с младшего, самого правого). Давайте переведем то что у нас уже есть в двоичный код.

![](https://lh6.googleusercontent.com/uvPLBMu3prc98Igzyd6DH1xwPDXkLm_ZmVL25wWrqhbpWhUUOlHOtqDEwdgrZi-uokf3T3kWKaRoSBTzu3ru29B4BvHkqmSR0irS1f0kx_a4V1Efq39eXl5Eg40rJUKrp0v_PvE-NOhQBg6iwi_DDw)

Теперь в том месте программы, где мы вызываем функцию `shiftOut()` вместо `B10101010` можно смело написать 170, и ничего не изменится.

  

#### Создание световых эффектов

С помощью функции `shiftOut()` можно очень быстро обновлять данные в ячейках сдвиговых регистров, чтобы создавать динамичные световые анимации. Давайте создадим эффект “бегущего огня”. Для этого представим в десятичном виде положение каждого светодиода в регистре, создадим последовательность из этих чисел, и передадим в функцию `shiftOut()`.

![](https://lh5.googleusercontent.com/ZnQS3tspu9oTSA0BL06vHOcrEsu-ZIIex_cHqTP7AdJqRLu2Sk6BfyiZ_PgwM-mbfrKTjVBEXkdTuSrvnwhhUEsjyi3zwrWaYDrXD2ghWFgNX0JKh6YDmQR_aPePv2NNv_8rEuwdPGyF4ScGjdxzUA)
```c++
const int SER = 8;
const int LATCH = 9;
const int CLK = 10;
// последовательность
int vs[14] = {1,2,4,8,16,32,64,128,64,32,16,8,4,2};

void setup() {
	pinMode(SER, OUTPUT);
	pinMode(LATCH, OUTPUT);
	pinMode(CLK, OUTPUT);
}

void loop() {
	for (int i = 0; i<14;i++)
	{
		digitalWrite(LATCH, LOW);
		shiftOut(SER, CLK, MSBFIRST, vs[i]);
		digitalWrite(LATCH, HIGH);
		delay(20);
	}
}
```
  Пример кода, где массив в двоичном виде используется в цикле. Обратите внимание, как выглядит второй цикл - в нем, в функции `shiftOut()` четвертый аргумент это разность тройки и `i`-го элемента. Изменяя этот аргумент можно добиться более быстрого перемещения бегущего огня.
```c++ 
int dataPin = 8;
int clockPin = 10;
int latchPin = 9;

byte path[4] = {
	B11000011,
	B00111100,
	B00100100,
	B00011000
};

void setup() {
	pinMode(latchPin, OUTPUT);
	pinMode(clockPin, OUTPUT);
	pinMode(dataPin, OUTPUT);
}

void loop() {
	for (int i = 0; i < 4; i++) {
		digitalWrite(latchPin, LOW);
		shiftOut(dataPin, clockPin, LSBFIRST, path[i]);
		digitalWrite(latchPin, HIGH);
		delay(250);
	}
	for (int i = 0; i < 4; i++) {
		digitalWrite(latchPin, LOW);
		shiftOut(dataPin, clockPin, LSBFIRST, path[3 - i]);
		digitalWrite(latchPin, HIGH);
		delay(250);
	}
}
```
  Так же можно использовать довольно интересную функцию `bitWrite(x, n, b)` - где `x` - переменная, у которой нужно изменить бит, `n` - номер бита, состояние которого необходимо изменить(начинается с крайнего правого), `b` - новое значение бита (`0` или `1`).

Реализация бегущего огня с помощью `bitWrite()`.
```c++
int dataPin = 8;
int clockPin = 10;
int latchPin = 9;

void setup() {
	pinMode(latchPin, OUTPUT);
	pinMode(clockPin, OUTPUT);
	pinMode(dataPin, OUTPUT);
}

void loop() {
	byte byteToSend = 0; //Создаем пустой байт B00000000
	for (int bitPos = 0; bitPos < 8; bitPos++) { // В переменной хранится позиция изменяемого бита
		byteToSend = 0; // Обнуляем байт при каждом проходе
		bitWrite(byteToSend, bitPos, HIGH); // При bitPos=0 получим B00000001, при bitPos=1 - B00000010, при bitPos=2 - B00000100 и т.д.
		digitalWrite(latchPin, LOW);
		shiftOut(dataPin, clockPin, MSBFIRST, byteToSend); // Инвертируем сигнал при помощи MSBFIRST, грузим с первого бита
		digitalWrite(latchPin, HIGH);
		delay(50);
	}
}
```
#### Реализация ШИМ с помощью сдвигового регистра

К сожалению ШИМ сдвиговым регистром не поддерживается. Поэтому есть небольшая хитрость - мы будем использовать выход регистра OE. OE можно назвать логическим нулем для всех выходов. Если мы подключим этот выход к ШИМ Arduino, мы можем смещать логический ноль, тем самым имитировать ШИМ на выходах.
```c++
int dataPin = 8;
int latchPin = 9;
int clockPin = 10;
int pwmPin = 6;

void setup() {
	//устанавливаем режим OUTPUT
	pinMode(latchPin, OUTPUT);
	pinMode(clockPin, OUTPUT);
	pinMode(dataPin, OUTPUT);
	pinMode(pwmPin, OUTPUT);
	digitalWrite(latchPin, LOW); // устанавливаем синхронизацию "защелки" на LOW
	shiftOut(dataPin, clockPin, LSBFIRST, B11110001);
	digitalWrite(latchPin, HIGH); //"защелкиваем" регистр, тем самым устанавливая значения на выходах
}

void loop() {
	for (int i=0; i<256; i++) {
		analogWrite(pwmPin, i); // Назначаем выходу ШИМ разные значения
		delay(2); // Делаем паузу, чтобы не мигало слишком быстро
	}
}

```

#### Светодиодная матрица и сдвиговые регистры

В нашем уроке мы будем подключать к Ардуино Уно самую простую светодиодную матрицу 8×8 красного свечения. Нумерация выводов начинается с нижнего левого угла. При этом, нумерация ног 1-16 не связана никакой логикой с нумерацией колонок и строк C и R.

[![Распиновка светодиодной матрицы 8x8](https://robotclass.ru/wp-content/uploads/2016/12/8X8-Matrix-Pinout.jpg)](https://robotclass.ru/wp-content/uploads/2016/12/8X8-Matrix-Pinout.jpg)

Ориентируясь на урок про динамическую индикацию, попробуем использовать в схеме управления матричным индикатором 8-битные сдвиговые регистры. Один регистр подключим к выводам индикатора, отвечающим за колонки, а второй к выводам строк.

**Принципиальная схема**

[![Принципиальная схема светодиодная матрица Ардуино](https://robotclass.ru/wp-content/uploads/2016/12/led-matrix-8x8_%D1%81%D1%85%D0%B5%D0%BC%D0%B0_c-1024x428.png)](https://robotclass.ru/wp-content/uploads/2016/12/led-matrix-8x8_%D1%81%D1%85%D0%B5%D0%BC%D0%B0_c.png)

**Важное замечание №1.**  Необходимо, чтобы резисторы в этой схеме были на линиях, идущих от первого сдвигового регистра. Этот сдвиговый регистр отвечает за колонки. При таком подключении, каждый резистор будет задавать ток только для одного светодиода на каждом шаге динамического алгоритма. Следовательно, все светодиоды будут светиться равномерно.

**Важное замечание №2.** Указанная выше схема носит сугубо ознакомительный характер. Правильнее будет включить в разрыв между вторым регистром и матрицей дополнительную силовую микросхему, например транзисторную сборку ULN2003.

##### Пример

Чтобы было веселей, попробуем высветить на индикаторе смайлик. Как уже было сказано, для вывода изображения на матрицу воспользуемся динамической индикацией. А именно, будем высвечивать нашу картинку построчно. Сначала зажжем нужные колонки в самой верхней строке, затем во второй, в третьей, и так все 8 строк.

[![Светодиодная матрица на Ардуино, схема](https://robotclass.ru/wp-content/uploads/2016/12/led_8x8.gif)](https://robotclass.ru/wp-content/uploads/2016/12/led_8x8.gif)

За колонки у нас будет отвечать первый сдвиговый регистр, а за строки второй. Следовательно, вывод строки будет состоять из двух последовательных записей в регистр: сначала передаем код строки, затем код точек в этой строке.

В этой программе мы также воспользуемся ускоренной версией функции `digitalWrite`. Это необходимо для того, чтобы процесс динамической индикации проходил очень быстро. В противном случае, мы увидим заметное мерцание матрицы.
```c
const byte data_pin = PD2;
const byte st_pin = PD3;
const byte sh_pin = PD4;

unsigned long tm, next_flick;
const unsigned int to_flick = 500;

byte line = 0;

const byte data[8] = {
    0b00111100,
    0b01000010,
    0b10100101,
    0b10000001,
    0b10100101,
    0b10011001,
    0b01000010,
    0b00111100
};

void latchOn(){
    digitalWriteFast(st_pin, HIGH); 
    digitalWriteFast(st_pin, LOW);
}

void fill( byte d ){
    for(char i=0; i<8; i++){
        digitalWriteFast(sh_pin, LOW);
        digitalWriteFast(data_pin, d & (1<<i));
        digitalWriteFast(sh_pin, HIGH);
    }
}

void setPinFast(byte pin){
    DDRD |= _BV(pin);
}

void digitalWriteFast(byte pin, byte sig){
    if( sig )
        PORTD |= _BV(pin);
    else
        PORTD &= ~_BV(pin);
}

void setup() {
    setPinFast(data_pin);
    setPinFast(st_pin);
    setPinFast(sh_pin);
}

void loop() {
    tm = micros();
    if( tm > next_flick ){
        next_flick = tm + to_flick;
        line++;
        if( line == 8 )
            line = 0;
        // передаем код строки
        fill( ~(1<<(7-line)) );
        // зажигаем точки в строке № line
        fill( data[line] );
        // открываем защелку
        latchOn();
    }
}
```

Основная часть этой программы, включая переменные  `data_pin, sh_pin, st_pin, next_flick, to_flick`  и функцию  `fill`
Массив  `data` хранит восемь строк нашей картинки. Для экономии памяти мы записали каждую комбинацию точек в бинарном виде.

Функция  `latchOn` открывает защелку регистра. Это нужно делать только после заполнения обоих сдвиговых регистров.

## Интерефсы связи:
`Arduino Uno` поддерживает следующие интерфейсы связи:

1.  **Serial (UART)**: Arduino Uno имеет один hardware-сериальный порт, который может использоваться для связи с компьютером или другими устройствами через USB. Он используется для программирования и отладки Arduino Uno, а также для обмена данными с внешними устройствами.
    
2.  **I2C (TWI)**: Arduino Uno имеет два пина (A4 и A5), которые могут быть использованы для связи по шине I2C. Этот интерфейс позволяет подключать несколько устройств к одной шине с использованием только двух проводов.
    
3.  **SPI**: Arduino Uno имеет три пина (10, 11 и 13), которые могут быть использованы для связи по шине SPI. Этот интерфейс используется для обмена данными между Arduino Uno и другими устройствами, такими как датчики, дисплеи и память.
    
4.  **Аналоговые пины**: Arduino Uno имеет 6 аналоговых пинов (A0-A5), которые могут быть использованы для чтения аналоговых сигналов, например, с датчиков.
    
5.  **Цифровые пины**: Arduino Uno имеет 14 цифровых пинов, которые можно использовать для управления и чтения цифровых сигналов.
    
6.  **Питание**: Arduino Uno имеет различные пины для подачи питания (5V и 3.3V) и заземления (GND).
### Serial(UART)
`UART` (Universal Asynchronous Receiver/Transmitter, универсальный асинхронный приемопередатчик) - это аппаратный модуль для последовательной асинхронной передачи данных между устройствами. Он обеспечивает передачу и прием данных по одному проводу, используя только два состояния сигнала - высокий и низкий уровни напряжения.

`UART` является основным интерфейсом связи на многих микроконтроллерах, включая `Arduino Uno`. Он позволяет обмениваться данными между Arduino и другими устройствами, такими как компьютер или периферийные устройства.

Назначение линий:

-   `TX` (Transmission) - линия передачи данных от `Arduino` к другому устройству
-   `RX` (Reception) - линия приема данных от другого устройства к `Arduino`

`UART `использует асинхронную передачу данных, что означает, что данные передаются без синхронизации по внешнему тактовому сигналу. Вместо этого, каждый передаваемый бит сопровождается стартовым битом и стоповым битом, которые помогают синхронизироваться между устройствами.

Основные характеристики **UART**:
[Wokwi docs](https://docs.wokwi.com/guides/serial-monitor)
-   Скорость передачи данных (битрейт) - устанавливает скорость передачи данных между устройствами. На` Arduino Uno` можно настроить скорость передачи от 300 бит/с до 115200 бит/с.
-   Формат кадра данных - определяет, какие биты используются для передачи данных (бит данных) и какой бит для ошибок (бит паритета).
-   Чтение и запись данных - `Arduino Uno` предоставляет функции для чтения и записи данных через `UART`. Например, функция `Serial.read()` используется для чтения данных из буфера входного потока, а функция `Serial.write()` - для записи данных в буфер выходного потока.

`UART` является простым и широко распространенным интерфейсом связи, который позволяет обмениваться данными между Arduino и другими устройствами. Он часто используется для отладки и программирования Arduino, а также для передачи данных между различными датчиками, модулями связи и периферийными устройствами.
Набор функций  **Serial**  служит для связи устройства Ардуино с компьютером или другими устройствами, поддерживающими последовательный интерфейс обмена данными. Все платы Arduino имеют хотя бы один последовательный порт ([UART](https://ru.wikipedia.org/wiki/UART), иногда называют USART). Для обмена данными  **Serial**  используют цифровые порты ввод/вывода 0 (RX) и 1 (TX), а также USB порт. Важно учитывать, что если вы используете функции  **Serial**, то нельзя одновременно с этим использовать порты 0 и 1 для других целей.

[Среда разработки Arduino](https://arduino.ru/Arduino_environment)  имеет встроенный монитор последовательного интерфейса (Serial monitor). Для начала обмена данными необходимо запустить монитор нажатием кнопки Serial monitor и выставить ту же скорость связи (baud rate), с которой вызвана функция begin().

Плата  [Arduino Mega](https://arduino.ru/Hardware/ArduinoBoardMega)  имеет три дополнительных последовательных порта:  **Serial1**  на портах 19 (RX) и 18 (TX),  **Serial2**  на портах на портах 17 (RX) и 16 (TX),  **Serial3**  на портах на портах 15 (RX) и 14 (TX). Чтобы использовать эти порты для связи с компьютером понадобится дополнительные адаптеры USB-to-serial, т.к. они не подключены к встроенному адаптеру платы Mega. Для связи с внешним устройством через последовательный интерфейс соедините TX порт вашего устройства с RX портом внешнего устройства и RX порт вашего устройства с портом TX внешнего и соедините "землю" на устройствах. (Важно! Не подключайте эти порты напрямую к RS232 порту, это может повредить плату).

#### Функции

-   [begin](https://arduino.ru/Serial/Begin)()
-   [end](https://arduino.ru/Serial/End)()
-   [available](https://arduino.ru/Reference/Serial/Available)()
-   [read](https://arduino.ru/Reference/Serial/Read)()
-   [flush](https://arduino.ru/Reference/Serial/Flush)()
-   [print](https://arduino.ru/Reference/Serial/Print)()
-   [println](https://arduino.ru/Reference/Serial/Println)()
-   [write](https://arduino.ru/Reference/Serial/Write)()
-   [peek](https://arduino.ru/Reference/Serial/Peek)()

#### Пример
##### 1. Print Some Data

```cpp
void setup() {
  // Initialize UART baud rate
  Serial.begin(9600);
}

void loop() {
  // Print a message to the Serial monitor
  Serial.println("Hello, World!");

  // Delay for visualization purposes
  delay(1000);
}

```

In this example, the Arduino board writes the message "Hello, World!" to the Serial monitor every second.

##### 2. Read Some Data

```cpp
void setup() {
  // Initialize UART baud rate
  Serial.begin(9600);
}

void loop() {
  // Check if there is any data available to read from the Serial port
  if (Serial.available()) {
    // Read the data from the Serial port
    char receivedByte = Serial.read();

    // Process the received data
    // (e.g., print it to the Serial monitor)
    Serial.print("Received: ");
    Serial.println(receivedByte);
  }
}

```
##### 3. Использование базовых функций Serial

В данном примере функция `Serial.begin(9600)` используется для инициализации `UART`-связи со скоростью передачи данных `9600`.

Приведем примеры других функций `Serial`, используемых в этом коде:

- Serial.available()` используется для проверки наличия данных, доступных для чтения из последовательного порта. В одном из примеров, если доступно хотя бы 3 байта, код считывает данные и обрабатывает их.

- `Serial.read()` используется для чтения байта из последовательного порта. В одном из примеров код считывает байт и обрабатывает его (например, преобразует в верхний регистр).

- `Serial.flush()` используется для того, чтобы дождаться передачи всех исходящих данных, прежде чем приступить к выполнению кода.CopyCopy

- `Serial.print()` и `Serial.println()` используются для отправки данных в последовательный порт в целях отладки или мониторинга. В одном из примеров код печатает значение переменной.

- `Serial.write()` используется для записи байта данных в последовательный порт.

- `Serial.peek()` используется для подглядывания за следующим байтом в буфере Serial без его удаления. В одном из примеров код подсматривает следующий байт и выполняет некоторое действие, основываясь на его значении.
```c++
void setup() {
  // Initialize UART baud rate
  Serial.begin(9600);
}

void loop() {
  // Check if there is any data available to read from the Serial port
  if (Serial.available()) {
    // Read the data from the Serial port
    char receivedByte = Serial.read();

    // Process the received data
    // (e.g., convert it to uppercase)
    char processedByte = toupper(receivedByte);

    // Send the processed data back to the Serial port
    Serial.print("Processed: ");
    Serial.println(processedByte);
  }
  // Example using Serial.available()
  if (Serial.available() >= 3) {
    // Read three bytes from the Serial port
    char receivedData[3];
    for (int i = 0; i < 3; i++) {
      receivedData[i] = Serial.read();
    }

    // Process the received data
    // (e.g., send it to another function for further processing)
    processReceivedData(receivedData);
  }
  // Example using Serial.print()
  int variable = 42;
  Serial.print("The value of variable is ");
  Serial.println(variable);

  // Example using Serial.flush()
  Serial.print("Send some data...");
  delay(1000);
  Serial.flush(); // Wait for all outgoing data to be transmitted
  Serial.println("Data sent.");

  // Example using Serial.write()
  char dataToSend = 'A';
  Serial.write(dataToSend);

  // Example using Serial.peek()
  if (Serial.available()) {
    // Peek at the next byte without removing it from the buffer
    char nextByte = Serial.peek();

    // Process the next byte
    // (e.g., check if it is a specific character)
    if (nextByte == 'X') {
      // Do something
    }
  }
}

void processReceivedData(char* data) {
  // Process the received data
  // (e.g., perform calculations or send it to another device)
}
```
##### 4. Read Data, Do Something, and Send After

```cpp
void setup() {
  // Initialize UART baud rate
  Serial.begin(9600);
}

void loop() {
  // Check if there is any data available to read from the Serial port
  if (Serial.available()) {
    // Read the data from the Serial port
    char receivedByte = Serial.read();

    // Process the received data
    // (e.g., convert it to uppercase)
    char processedByte = toupper(receivedByte);

    // Send the processed data back to the Serial port
    Serial.print("Processed: ");
    Serial.println(processedByte);
  }
}

```
In this example, the Arduino board reads the data sent from the Serial monitor, processes it (e.g., converts it to uppercase), and sends the processed data back to the Serial port.

#### Использование библиотеки `SoftwareSerial.h`
1.  Чтение и вывод на компьютер:

```cpp
#include <SoftwareSerial.h>

SoftwareSerial mySerial(2, 3); // Установка пинов RX и TX для SoftwareSerial

void setup() {
  Serial.begin(9600); // Настройка стандартного Serial порта на скорость 9600 бит/с
  mySerial.begin(9600); // Настройка SoftwareSerial порта на скорость 9600 бит/с
}

void loop() {
  if (mySerial.available()) { // Проверка наличия данных в SoftwareSerial порту
    char data = mySerial.read(); // Чтение данных из SoftwareSerial порта
    Serial.print("Received: ");
    Serial.println(data); // Вывод данных в стандартный Serial порт
  }
}

```

2.  Передача данных на Arduino:

```cpp
#include <SoftwareSerial.h>

SoftwareSerial mySerial(2, 3); // Установка пинов RX и TX для SoftwareSerial

void setup() {
  Serial.begin(9600); // Настройка стандартного Serial порта на скорость 9600 бит/с
  mySerial.begin(9600); // Настройка SoftwareSerial порта на скорость 9600 бит/с
}

void loop() {
  if (Serial.available()) { // Проверка наличия данных в стандартном Serial порту
    char data = Serial.read(); // Чтение данных из стандартного Serial порта
    mySerial.print("Received: ");
    mySerial.println(data); // Отправка данных в SoftwareSerial порт
  }
}
```
#### [Кольцевой буфер](https://en.wikipedia.org/wiki/Circular_buffer)
[Заметка](https://habr.com/ru/companies/otus/articles/557310/)
```c++
// Circular buffer size
#define BUFFER_SIZE 128

// UART buffer
char uartBuffer[BUFFER_SIZE];
volatile uint8_t uartBufferHead = 0;
volatile uint8_t uartBufferTail = 0;

// UART receive interrupt handler
void uartReceiveISR() {
  // Read the received byte from UART
  char receivedByte = Serial.read();

  // Calculate the next buffer head index
  uint8_t nextHead = (uartBufferHead + 1) % BUFFER_SIZE;

  // Check if the buffer is full
  if (nextHead != uartBufferTail) {
    // Store the received byte in the buffer
    uartBuffer[uartBufferHead] = receivedByte;
    uartBufferHead = nextHead;
  }
}

void setup() {
  // Initialize UART baud rate
  Serial.begin(9600);

  // Set the UART receive interrupt
  Serial.setTimeout(1); // Set a short timeout to trigger receive ISR
  Serial.attachInterrupt(uartReceiveISR);
}

void loop() {
  // Check if there is any data in the buffer
  if (uartBufferTail != uartBufferHead) {
    // Calculate the next buffer tail index
    uint8_t nextTail = (uartBufferTail + 1) % BUFFER_SIZE;

    // Read the next byte from the buffer
    char nextByte = uartBuffer[uartBufferTail];
    uartBufferTail = nextTail;

    // Handle the received byte
    // (e.g., send it to another function for processing)
    processReceivedByte(nextByte);
  }

  // Other code in the main loop
}

void processReceivedByte(char receivedByte) {
  // Process the received byte
  // (e.g., print it to the Serial monitor)
  Serial.print("Received: ");
  Serial.println(receivedByte);
}

```
### I2C

`I2C`(Inter-Integrated Circuits, межмикросхемное соединение) - последовательная ассиметричная шина для связи интегральных схем. Другими словами это протокол синхронной связи. Это значит, что оба устройства, которые обмениваются информацией с помощью данного протокола, должны использовать общий канал синхронизации.

Этот протокол связи был придуман в компании `Phillips`, далее сертифицирован в 2000 годах. Так как многие компании не хотят платить за использование сертифицированного протокола, они используют аналоги с другими названиями, но с таким же принципом. В интернете вы можете увидеть другие названия протокола `I2C`.

Для чего нам эта шина? Чтобы разобраться в этом, давайте посмотрим как она устроена. Как уже говорилось выше, протокол соединяет два устройства двумя линиями, одно устройство будет ведущим а другое ведомым. Так вот, ведомых устройств может быть несколько! Это значит, что мы можем сделать ведущим устройством нашу плату, а к ней через `I2C` подключить несколько датчиков, используя всего два вывода на плате! То есть `I2C` превращает нашу плату в конструктор, к которому мы можем цеплять очень большое количество периферии!

Назначение линий:

- `SCL` - Serial Clock - по этой линии передается общий сигнал синхронизации, который генерируется ведущим устройством

 - `SDA` - Serial Data - по этой линии осуществляется передача данных между ведущим и ведомым

Ведущее устройство также называют `master`, а ведомое - `slave`.

В любой момент времени только ведущее устройство может инициировать процесс обмена данными. При этом, так как ведомых может быть несколько, ведущий должен обращаться к ним по адресам. Соответственно, только ведомый с указанным адресом должен отвечать на сигнал ведущего, а все остальные ведомые должны не реагировать на этот сигнал. По сути, в подключении устройств мы ограничены лишь адресами подключенных устройств. Адресов может быть 127.

Пример кода для использования `I2C`:
#### Пример
##### 1.  Чтение данных с датчика `BMP180`:

```cpp
#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BMP085.h>

Adafruit_BMP085 bmp;

void setup() {
  Serial.begin(9600);
  if (!bmp.begin()) {
    Serial.println("Could not find a valid BMP085 sensor, check wiring!");
    while (1);
  }
}

void loop() {
  float temperature = bmp.readTemperature();
  float pressure = bmp.readPressure() / 100.0;
  float altitude = bmp.readAltitude();

  Serial.print("Temperature: ");
  Serial.print(temperature);
  Serial.println(" *C");
  
  Serial.print("Pressure: ");
  Serial.print(pressure);
  Serial.println(" hPa");
  
  Serial.print("Altitude: ");
  Serial.print(altitude);
  Serial.println(" meters");

  delay(1000);
}

```

##### 2.  Управление дисплеем `LCD` с использованием библиотеки `LiquidCrystal_I2C.h`:

```cpp
#include <Wire.h>
#include <LiquidCrystal_I2C.h>

LiquidCrystal_I2C lcd(0x27, 16, 2); // Установка адреса и размеров дисплея

void setup() {
  lcd.begin(16, 2); // Инициализация дисплея
  lcd.backlight(); // Включение подсветки
  lcd.print("Hello, World!"); // Вывод текста на дисплей
}

void loop() {
  // Дополнительные операции с дисплеем
}
```

### SPI

`SPI` (Serial Peripheral Interface, последовательный периферийный интерфейс) - это синхронный последовательный интерфейс связи между микроконтроллером и другими периферийными устройствами. Он позволяет передавать данные по нескольким линиям одновременно, используя одну линию для синхронизации и отдельные линии для передачи данных.

`SPI` является широко распространенным интерфейсом на многих микроконтроллерах, включая `Arduino Uno`, и используется для связи с различными устройствами, такими как датчики, дисплеи, память и другие периферийные устройства.

Назначение линий:

-   `SCK` (Serial Clock) - линия синхронизации, которая устанавливает тактовую частоту передачи данных между микроконтроллером и периферийным устройством.
-   `MOSI` (Master Out Slave In) - линия передачи данных от микроконтроллера к периферийному устройству.
-   `MISO` (Master In Slave Out) - линия передачи данных от периферийного устройства к микроконтроллеру.
-   `SS` (Slave Select) - линия выбора ведомого устройства, используется для выбора конкретного периферийного устройства в множестве подключенных устройств.

`SPI` поддерживает полный дуплексный режим передачи данных, что означает, что микроконтроллер и периферийное устройство могут передавать данные одновременно в оба направления. Передача данных осуществляется побитово, с настройкой скорости передачи данных.

Основные характеристики `SPI`:

-   Режим передачи данных (`Mode`) - определяет состояние линий синхронизации и передачи данных, которое используется для выполнения передачи данных между микроконтроллером и периферийным устройством.
-   Скорость передачи данных (`bitrate`) - устанавливает скорость передачи данных между микроконтроллером и периферийным устройством.
-   Количество бит в кадре данных (`Bit Order`) - определяет порядок передачи битов данных, либо старший бит (`MSB`) передается первым, либо младший бит (`LSB`) передается первым.

Чтение и запись данных через `SPI` в Arduino Uno осуществляется с помощью библиотеки `SPI` и соответствующих функций, которые предоставляются в ней. Например, функция `SPI.transfer()` используется для передачи и чтения данных по линиям `SPI`.

Пример кода для использования `SPI`:

##### 1.  Запись и считывание данных с SD-карты:

```cpp
#include <SPI.h>
#include <SD.h>

File myFile;

void setup() {
  Serial.begin(9600);
  if (!SD.begin(10)) { // Инициализация SD-карты на пине 10
    Serial.println("No SD card found");
    while (1);
  }
  
  myFile = SD.open("example.txt", FILE_WRITE); // Открытие файла для записи
  if (myFile) {
    myFile.println("Hello, world!"); // Запись данных в файл
    myFile.close(); // Закрытие файла
  }
  
  myFile = SD.open("example.txt"); // Открытие файла для чтения
  if (myFile) {
    while (myFile.available()) {
      Serial.write(myFile.read()); // Чтение данных из файла и вывод в Serial порт
    }
    myFile.close(); // Закрытие файла
  }
}

void loop() {
  // Дополнительные операции с SD-картой
}
```

## Работа с различными сенсорами
### Виды сенсоров

На прошлом занятии мы познакомились с платой `Arduino`, ее средой программирования и получили общие знания об устройстве. Дальше по курсу мы будем углублять знания и каждое занятие будет посвящено отдельным функциям платы или определенным компонентам, принципам их работы. И сегодня мы познакомимся с сенсорами - средствами получения информации об окружающем мире.

Если говорить про `Arduino` с точки зрения IoT, то датчики играют очень важную роль. Так как эта концепция построена на считывании данных, `Arduino` является идеальной средой для прототипирования - подключаемых датчиков много, вплоть до модулей машинного зрения. Поэтому сегодня мы поговорим про сенсоры, какие они бывают, как получают информацию и какие процессы при этом происходят в нашей плате.

Давайте разделим все сенсоры на группы, в зависимости от считываемых данных. Можно выделить несколько групп:

-   **Климатические датчики**: измерение температуры и влажности воздуха, земли, измерение атмосферного давления и прочее.
    
-   **Датчики освещенности**: измерение интенсивности света и другие параметры света.
    
-   **Датчики определения в пространстве**: акселерометр, гироскоп, магнитометр.
    
-   **Датчики механического воздействия**: кнопки, потенциометры и другие элементы для взаимодействия с проектами.
    

Это основные группы, но существует большое количество различных датчиков, и некоторые из них нельзя отнести к какой-то конкретной группе, например, датчики газа.

### Библиотека Wire.h

Для начала давайте познакомимся с основными функциями и операторами библиотеки `Wire.h`. Напишем код, в котором `I2C` совместимый датчик будет ведомым устройством, а мы с платы будем запрашивать с него информацию. Библиотека не требует скачивания, так как по умолчанию добавлена в Arduino IDE.
```c++
#include <Wire.h>
  
int light_address = 29; //адрес нашего устройства
  
void setup() {
	Serial.begin(9600);
}
  
void loop() {
	Wire.beginTransmission(light_address); // начинаем общение с шиной
	Wire.begin();//инициализируем прослушаивание шины
	Wire.write(0);//отправляем ноль, чтобы считать показания с датчика
	Wire.endTransmission();//заканчиваем общение с шиной
	Wire.requestFrom(light_address, 1);//ждем единицу с датчика
	while(Wire.available() == 0);//цикл будет крутиться пока мы не получим информацию
		int c = Wire.read();// полученное значение добавляем в переменную
	Serial.println(c);
	delay(500);
}
```
  
Ведущий инициирует обмен данными. Для этого он генерирует импульсы(всего 9) и посылает их по линии `SCL`. Одновременно на линии `SDA` он выставляет адрес адрес устройства(ведомого), с которым необходимо установить связь. Адрес тактируется первыми семью тактами(отсюда ограничение подключаемых модулей, 2 в 7 степени = 128). Далее идет бит операции - чтение или запись, и бит подтверждения, что ведомое устройство получило запрос. Если бит подтверждения не пришел, обмен заканчивается, или ведущий продолжает посылать запросы.

![](https://lh6.googleusercontent.com/NJ0wn3EW5WLptAW6rEBC9h74yTDoYJoJBrRhoqjyjz9Rve1oP6piTz1Q4HE2SV2cNKWG-zDB_X_fHl1gKLh9f1lN-w7szTSmwerPE5NDO1cvy3bUa5dAIEeZQ9xra3M8dXSzKdGeXWrzDx4w10tsu7U)

  ### Датчик `I2C` VL6180X

Пример с датчиком освещенности и приближения. Обратите внимание, что данный датчик требует подключения дополнительной библиотеки. Используется схема с прошлого занятия, со сдвиговым регистром.

[Datasheet](http://wiki.amperka.ru/_media/%D0%BF%D1%80%D0%BE%D0%B4%D1%83%D0%BA%D1%82%D1%8B:troyka-proximity:dt_vl6180x.pdf)

  

![](https://lh6.googleusercontent.com/xp5FfKEsfX2rmTLEeeUe7DkXtYkZMbegIgY9cyuhVe4AOuTjxJTfO7qdnhxVjQovHCdGXSF7VjIvYJQX1vtM7rXENRvUAVrAw0saAstkZzXTDCoTNQ76_HBcqdgmagjJ49-BGX73NBnNM4ZHs6hjMA)
```c++
#include <Wire.h> //библиотека I2C
#include <SparkFun VL6180X.h> // библиотека для датчика
#define VL6180X_ADDRESS 0x29

VL6180x sensor(VL6180X_ADDRESS); // инициализация датчика
const int SER = 8;
const int LATCH = 9;
const int CLK = 10;
int vs[8] = {1,2,4,8,32,64,128,255};

void setup() {
	Serial.begin(9600);
	while (sensor.VL6180xInit()) {
		Serial.println("Failed to initalize");
		delay(1000);
		}
	sensor.VL6180xDefautSettings(); // загрузка настроек датчика по умолчанию
	delay(1000);
	pinMode(SER, OUTPUT);
	pinMode(LATCH, OUTPUT);
	pinMode(CLK, OUTPUT);
}

void loop() {
	int dist = sensor.getDistance();// метод для измерения расстояния
	dist = map(dist, 0, 200, 0, 8);
	dist = constrain(dist, 0, 8);
	digitalWrite(LATCH, LOW);
	shiftOut(SER, CLK, MSBFIRST, vs[dist]);
	digitalWrite(LATCH, HIGH);
	delay(10);
}
```

### Взаимодействие между двумя платами Arduino

Здесь мы будем использовать две платы Arduino, одна будет ведущим устройством, а вторая - ведомым. Ведущее устройство будет отправлять сообщения ведомому, которое будет выводить их в последовательный монитор порта, для того чтобы убедиться, что все работает.

![](https://lh3.googleusercontent.com/i6zLAPbBJpV51EwObHT-hvUGzL2_kSgb6xvihzl4HZ648g-zHhFff7kWdT-F2ic2flMwPPb_ccuiFFplnXB3bUlUSelKs4AAIUmPny2wyaVCmJ-9bfhKJfA8V6JJcTEcACISXuPh88PoYMaifDJm-w)

Как видите, в данном примере линии шины вынесены на плате под отдельным названием. Если вы используете плату `Arduino UNO`, у вас `SDA` и `SCL` это `A4` и `A5`. Резисторы - 4,7 кОм.

Далее можно открыть примеры скетча для библиотеки Wire, и воспользоваться следующими примерами: master_writer для ведущего устройства, и slave_receiver для ведомого. Ниже вы найдете эти скетчи. Для того, чтобы видеть приходящие сообщения, ведомое устройство мы оставим подключенным к компьютеру, а ведущее - к другому источнику питания.

#### Для ведущего устройства:
```c++
#include <Wire.h>
void setup() {
	Wire.begin(); // подключиться к шине i2c (для ведущего устройства
}
byte x = 0;

void loop() {
	// адрес не указывается)
	Wire.beginTransmission(4); // инициализировать передачу устройству #4
	Wire.write("x is ");
	Wire.write(x);
	Wire.endTransmission();
	x++;
	delay(500);
}
```
#### Для ведомого устройства:
```c++
#include <Wire.h> 

void setup() {
	Wire.begin(4); // подключиться к шине i2c с адресом #4
	Wire.onReceive(receiveEvent); //обработчик события
	Serial.begin(9600); //последовательного порта
}

void loop() {
	delay(100);
}

void receiveEvent(int howMany) {
	while (1 < Wire.available()) { // цикл по всем принятым байтам, кроме последнего
		char c = Wire.read(); // прочитать байт как
		Serial.print(c);// вывести символ
		int x = Wire.read(); целое число // прочитать байт как
		Serial.println(x);// вывести целое число
	}
}
```
Скетч для ведомого устройства использует прерывания для принятия сообщений.
### 1-Wire

Шина `1-Wire` служит целям, похожим на цели шины `I2C`, то есть она обеспечивает возможность взаимодействий микроконтроллеров с периферийными устройствами посредством минимального количества линий передачи данных. Стандарт `1-Wire`, разработанный в компании Dallas Semiconductor, свел потребность в линиях до логического минимума — всего одной. Шина имеет более низкое быстродействие, чем `I2C`, но обладает интересной особенностью — паразитным питанием (parasitic power), позволяющее подключать периферийные устройства к микроконтроллеру всего двумя проводами: `GND` (ground — земля) и комбинированным проводом питания и передачи данных.

Шина `1-Wire` поддерживается более узким диапазоном устройств, чем `I2C`. Большинство из них производят компании Dallas Semiconductor и Maxim. К их числу относятся устройства идентификации картриджей для принтеров, флеш-память и ЭСППЗУ, а также `АЦП`. Однако наибольшую популярность среди устройств `1-Wire` у радиолюбителей завоевал температурный датчик `DS18B20` компании Dallas Semiconductor.

`1-Wire` — это именно шина, а не соединение «точка–точка». К ней можно подключить до 255 устройств.

Так же как `I2C`, интерфейс `1-Wire` использует понятия ведущего и ведомого устройств. Микроконтроллер играет роль ведущего, а периферийные устройства — ведомых. Каждое ведомое устройство еще на заводе получает уникальный идентификационный номер, который часто называют адресом, чтобы его можно было идентифицировать на шине, к которой подключено множество ведомых. Адрес имеет размер `64` бита, что позволяет иметь примерно `1,8 × 1019` разных идентификационных номеров.

Подобно `I2C`, протокол `1-Wire` предусматривает переключение режима работы шины ведущим устройством на ввод и вывод, чтобы иметь возможность двусторонних взаимодействий. Однако в шине `1-Wire` отсутствует отдельная линия передачи тактовых сигналов, поэтому нули и единицы передаются длинными и короткими импульсами. Импульс длительностью 60 мкс обозначает 0, а длительностью 15 мкс — 1.

Обычно линия данных находится под напряжением с уровнем `HIGH`, но, когда микроконтроллеру (ведущему) требуется послать команду устройству, он генерирует специальный импульс сброса с уровнем `LOW` длительностью не менее 480 мкс. Вслед за ним следует последовательность импульсов 1 и 0.

#### Сканирование шины

Поскольку каждое ведомое устройство, подключенное к шине, имеет уникальный идентификационный номер, присвоенный на заводе, нужен какой-то способ определить адреса устройств, подключенных к шине. Было бы неблагоразумно «зашивать» адреса устройств в скетч, потому что в случае замены новое ведомое устройство будет иметь уже другой адрес и скетч не сможет обращаться к нему. Поэтому ведущее устройство (`Arduino`) должно создать своеобразную опись устройств на шине. Здесь следует отметить, что первые 8 бит в адресе определяют «семейство», которому принадлежит устройство, то есть по ним можно определить, является ли устройство, например, датчиком DS18B20 или относится к какому-то другому типу.

В библиотеке `OneWire` имеется функция `search`, которую можно использовать для поиска всех ведомых устройств на шине. Следующий пример выводит адреса всех устройств на шине в монитор последовательного порта:
```c++
#include <OneWire.h>

OneWire bus(10); // пин 10 как шина данных
void setup()
{
	Serial.begin(9600);
	byte address[8]; // 64 бита
	while (bus.search(address)) {
		for(int i = 0; i < 7; i++) {
			Serial.print(address[i], HEX);
			Serial.print(" "); 
		}
		// проверить контрольную сумму
		if (OneWire::crc8(address, 7) == address[7]) {
			Serial.println(" CRC OK"); 
			}
		else {
			Serial.println(" CRC FAIL"); 
			}
		}
}

void loop()
{
}
```
#### Пример
```c++
#include <OneWire.h>
#include <DallasTemperature.h>
const int busPin = 10;
OneWire bus(busPin);
DallasTemperature sensors(&bus);
DeviceAddress sensor;

void setup()
{
	Serial.begin(9600); sensors.begin();
	if (!sensors.getAddress(sensor, 0)) 
}

void loop() {
	sensors.requestTemperatures();
	float tempC = sensors.getTempC(sensor);
	Serial.println(tempC);
	delay(1000);

}
```
Этот скетч выводит в окно монитора последовательного порта температуру в градусах Цельсия, прочитанную с единственного датчика температуры
Может произойти такое, что вы не можете найти адрес вашего датчика, или адрес отличается от указанного. Для это есть специальный скетч по поиску адреса у устройства, совместимого с `I2C`. В этом скетче мы просто посылаем запрос на обмен данными на каждый адрес, и в итоге находим тот адрес, который нам отвечает.

```c++
void setup(){
	Wire.begin();
	Serial.begin(9600);
	while (!Serial);
	Serial.println("\nI2C Scanner");
}

void loop(){
	byte error, address;
	int nDevices;
	Serial.println("Scanning...");
	nDevices = 0;
	for(address = 8; address < 127; address++ ){
		Wire.beginTransmission(address);
		error = Wire.endTransmission();
		if (error == 0){
			Serial.print("I2C device found at address 0x");
			if (address<16)
				Serial.print("0");
			Serial.print(address,HEX);
			Serial.println(" !");
			nDevices++;
		}
		else if (error==4) {
			Serial.print("Unknown error at address 0x");
			if (address<16)
				Serial.print("0");
			Serial.println(address,HEX);
		}
	}
	if (nDevices == 0)
		Serial.println("No I2C devices found");
	else
		Serial.println("done");
delay(5000);
}
```

### Список дополнительных источников информации по программированию на С/С++ и Arduino
1) Русскоязычный справочный ресурс содержит переведенные примеры с официального сайта и справочную документацию http://arduino.ru/
2) Официальный сайт компании **Arduino**  https://www.arduino.cc/
3) Уроки по **Arduino**  https://lesson.iarduino.ru/
4) Уроки по **Arduino**  http://mypractic.ru/uroki-programmirovaniya-arduino-navigaciya-po-urokam
5) Уроки по **Arduino**  https://all-arduino.ru/category/uroki/
6) Уроки по **Arduino**  https://arduinomaster.ru/program/
7) Лекции и примеры программирования на С/С++ https://prog-cpp.ru/c/
8) Лекции и примеры программирования на С/С++ http://www.codenet.ru/progr/cpp/1/
9) Лекции и примеры программирования на С/С++ http://www.c-cpp.ru/
10) Исходный код **Arduino** https://github.com/arduino/ArduinoCore-avr
